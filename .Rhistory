plotting = TRUE)
colordistance:::pause()
}
recolorize <- function(img.path, method = "kmeans",
bins = 3, n = 10,
lower = NULL, upper = NULL,
transparent = TRUE,
resize = NULL, rotate = NULL,
plotting = TRUE, horiz = TRUE) {
# get method
method <- match.arg(tolower(method), c("kmeans", "histogram"))
# read in image
img.ext <- tolower(tools::file_ext(img.path))
if (img.ext %in% c("jpeg", "jpg", "png", "bmp")) {
img <- imager::load.image(img.path)
} else {
stop("Image must be either JPG, PNG, or BMP")
}
# resize if specified
if (!is.null(resize)) {
img <- imager::imresize(img, scale = resize, interpolation = 6)
}
# rotate if specified
if (!is.null(rotate)) {
img <- imager::imrotate(img, angle = rotate)
}
# undo what cimg does for some reason
img <- imager::ro
img <- imager::imrotate(img, -90)
# drop depth channel
# i don't want to talk about this
# someday we'll do it all with cimg objects
temp <- array(dim = dim(img)[c(1:2, 4)])
temp <- img[ , , 1, ]
img <- temp
rm(temp)
# make background condition
alpha.channel <- dim(img)[3] == 4 # is there a transparency channel?
bg.condition <- backgroundCondition(lower = lower, upper = upper,
center = NULL, radius = NULL,
transparent = transparent,
alpha.channel = alpha.channel)
# index background
bg.indexed <- backgroundIndex(img, bg.condition)
# color clusters & assign pixels
color.clusters <- colorClusters(bg.indexed$non.bg, method = method,
n = n, bins = bins)
# recolor based on assignments/centers
recolored <- recolorImage(bg.indexed, color.clusters, plotting = FALSE)
# plot result
if (plotting) {
plotRecolorized(recolored$recolored.img,
recolored$centers, horiz = horiz)
}
# returnables:
original.img <- img
recolored.img <- recolored$recolored.img
method <- if( method == "kmeans" ) {
list(method = "kmeans", n = n)
} else {
list(method = "histogram", bins = bins)
}
color.space <- "RGB"
centers <- color.clusters$centers
sizes <- table(color.clusters$pixel.assignments)
pixel.assignments <- color.clusters$pixel.assignments
# return em
return.list <- list(original.img = original.img,
recolored.img = recolored.img,
method = method,
color.space = color.space,
centers = centers,
sizes = sizes,
pixel.assignments = pixel.assignments)
}
img.k <- recolorize(images[i],
method = "kmeans", n = 20, resize = 2,
lower = rep(0.97, 3), upper = rep(1, 3),
plotting = TRUE)
recolorize <- function(img.path, method = "kmeans",
bins = 3, n = 10,
lower = NULL, upper = NULL,
transparent = TRUE,
resize = NULL, rotate = NULL,
plotting = TRUE, horiz = TRUE) {
# get method
method <- match.arg(tolower(method), c("kmeans", "histogram"))
# read in image
img.ext <- tolower(tools::file_ext(img.path))
if (img.ext %in% c("jpeg", "jpg", "png", "bmp")) {
img <- imager::load.image(img.path)
} else {
stop("Image must be either JPG, PNG, or BMP")
}
# resize if specified
if (!is.null(resize)) {
img <- imager::imresize(img, scale = resize, interpolation = 6)
}
# rotate if specified
if (!is.null(rotate)) {
img <- imager::imrotate(img, angle = rotate)
}
# undo what cimg does for some reason
img <- imager::imrotate(img, -90)
# drop depth channel
# i don't want to talk about this
# someday we'll do it all with cimg objects
temp <- array(dim = dim(img)[c(1:2, 4)])
temp <- img[ , , 1, ]
img <- temp
rm(temp)
# make background condition
alpha.channel <- dim(img)[3] == 4 # is there a transparency channel?
bg.condition <- backgroundCondition(lower = lower, upper = upper,
center = NULL, radius = NULL,
transparent = transparent,
alpha.channel = alpha.channel)
# index background
bg.indexed <- backgroundIndex(img, bg.condition)
# color clusters & assign pixels
color.clusters <- colorClusters(bg.indexed$non.bg, method = method,
n = n, bins = bins)
# recolor based on assignments/centers
recolored <- recolorImage(bg.indexed, color.clusters, plotting = FALSE)
# plot result
if (plotting) {
plotRecolorized(recolored$recolored.img,
recolored$centers, horiz = horiz)
}
# returnables:
original.img <- img
recolored.img <- recolored$recolored.img
method <- if( method == "kmeans" ) {
list(method = "kmeans", n = n)
} else {
list(method = "histogram", bins = bins)
}
color.space <- "RGB"
centers <- color.clusters$centers
sizes <- table(color.clusters$pixel.assignments)
pixel.assignments <- color.clusters$pixel.assignments
# return em
return.list <- list(original.img = original.img,
recolored.img = recolored.img,
method = method,
color.space = color.space,
centers = centers,
sizes = sizes,
pixel.assignments = pixel.assignments)
}
img.k <- recolorize(images[i],
method = "kmeans", n = 20, resize = 2,
lower = rep(0.97, 3), upper = rep(1, 3),
plotting = TRUE)
# white background, multiple images
for (i in 2:length(images)) {
img.k <- recolorize(images[i],
method = "kmeans", n = 20, resize = 2,
lower = rep(0.97, 3), upper = rep(1, 3),
plotting = TRUE)
colordistance:::pause()
}
# and now for this absolute horror show
# this is an indexing problem
# it creates a nausea-inducing vomitous recolor
# sorry
for (i in 2:length(images)) {
img.k <- recolorize(images[i],
method = "hist", bins = 2, resize = 2,
lower = rep(0.97, 3), upper = rep(1, 3),
plotting = TRUE)
colordistance:::pause()
}
# and now for this absolute horror show
# this is an indexing problem
# it creates a nausea-inducing vomitous recolor
# sorry
# it's different every time, somehow?
# try to find it funny
for (i in 2:length(images)) {
img.k <- recolorize(images[i],
method = "hist", bins = 2, resize = 2,
lower = rep(0.97, 3), upper = rep(1, 3),
plotting = TRUE)
colordistance:::pause()
}
# and now for this absolute horror show
# this is an indexing problem
# it creates a nausea-inducing vomitous recolor
# sorry
# it's different every time, somehow?
# try to find it funny
for (i in 2:6 {
# and now for this absolute horror show
# this is an indexing problem
# it creates a nausea-inducing vomitous recolor
# sorry
# it's different every time, somehow?
# try to find it funny
for (i in 2:6) {
img.k <- recolorize(images[i],
method = "hist", bins = 2, resize = 2,
lower = rep(0.97, 3), upper = rep(1, 3),
plotting = TRUE)
colordistance:::pause()
}
# or don't run it
for (i in 2:6) {
img.k <- recolorize(images[i],
method = "hist", bins = 3, resize = 2,
lower = rep(0.97, 3), upper = rep(1, 3),
plotting = TRUE, cex.text = 1.5)
colordistance:::pause()
}
devtools::load_all("~/Dropbox/color/recolorize")
# or don't run it
for (i in 2:6) {
img.k <- recolorize(images[i],
method = "hist", bins = 3, resize = 2,
lower = rep(0.97, 3), upper = rep(1, 3),
plotting = TRUE, cex.text = 1.5)
colordistance:::pause()
}
recolorize <- function(img.path, method = "kmeans",
bins = 3, n = 10,
lower = NULL, upper = NULL,
transparent = TRUE,
resize = NULL, rotate = NULL,
plotting = TRUE, horiz = TRUE,
cex.text = 1.5) {
# get method
method <- match.arg(tolower(method), c("kmeans", "histogram"))
# read in image
img.ext <- tolower(tools::file_ext(img.path))
if (img.ext %in% c("jpeg", "jpg", "png", "bmp")) {
img <- imager::load.image(img.path)
} else {
stop("Image must be either JPG, PNG, or BMP")
}
# resize if specified
if (!is.null(resize)) {
img <- imager::imresize(img, scale = resize, interpolation = 6)
}
# rotate if specified
if (!is.null(rotate)) {
img <- imager::imrotate(img, angle = rotate)
}
# undo what cimg does for some reason
img <- imager::imrotate(img, -90)
# drop depth channel
# i don't want to talk about this
# someday we'll do it all with cimg objects
temp <- array(dim = dim(img)[c(1:2, 4)])
temp <- img[ , , 1, ]
img <- temp
rm(temp)
# make background condition
alpha.channel <- dim(img)[3] == 4 # is there a transparency channel?
bg.condition <- backgroundCondition(lower = lower, upper = upper,
center = NULL, radius = NULL,
transparent = transparent,
alpha.channel = alpha.channel)
# index background
bg.indexed <- backgroundIndex(img, bg.condition)
# color clusters & assign pixels
color.clusters <- colorClusters(bg.indexed$non.bg, method = method,
n = n, bins = bins)
# recolor based on assignments/centers
recolored <- recolorImage(bg.indexed, color.clusters, plotting = FALSE)
# plot result
if (plotting) {
plotRecolorized(recolored$recolored.img,
recolored$centers, horiz = horiz,
cex.text = cex.text)
}
# returnables:
original.img <- img
recolored.img <- recolored$recolored.img
method <- if( method == "kmeans" ) {
list(method = "kmeans", n = n)
} else {
list(method = "histogram", bins = bins)
}
color.space <- "RGB"
centers <- color.clusters$centers
sizes <- table(color.clusters$pixel.assignments)
pixel.assignments <- color.clusters$pixel.assignments
# return em
return.list <- list(original.img = original.img,
recolored.img = recolored.img,
method = method,
color.space = color.space,
centers = centers,
sizes = sizes,
pixel.assignments = pixel.assignments)
}
# or don't run it
for (i in 2:6) {
img.k <- recolorize(images[i],
method = "hist", bins = 3, resize = 2,
lower = rep(0.97, 3), upper = rep(1, 3),
plotting = TRUE, cex.text = 1.5)
colordistance:::pause()
}
# plots a recolored image + its color palette
plotRecolorized <- function(recolored.img, color.centers, horiz = FALSE,
cex.text = 2) {
# for resetting
user.par <- par(no.readonly = TRUE)
# layout
if (horiz) {
layout(matrix(c(2, 1), 1, 2),
widths = c(0.2, 0.8))
} else {
layout(matrix(c(1, 2), 2, 1),
heights = c(0.8, 0.2))
}
# plotting image
par(mar = rep(0.5, 4))
plotImageArray(recolored.img)
# plotting palette
par(mar = rep(0.5, 4))
plotColorPalette(color.centers, horiz = horiz, cex.text = cex.text)
# reset parameters
par(user.par)
}
img.k <- recolorize(images[i],
method = "hist", bins = 3, resize = 2,
lower = rep(0.97, 3), upper = rep(1, 3),
plotting = TRUE, cex.text = 1.5)
# or don't run it
for (i in 2:6) {
img.k <- recolorize(images[i],
method = "hist", bins = 3, resize = 2,
lower = rep(0.97, 3), upper = rep(1, 3),
plotting = TRUE, cex.text = 1.5)
colordistance:::pause()
}
# Load the code ####
# load libraries
install.packages("here", "imager")
library(here)
img <- "~/Downloads/image.png"
devtools::load_all(".")
img.k <- recolorize(img)
img.k <- recolorize(img, n = 50)
img.k$centers
img.k <- recolorize(img, n = 50, lower = c(0.13, 0.22, 0.25), upper = c(0.16, 0.26, 0.29))
img.k <- recolorize(img, n = 4,
lower = c(0.13, 0.22, 0.25),
upper = c(0.16, 0.26, 0.29))
img.k$centers
img
img.path <- img
method <- "kmeans"
# read in image
img.ext <- tolower(tools::file_ext(img.path))
if (img.ext %in% c("jpeg", "jpg", "png", "bmp")) {
img <- imager::load.image(img.path)
} else {
stop("Image must be either JPG, PNG, or BMP")
}
# undo what cimg does for some reason
img <- imager::imrotate(img, 90)
# drop depth channel
# i don't want to talk about this
# someday we'll do it all with cimg objects
temp <- array(dim = dim(img)[c(1:2, 4)])
temp <- img[ , , 1, ]
img <- temp
rm(temp)
plotImageArray(img)
img <- imager::load.image(img.path)
# drop depth channel
# i don't want to talk about this
# someday we'll do it all with cimg objects
temp <- array(dim = dim(img)[c(1:2, 4)])
plotImageArray(temp)
# drop depth channel
# i don't want to talk about this
# someday we'll do it all with cimg objects
temp <- array(dim = dim(img)[c(1:2, 4)])
temp <- img[ , , 1, ]
plotImageArray(temp)
img <- imager::load.image(img.path)
plot(img)
# drop depth channel
# i don't want to talk about this
# someday we'll do it all with cimg objects
temp <- array(dim = dim(img)[c(1:2, 4)])
temp <- img[ , , 1, ]
plotImageArray(temp)
install.packages("magick")
install.packages("magick")
img <- raster::flip(img, 'x')
?raster::flip
# drop depth channel
# i don't want to talk about this
# someday we'll do it all with cimg objects
temp <- array(dim = dim(img)[c(1:2, 4)])
temp <- img[ , , 1, ]
img <- temp
plotImageArray(img)
plotImageArray(img)
devtools::load_all(".")
plotImageArray(img)
img <- raster::flip(img, direction = 'x')
img <- png::readPNG(img.path)
is.raster(img)
img <- png::readPNG(img.path, native = TRUE)
is.raster(img)
img <- imager::load.image(img.path)
# undo what cimg does for some reason
img <- imager::imrotate(img, 90)
# drop depth channel
# i don't want to talk about this
# someday we'll do it all with cimg objects
temp <- array(dim = dim(img)[c(1:2, 4)])
temp <- img[ , , 1, ]
img <- temp
plotImageArray(img)
img <- apply(img, 1, rev)
plotImageArray(img)
dim(img)
img <- imager::load.image(img.path)
# undo what cimg does for some reason
img <- imager::imrotate(img, 90)
# drop depth channel
# i don't want to talk about this
# someday we'll do it all with cimg objects
temp <- array(dim = dim(img)[c(1:2, 4)])
temp <- img[ , , 1, ]
img <- temp
dim(img)
img <- apply(img, 3, function(i) apply(i, 1, rev))
dim(img)
img <- imager::load.image(img.path)
# drop depth channel
# i don't want to talk about this
# someday we'll do it all with cimg objects
temp <- array(dim = dim(img)[c(1:2, 4)])
temp <- img[ , , 1, ]
#img <- temp
plotImageArray(temp)
# undo what cimg does for some reason
img <- imager::imrotate(img, -90)
# drop depth channel
# i don't want to talk about this
# someday we'll do it all with cimg objects
temp <- array(dim = dim(img)[c(1:2, 4)])
temp <- img[ , , 1, ]
#img <- temp
plotImageArray(temp)
#img <- temp
rotate = function(mat) t(mat[nrow(mat):1,,drop=FALSE])
a <- matrix(c(1:10,10:1), ncol=2)
rotate(a)
a
#img <- temp
rotate = function(mat) (mat[nrow(mat):1,,drop=FALSE])
a
rotate(a)
#img <- temp
rotate = function(mat) (mat[,ncol(mat):1,drop=FALSE])
rotate(a)
a
rotate(a)
temp <- apply(temp, 3, rotate)
plotImageArray(temp)
dim(temp)
temp <- img[ , , 1, ]
temp <- apply(temp[,,1], 2, rotate)
temp[,,1]
temp[,,1] %>% dim
library(magrittr)
temp[,,1] %>% dim
test <- temp[,,1]
test2 <- rotate(test)
dim(test2)
plotImageArray(test2)
temp[,,,] <- test2
temp[,,] <- test2
plotImageArray(temp)
test <- apply(temp, 3, rotate)
dim(test)
temp[,,] <- apply(temp, 3, rotate)
# drop depth channel
# i don't want to talk about this
# someday we'll do it all with cimg objects
temp <- array(dim = dim(img)[c(1:2, 4)])
temp <- img[ , , 1, ]
temp[,,] <- apply(temp, 3, rotate)
plotImageArray(temp)
img <- imager::load.image(img.path)
# drop depth channel
# i don't want to talk about this
# someday we'll do it all with cimg objects
temp <- array(dim = dim(img)[c(1:2, 4)])
temp <- img[ , , 1, ]
#img <- temp
temp[ , , ] <- apply(temp, 3, function(mat) mat[ , ncol(mat):1, drop=FALSE])
plotImageArray(temp)
# undo what cimg does for some reason
img <- imager::imrotate(img, -90)
# drop depth channel
# i don't want to talk about this
# someday we'll do it all with cimg objects
temp <- array(dim = dim(img)[c(1:2, 4)])
temp <- img[ , , 1, ]
#img <- temp
temp[ , , ] <- apply(temp, 3, function(mat) mat[ , ncol(mat):1, drop=FALSE])
plotImageArray(temp)
