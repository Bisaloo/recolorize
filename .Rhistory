layers <- splitByColor(re_fit)
# define image path - we're using an image that comes with the package
img_path <- system.file("extdata/corbetti.png", package = "recolorize")
# load image
img <- readImage(img_path)
# it's just an array with 4 channels:
dim(img)
layout(matrix(1:5, nrow = 1))
plotImageArray(img, main = "RGB image")
plotImageArray(img[ , , 1], main = "R channel")
plotImageArray(img[ , , 2], main = "G channel")
plotImageArray(img[ , , 3], main = "B channel")
plotImageArray(img[ , , 4], main = "Alpha channel")
layout(matrix(1:5, nrow = 1))
plotImageArray(img, main = "RGB image")
plotImageArray(img[ , , 1], main = "R channel")
plotImageArray(img[ , , 2], main = "G channel")
plotImageArray(img[ , , 3], main = "B channel")
plotImageArray(img[ , , 4], main = "Alpha channel")
corbetti <- system.file("extdata/corbetti.png", package = "recolorize")
# using all the default parameters:
recolorize_defaults <- recolorize(img = corbetti)
# you can also read in the image as an array:
corbetti_array <- readImage(corbetti)
# and then pass it to the recolorize function
# (not plotting this time since it gives you identical results)
recolorize_defaults <- recolorize(img = corbetti_array, plotting = FALSE)
class(recolorize_defaults)
attributes(recolorize_defaults)
summary(recolorize_defaults)
dim(recolorize_defaults$recolored_img)
dim(recolorize_defaults$pixel_assignments)
# using just the pixel_assignments and centers to recreate the recolored image:
recolored_img <- constructImage(pixel_assignments = recolorize_defaults$pixel_assignments,
centers = recolorize_defaults$centers)
# we can also pass a different set of centers:
new_centers <- viridisLite::viridis(8)
new_centers <- t(col2rgb(new_centers) / 255)
viridis_img <- constructImage(pixel_assignments = recolorize_defaults$pixel_assignments,
centers = new_centers)
layout(matrix(1:2, nrow = 1))
plotImageArray(recolored_img, main = "recolored image")
plotImageArray(viridis_img, main = "swapped centers")
# where we're going, we don't need figure margins!
par(mar = rep(0, 4))
# all colors the same size, with printed numbers for their index
plotColorPalette(centers = recolorize_defaults$centers)
# colors proportional to their region size in the image
plotColorPalette(centers = recolorize_defaults$centers,
sizes = recolorize_defaults$sizes)
# where we're going, we don't need figure margins!
par(mar = rep(0, 4))
# all colors the same size, with printed numbers for their index
plotColorPalette(centers = recolorize_defaults$centers)
# number of bins is ^3, so we'll specify 2 bins and 8 kmeans clusters to get 8 color centers either way:
hist_obj <- recolorize(corbetti, method = "histogram", bins = 2)
kmeans_obj <- recolorize(corbetti, method = "kmeans", n = 8)
layout(matrix(1:3, nrow = 1))
# using increasing numbers of bins per channel:
for (i in 2:4) {
hist_fit <- recolorize(corbetti, method = "hist", bins = i, plotting = FALSE)
plotColorClusters(centers = hist_fit$centers,
sizes = hist_fit$sizes, scaling = 10,
tick.marks = F, xlab = "R", ylab = "G", zlab = "B",
main = paste(i, "bins per channel"))
}
plot(hist_fit, sizes = TRUE)
library(recolorize)
k_vec <- 3:10
layout(matrix(1:8, nrow = 2))
for (i in k_vec) {
kmeans_fit <- recolorize(corbetti, "k", n = i, plotting = FALSE)
plotColorClusters(centers = kmeans_fit$centers,
sizes = kmeans_fit$sizes, scaling = 10,
tick.marks = F,
xlab = "", ylab = "", zlab = "",
main = paste("n =", i),
mar = c(2, 1, 2, 1),
xlim = 0:1, ylim = 0:1, zlim = 0:1)
}
```{r, fig.width = 6, fig.height = 4}
kmeans_1 <- recolorize(corbetti, method = "k", n = 8, plotting = FALSE)
kmeans_2 <- recolorize(corbetti, method = "k", n = 8, plotting = FALSE)
kmeans_3 <- recolorize(corbetti, method = "k", n = 8, plotting = FALSE)
layout(matrix(1:6, nrow = 1), widths = c(rep(.25, 3),
rep(.25/3, 3)))
for (i in list(kmeans_1, kmeans_2, kmeans_3)) {
par(mar = rep(0, 4))
plotImageArray(i$recolored_img)
}
for (i in list(kmeans_1, kmeans_2, kmeans_3)) {
par(mar = rep(0, 4))
plotColorPalette(i$centers, i$sizes, horiz = FALSE)
}
# image path
corbetti <- system.file("extdata/corbetti.png", package = "recolorize")
# using default settings
init_fit <- recolorize(corbetti, method = "histogram", bins = 2, color_sapce = "sRGB")
# using default settings
init_fit <- recolorize(corbetti, method = "histogram", bins = 2, color_space = "sRGB")
recluster_fit <- recluster(init_fit, color_space = "Lab", similarity_cutoff = 60, plot_hclust = TRUE)
recluster_fit <- recluster(init_fit, color_space = "Lab", similarity_cutoff = 45, plot_hclust = TRUE)
threshold_fit <- thresholdRecolor(init_fit, pct = 0.05)
threshold_fit <- thresholdRecolor(init_fit, pct = 0.01)
# this isn't as effective
threshold_fit <- thresholdRecolor(init_fit, pct = 0.02)
init_fit <- recolorize(corbetti, method = "histogram", bins = 3, color_space = "sRGB")
# this isn't as effective
threshold_fit <- thresholdRecolor(init_fit, pct = 0.02)
# this isn't as effective
threshold_fit <- thresholdRecolor(init_fit, pct = 0.05)
# this isn't as effective
threshold_fit <- thresholdRecolor(init_fit, pct = 0.1)
# this isn't as effective
threshold_fit <- thresholdRecolor(init_fit, pct = 0.05)
plot(init_fit)
# using default settings
init_fit <- recolorize(corbetti, method = "histogram", bins = 2, color_space = "sRGB")
plot(init_fit)
merge_fit <- mergeLayers(init_fit, merge_list = list(1, 2,
c(3, 5),
c(4, 7),
c(6, 8)))
# we can clean/despeckle layers:
edited_fit <- editLayer(merge_fit, layer_idx = 1, operation = "clean", px_size = 2)
# we can clean/despeckle layers:
edited_fit <- editLayer(merge_fit, layer_idx = 1, operation = "fill", px_size = 2)
# we can clean/despeckle layers:
edited_fit <- editLayer(merge_fit, layer_idx = 1, operation = "shrink", px_size = 2)
# we can clean/despeckle layers:
edited_fit <- editLayer(merge_fit, layer_idx = 1, operation = "shrink", px_size = 3)
edited_fit2 <- editLayer(edited_fit, layer_idx = 1, operation = "grow", px_size = 2)
edited_fit2 <- editLayer(edited_fit, layer_idx = 1, operation = "grow", px_size = 3)
# we can clean/despeckle layers:
edited_fit <- editLayer(merge_fit, layer_idx = 1, operation = "clean", px_size = 3)
# we can clean/despeckle layers:
edited_fit <- editLayer(merge_fit, layer_idx = 1, operation = "clean", px_size = 2)
edited_fit2 <- editLayer(merge_fit, layer_idx = 1, operation = "fill", px_size = 2)
# we can do several layers at once:
edited_multiple <- editLayers(merge_fit)
# we can do several layers at once:
edited_multiple <- editLayers(merge_fit, operations = "shrink", px_sizes = 8)
# we can do several layers at once:
edited_multiple <- editLayers(merge_fit, operations = "shrink", px_sizes = 5)
# we can do several layers at once:
edited_multiple <- editLayers(merge_fit, operations = "clean", px_sizes = 5)
# we can do several layers at once:
edited_multiple <- editLayers(merge_fit, operations = "clean", px_sizes = 10)
dir(system.file("extdata", package = "recolorize"))
im1 <- system.file("extdata/ocellata.png", package = "recolorize")
im2 <- system.file("extdata/ephippigera.png", package = "recolorize")
fit_1 <- recolorize(im1)
fit_2 <- imposeColors(im2, centers = fit_1$centers)
fit_2 <- imposeColors(im2, centers = fit_1$centers, adjust_centers = FALSE)
rgb_centers <- col2rgb(c("red", "green", "blue",
"cyan", "magenta", "yellow",
"black", "white"))
rgb_centers
rgb_centers <- t(col2rgb(c("red", "green", "blue",
"cyan", "magenta", "yellow",
"black", "white")) / 255)
fit_rgb <- imposeColors(im2, centers = rgb_centers, adjust_centers = FALSE)
# image path
fulgidissima <- system.file("extdata/fulgidissima.png", package = "recolorize")
# load image
img <- readImage(fulgidissima)
# load image
img <- readImage(fulgidissima)
?blurImage
#
blurred_img <- blurImage(img, blur_function = "blur_anisotropic", 2)
#
blurred_img <- blurImage(img, blur_function = "blur_anisotropic", 5)
#
blurred_img <- blurImage(img, blur_function = "blur_anisotropic", amplitude = 5)
#
blurred_img <- blurImage(img, blur_function = "blur_anisotropic",
amplitude = 5, sharpness = 3)
#
blurred_img <- blurImage(img, blur_function = "blur_anisotropic",
amplitude = 1, sharpness = 3)
#
blurred_img <- blurImage(img, blur_function = "blur_anisotropic",
amplitude = 2, sharpness = 3)
#
blurred_img <- blurImage(img, blur_function = "blur_anisotropic",
amplitude = 2, sharpness = 1)
#
blurred_img <- blurImage(img, blur_function = "blur_anisotropic",
amplitude = 2, sharpness = 10)
#
blurred_img <- blurImage(img, blur_function = "medianblur",
n = 5, threshold = 0.5)
#
blurred_img <- blurImage(img, blur_function = "medianblur",
n = 5, threshold = 0.4)
#
blurred_img <- blurImage(img, blur_function = "medianblur",
n = 5, threshold = 0.2)
init_fit
recolorize_obj <- init_fit
pixel_idx <- which(recolorize_obj$pixel_assignments != 0)
pixel_idx
# get residuals in given color space
imDist(recluster_fit$original_img,
recluster_fit$recolored_img)
# get residuals in given color space
imDist(merge_fit$recolored_img,
recluster_fit$recolored_img)
# we can identify the hotspots of differences between two clustering methods:
imdist <- imDist(merge_fit$recolored_img,
recluster_fit$recolored_img)
# we can identify the hotspots of differences between two clustering methods:
fit_dist <- imDist(merge_fit$recolored_img,
recluster_fit$recolored_img)
hist(fit_dist)
hist(fit_dist > 0)
hist(fit_dist[which(fit_dist > 0)])
# or between the original image and the color map:
im_dist <- imDist(merge_fit$original_img,
merge_fit$recolored_img)
?imDist
# we can identify the hotspots of differences between two clustering methods:
fit_dist <- imDist(merge_fit$recolored_img,
recluster_fit$recolored_img)
# or between the original image and the color map:
im_dist <- imDist(merge_fit$original_img,
merge_fit$recolored_img)
hist(im_dist)
# we can see how our residuals are distributed:
hist(sqrt(im_dist^2))
# we can see how our residuals are distributed:
hist(sqrt(im_dist^2))
# and we can split by color
layers <- splitByColor(merge_fit, plot_method = "binary")
# and we can split by color
layout(matrix(1:5, nrow = 1))
layers <- splitByColor(merge_fit, plot_method = "binary")
layers <- splitByColor(merge_fit, plot_method = "colormask")
layers <- splitByColor(merge_fit, plot_method = "binary")
as_classify <- classify_recolorize(recluster_fit)
devtools::load_all(".")
# we can see how our residuals are distributed:
hist(im_dist, main = "CIE Lab distances")
as_classify <- classify_recolorize(recluster_fit)
classify_obj <- classify_recolorize(recluster_fit)
test <- pavo::adjacent(classify_obj)
test <- pavo::adjacent(classify_obj, xscale = 10)
devtools::load_all(".")
?recluster
# get an image
corbetti <- system.file("extdata/corbetti.png", package = "recolorize")
# too many color centers
recolored_corbetti <- recolorize(corbetti, bins = 3)
# just enough!
# check previous plot for clustering cutoff
recluster_obj <- recluster(recolored_corbetti,
similarity_cutoff = 60,
plot_hclust = TRUE,
refit_method = "impose")
devtools::load_all(".")
# get an image
corbetti <- system.file("extdata/corbetti.png", package = "recolorize")
# too many color centers
recolored_corbetti <- recolorize(corbetti, bins = 3)
# just enough!
# check previous plot for clustering cutoff
recluster_obj <- recluster(recolored_corbetti,
similarity_cutoff = 60,
plot_hclust = TRUE,
refit_method = "impose")
par(mar = c(3, 2, 0, 0))
plot(hcd, xlab = "", ylab = paste(color_space, "color distance"))
devtools::load_all(".")
# get an image
corbetti <- system.file("extdata/corbetti.png", package = "recolorize")
# too many color centers
recolored_corbetti <- recolorize(corbetti, bins = 3)
# just enough!
# check previous plot for clustering cutoff
recluster_obj <- recluster(recolored_corbetti,
similarity_cutoff = 60,
plot_hclust = TRUE,
refit_method = "impose")
devtools::load_all(".")
# get an image
corbetti <- system.file("extdata/corbetti.png", package = "recolorize")
# too many color centers
recolored_corbetti <- recolorize(corbetti, bins = 3)
# just enough!
# check previous plot for clustering cutoff
recluster_obj <- recluster(recolored_corbetti,
similarity_cutoff = 60,
plot_hclust = TRUE,
refit_method = "impose")
devtools::load_all(".")
centers
centers <- recolored_corbetti$centers
centers
col2col(centers, "sRGB", "sRGB")
hex_col <- grDevices::rgb(centers)
hex_col
library(recolorize)
recluster_results <- recluster(recolorize_defaults,
similarity_cutoff = 45)
corbetti <- system.file("extdata/corbetti.png", package = "recolorize")
# using all the default parameters:
recolorize_defaults <- recolorize(img = corbetti)
recluster_results <- recluster(recolorize_defaults,
similarity_cutoff = 45)
recluster_rgb <- recluster(recolorize_defaults, color_space = "sRGB",
similarity_cutoff = 0.5)
similarity_cutoff = 0.5)
?thresholdRecolor
chongi <- system.file("extdata/chongi.png", package = "recolorize")
chongi_1 <- recolorize(chongi)
chongi_1 <- recolorize(chongi, bins = 3)
chongi_1 <- recolorize(chongi, bins = 2)
chongi_2 <- thresholdRecolor(chongi_1)
chongi_1 <- recolorize(chongi, bins = 3)
chongi_2 <- thresholdRecolor(chongi_1)
chongi_1 <- recolorize(chongi, color_space = "Lab", bins = 3)
chongi_2 <- thresholdRecolor(chongi_1)
chongi_1 <- recolorize(chongi, color_space = "sRGB", bins = 3)
chongi_1 <- recolorize(chongi, color_space = "sRGB", bins = 2)
chongi_2 <- thresholdRecolor(chongi_1)
corbetti_impose <- imposeColors(corbetti,
centers = t(col2rgb(c("black",
"white",
"red",
"green",
"blue")) / 255))
corbetti_impose <- imposeColors(corbetti, color_space = "sRGB",
centers = t(col2rgb(c("black",
"white",
"red",
"green",
"blue")) / 255))
dir(system.file("extdata", package = "recolorize"))
fit1 <- recolorize(im1)
im1 <- system.file("extdata/ocellata.png", package = "recolorize")
im2 <- system.file("extdata/ephippigera.png", package = "recolorize")
fit1 <- recolorize(im1)
fit2 <- imposeColors(im2)
fit2 <- imposeColors(im2, centers = fit1$centers)
fit1 <- recolorize(im1)
fit2 <- imposeColors(im2, centers = fit1$centers)
# edit a single layer
editLayer(recluster_fit, 1, "clean", 2)
# edit a single layer
editLayer(recluster_results, 1, "clean", 2)
# edit a single layer
cream_edit <- editLayer(recluster_results, layer_idx = 2, operation = "clean", px_size = 2)
# edit a single layer
cream_edit <- editLayer(recluster_results, layer_idx = 2, operation = "clean", px_size = 3)
# edit multiple layers
mondrian <- editLayers(cream_edit, operations = "clean", px_sizes = 10)
# edit multiple layers
mondrian <- editLayers(recluster_results, operations = "clean", px_sizes = 10)
merge_fit <- mergeLayers(recolorize_defaults,
merge_list = list(1, 2,
c(3, 5),
c(4, 7),
c(6, 8)))
```{r, fig.width=5}
layout(matrix(1:2, 1))
plotImageArray(recluster_results$recolored_img, main = "recluster")
plotImageArray(merge_fit$recolored_img, main = "mergeLayers")
dist_original <- imDist(recluster_results$original_img,
recluster_results$recolored_img)
dist_fits <- imDist(recolorize_defaults$recolored_img,
recluster_results$recolored_img)
dist_fits <- imDist(merge_fit$recolored_img,
recluster_results$recolored_img)
dist_fits <- imDist(merge_fit$recolored_img,
recluster_results$recolored_img, color_space = "sRGB")
sum(dist_fits)
sum(dist_original, na.rm = TRUE)
hist(dist_original, na.rm = TRUE)
hist(dist_original, main = "CIE Lab residuals", xlab = "CIE Lab distance")
layout(matrix(1:5, nrow = 1))
layers <- splitByColor(recluster_results)
image(layers[[1]])
image(layers[[1]], col = c("black", "white"))
image(t(layers[[1]]), col = c("black", "white"))
plotImageArray(layers[[1]])
lapply(layers, plotImageArray)
as_classify <- classify_recolorize(recluster_results, imgname = "corbetti")
adj_analysis <- pavo::adadjacent(as_classify, xscale = 10)
as_classify <- classify_recolorize(recluster_results, imgname = "corbetti")
adj_analysis <- pavo::adjacent(as_classify, xscale = 10)
img_all <- imgs[5]
imgs <- dir("../misc_images/nielsen_colias/", "png", full.names = TRUE)[-3]
imgs
img_all <- imgs[5]
library(recolorize)
test <- readImage(img_all)
plotImageArray(test)
dim(test)
fit1 <- recolorize(img_all, bins = 2)
fit1 <- recolorize(img_all, bins = 3)
fit1 <- recolorize(img_all, color_space = "Lab",
bins = c(3, 5, 3))
fit1 <- recolorize(img_all,
color_space = "Lab",
bins = c(3, 6, 3))
fit2 <- recolorize(img_all,
color_space = "sRGB",
bins = c(5, 5, 3))
fit2 <- recolorize(img_all, method = "k",
n = 6)
fit2 <- recolorize(img_all, color_space = "Lab",
method = "k",
n = 6)
fit1 <- recolorize(img_all,
color_space = "Lab",
bins = 5)
fit2 <- recluster(similarity_cutoff = 30)
fit2 <- recluster(fit1, similarity_cutoff = 30)
# this seems to work
fit1 <- recolorize(img_all,
color_space = "Lab",
bins = c(3, 5, 3))
layers <- splitByColor(fit1, plot_method = "colormask")
fit1$sizes
layers <- splitByColor(fit1, layers = which(fit1$sizes > 0),
plot_method = "colormask")
layout(matrix(1:6, 2))
layers <- splitByColor(fit1, layers = which(fit1$sizes > 1000),
plot_method = "colormask")
plotColorClusters(centers = fit1$centers,
sizes = fit1$sizes,
color_space = "Lab")
plotColorClusters(centers = fit1$centers,
sizes = fit1$sizes,
color_space = "sRGB")
convertColor(fit1$centers, "sRGB", "Lab")
plotColorClusters(centers = convertColor(fit1$centers, "sRGB", "Lab"),
sizes = fit1$sizes,
color_space = "Lab")
plotColorClusters(centers = convertColor(fit1$centers, "sRGB", "Lab"),
sizes = fit1$sizes,
color_space = "Lab",scaling = 15)
fit2 <- imposeColors(fit1$recolored_img,
centers = fit1$centers[which(fit1$sizes > 1000), ])
layout(matrix(1:6, 2))
layers <- splitByColor(fit2, plot_method = "colormask")
fit3 <- mergeLayers(fit2, merge_list = list(c(3, 5),
c(2, 4)))
help(package = "cluster")
imgs <- dir("../misc_images/nielsen_colias/", "png", full.names = TRUE)[-3]
imgs
img_all <- imgs[5]
library(recolorize)
# this seems to work quite well:
fit1 <- recolorize(img_all,
color_space = "Lab",
bins = c(3, 5, 3))
# but notice we have quite a few empty or very tiny patches:
fit1$sizes
# we can fold those into their most similar major patch by re-fitting with
# only those color patches which are >1000 pixels
fit2 <- imposeColors(fit1$recolored_img,
centers = fit1$centers[which(fit1$sizes > 1000), ])
# finally, we can see that some of the melanistic and yellow patches are broken
layout(matrix(1:6, 2))
layers <- splitByColor(fit2, plot_method = "colormask")
fit3 <- mergeLayers(fit2, merge_list = list(c(3, 5),
c(2, 4)))
# I certainly see what you mean about the k-means clusters...!
fit_k <- recolorize(img_all,
color_space = "Lab",
method = "k",
n = 4)
# combining the layers
fit3 <- mergeLayers(fit2, merge_list = list(c(3, 5),
c(2, 4)),
color_to = fit2$centers[c(5, 2), ])
# merging layers returns the average color of all pixels
# assigned to that patch by default (above),
# but this often results in duller colors, so you can also
# specify which colors to set using color_to:
fit3_pick_colors <- mergeLayers(fit2, merge_list = list(c(3, 5),
c(2, 4)),
color_to = fit2$centers[c(5, 2), ])
plot(fit3_pick_colors)
layout(matrix(1:2, 1))
layout(matrix(1:2, 1))
plotImageArray(fit1$original_img)
plotImageArray(fit3$recolored_img)
imgs <- dir("../misc_images/nielsen_colias/", "png", full.names = TRUE)[-3]
imgs
imgs <- dir("../misc_images/nielsen_colias/", "_D.png", full.names = TRUE)[-3]
imgs
fit_impose <- imposeColors(imgs[2],
centers = fit3$centers)
fit_impose <- imposeColors(imgs[2],
centers = fit2$centers)
# what about the other guy?
fit_img2 <- recolorize(imgs[2],
color_space = "Lab",
bins = c(3, 5, 3))
# what about the other guy?
fit1_img2 <- recolorize(imgs[2],
color_space = "Lab",
bins = c(3, 6, 3))
# this works alright:
fit_impose <- imposeColors(imgs[2], color_space = "Lab",
centers = fit2$centers)
# this works alright:
fit_impose <- imposeColors(imgs[2], color_space = "Lab",
centers = fit2$centers, adjust_centers = FALSE)
