merge_list,
color_to)
merge_list <- pm$merge_list
color_to <- pm$color_to
# convert recolored image to a cimg object
cimg_obj <- array_to_cimg(recolorize_obj$recolored_img,
flatten_alpha = T)
# split the layers
layers <- splitByColor(recolorize_obj,
plot_method = "none")
# get centers and sizes
centers <- recolorize_obj$centers
sizes <- recolorize_obj$sizes
centers
sizes
# get the list of untouched layers
orig_layers <- which(!(1:length(layers) %in% unlist(merge_list)))
orig_layers
new_centers <- centers[orig_layers, ]
new_sizes <- sizes[orig_layers]
new_centers
new_sizes
px_assign <- matrix(0,
nrow = nrow(recolorize_obj$pixel_assignments),
ncol = ncol(recolorize_obj$pixel_assignments))
length(orig_layers)
i
i = 1
# get the vector of colors to combine
merge_vector <- merge_list[[i]]
# extract the first layer
layer <- layers[[merge_vector[1]]]
layer
plotImageArray(layer)
# get the new color:
col_to <- color_to[i]
if (col_to == "weighted average") {
if (length(merge_vector) > 1) {
col_to <- apply(centers[merge_vector, ], 2,
function(j) stats::weighted.mean(j,
sizes[merge_vector]))
} else {
col_to <- centers[merge_vector, ]
}
} else {
col_to <- color_to[i]
col_to <- as.vector(grDevices::col2rgb(col_to) / 255)
}
col_to
# add the other layers
# this is silly but doesn't seem that slow
if (length(merge_vector) > 1) {
for (j in 2:length(merge_vector)) {
layer <- layer + layers[[merge_vector[j]]]
}
}
plotImageArray(layer)
# add new center & size values
new_centers <- rbind(new_centers, col_to)
new_sizes <- c(new_sizes, sum(sizes[merge_vector]))
new_centers
new_zies
new_sizes
# change pixel assignments
idx <- which(recolorize_obj$pixel_assignments %in% merge_vector)
idx
length(orig_layers)
ength(orig_layers) + i
length(orig_layers) + i
px_assign[idx] <- length(orig_layers) + i
plotImageArray(px_assign)
plotImageArray(px_assign)
# convert to pixset
layer <- imager::as.pixset(imager::as.cimg(layer))
# and recolor (setting alpha)
cimg_obj <- imager::colorise(cimg_obj, layer, col_to)
plot(cimg_obj)
# for every element of merge list...
for (i in 1:length(merge_list)) {
# get the vector of colors to combine
merge_vector <- merge_list[[i]]
# extract the first layer
layer <- layers[[merge_vector[1]]]
# get the new color:
col_to <- color_to[i]
if (col_to == "weighted average") {
if (length(merge_vector) > 1) {
col_to <- apply(centers[merge_vector, ], 2,
function(j) stats::weighted.mean(j,
sizes[merge_vector]))
} else {
col_to <- centers[merge_vector, ]
}
} else {
col_to <- color_to[i]
col_to <- as.vector(grDevices::col2rgb(col_to) / 255)
}
# add the other layers
# this is silly but doesn't seem that slow
if (length(merge_vector) > 1) {
for (j in 2:length(merge_vector)) {
layer <- layer + layers[[merge_vector[j]]]
}
}
# add new center & size values
new_centers <- rbind(new_centers, col_to)
new_sizes <- c(new_sizes, sum(sizes[merge_vector]))
# change pixel assignments
idx <- which(recolorize_obj$pixel_assignments %in% merge_vector)
px_assign[idx] <- length(orig_layers) + i
# convert to pixset
layer <- imager::as.pixset(imager::as.cimg(layer))
# and recolor (setting alpha)
cimg_obj <- imager::colorise(cimg_obj, layer, col_to)
}
plot(cimg_obj)
# thbbt
rownames(new_centers) <- NULL
# convert back to array and add alpha channel
# i have LEARNED MY LESSON with imager alpha channels
# (highly unpredictable behavior)
as_array <- cimg_to_array(cimg_obj)
as_array <- abind::abind(as_array,
recolorize_obj$recolored_img[ , , 4],
along = 3)
plotImageArray(as_array)
# reconstruct the recolorize obj
merged_obj <- recolorize_obj
merged_obj$recolored_img <- as_array
merged_obj$method <- paste("merged", merged_obj$method)
merged_obj$centers <- new_centers[-which(new_sizes == 0), ]
merged_obj$centers
new_sizes
new_centers
which(new_sizes == 0)
new_centers[-which(new_sizes == 0), ]
plotImageArray(px_assign / max(px_assign))
range(px_assign)
devtools::load_all(".")
# default: histogram, 2 bins/channel
rfit <- recolorize(img, bins = 4)
test <- recluster(rfit, refit_method = "merge")
test2 <- editLayers(test)
range(test$pixel_assignments)
# default: histogram, 2 bins/channel
rfit <- recolorize(img, bins = 4)
merge_list <- list(1, 2:64)
color_to = "weighted average"
# check parameters
pm <- clean_merge_params(recolorize_obj,
merge_list,
color_to)
merge_list <- pm$merge_list
color_to <- pm$color_to
# convert recolored image to a cimg object
cimg_obj <- array_to_cimg(recolorize_obj$recolored_img,
flatten_alpha = T)
# split the layers
layers <- splitByColor(recolorize_obj,
plot_method = "none")
# get centers and sizes
centers <- recolorize_obj$centers
sizes <- recolorize_obj$sizes
# get the list of untouched layers
orig_layers <- which(!(1:length(layers) %in% unlist(merge_list)))
new_centers <- centers[orig_layers, ]
new_sizes <- sizes[orig_layers]
px_assign <- matrix(0,
nrow = nrow(recolorize_obj$pixel_assignments),
ncol = ncol(recolorize_obj$pixel_assignments))
# if any layers are going untouched...
if (length(orig_layers) > 0 & sum(new_sizes) > 0) {
for (i in 1:length(orig_layers)) {
# copy their pixel assignments:
if (new_sizes[i] > 0) {
px_assign[which(recolorize_obj$pixel_assignments ==
orig_layers[i])] <- i
} else {
next
}
}
}
# for every element of merge list...
for (i in 1:length(merge_list)) {
# get the vector of colors to combine
merge_vector <- merge_list[[i]]
# extract the first layer
layer <- layers[[merge_vector[1]]]
# get the new color:
col_to <- color_to[i]
if (col_to == "weighted average") {
if (length(merge_vector) > 1) {
col_to <- apply(centers[merge_vector, ], 2,
function(j) stats::weighted.mean(j,
sizes[merge_vector]))
} else {
col_to <- centers[merge_vector, ]
}
} else {
col_to <- color_to[i]
col_to <- as.vector(grDevices::col2rgb(col_to) / 255)
}
# add the other layers
# this is silly but doesn't seem that slow
if (length(merge_vector) > 1) {
for (j in 2:length(merge_vector)) {
layer <- layer + layers[[merge_vector[j]]]
}
}
# add new center & size values
new_centers <- rbind(new_centers, col_to)
new_sizes <- c(new_sizes, sum(sizes[merge_vector]))
# change pixel assignments
idx <- which(recolorize_obj$pixel_assignments %in% merge_vector)
px_assign[idx] <- length(orig_layers) + i
# convert to pixset
layer <- imager::as.pixset(imager::as.cimg(layer))
# and recolor (setting alpha)
cimg_obj <- imager::colorise(cimg_obj, layer, col_to)
}
# thbbt
rownames(new_centers) <- NULL
# convert back to array and add alpha channel
# i have LEARNED MY LESSON with imager alpha channels
# (highly unpredictable behavior)
as_array <- cimg_to_array(cimg_obj)
as_array <- abind::abind(as_array,
recolorize_obj$recolored_img[ , , 4],
along = 3)
# remove any stray empty things
if (any(new_sizes == 0)) {
new_centers <- new_centers[-which(new_sizes == 0), ]
new_sizes <- new_sizes[-which(new_sizes == 0)]
}
# reconstruct the recolorize obj
merged_obj <- recolorize_obj
merged_obj$recolored_img <- as_array
merged_obj$method <- paste("merged", merged_obj$method)
merged_obj$centers <- new_centers
merged_obj$sizes <- new_sizes
merged_obj$pixel_assignments <- px_assign
hclust(dist(convertColor(rfit$centers, "sRGB","Lab")))
cutree(hclust(dist(convertColor(rfit$centers, "sRGB","Lab"))),
h = 60)
cclust <- cutree(hclust(dist(convertColor(rfit$centers, "sRGB","Lab"))),
h = 60)
clust_groups <- cutree(hclust(dist(convertColor(rfit$centers, "sRGB","Lab"))),
h = 60)
lapply(unique(clust_groups),
function(i) which(clust_groups == i))
clust_groups <- cutree(hclust(dist(convertColor(rfit$centers, "sRGB","Lab"))),
h = 60)
merge_list <- lapply(unique(clust_groups),
function(i) which(clust_groups == i))
test <- mergeLayers(rfit, merge_list)
test$sizes
test$centers
test2 <- editLayers(test)
test <- recluster(rfit, refit_method = "merge")
convertColor(rfit$centers, "sRGB","Lab")
clust_groups <- cutree(hclust(dist(convertColor(rfit$centers, "sRGB","Lab"))),
h = 60)
merge_list <- lapply(unique(clust_groups),
function(i) which(clust_groups == i))
test <- mergeLayers(rfit, merge_list)
test <- recluster(rfit, refit_method = "merge")
test2 <- editLayers(test)
# courtesy:
current_par <- graphics::par()
# rename, to keep things clear
init_fit <- recolorize_obj
# first, ignore empty clusters -- they're not informative
sizes <- init_fit$sizes
centers <- init_fit$centers
# if any are empty, remove them
if (any(sizes == 0)) {
zero_idx <- which(sizes == 0)
sizes <- sizes[-zero_idx]
centers <- init_fit$centers[-zero_idx, ]
}
# convert to Lab space for better clustering
lab_init <- col2col(centers,
from = "sRGB",
to = color_space,
ref_white = ref_white)
color_space = "Lab"
# convert to Lab space for better clustering
lab_init <- col2col(centers,
from = "sRGB",
to = color_space,
ref_white = ref_white)
ref_white = "D65"
# convert to Lab space for better clustering
lab_init <- col2col(centers,
from = "sRGB",
to = color_space,
ref_white = ref_white)
# get distance matrix
d <- stats::dist(lab_init)
# perform clustering
# hc <- hclust(d / max(d))
hc <- stats::hclust(d)
# plot clustering:
if (plot_hclust) {
graphics::par(mfrow = c(1, 1), mar = c(1, 3, 3, 1))
plot(hc, xlab = "")
# plot cutoff value if provided:
if (is.null(n_final)) {
graphics::abline(h = similarity_cutoff, lty = 2, col = "red")
}
}
plot_hclust = TRUE
similarity_cutoff = 60
# plot clustering:
if (plot_hclust) {
graphics::par(mfrow = c(1, 1), mar = c(1, 3, 3, 1))
plot(hc, xlab = "")
# plot cutoff value if provided:
if (is.null(n_final)) {
graphics::abline(h = similarity_cutoff, lty = 2, col = "red")
}
}
n_final = NULL
# plot clustering:
if (plot_hclust) {
graphics::par(mfrow = c(1, 1), mar = c(1, 3, 3, 1))
plot(hc, xlab = "")
# plot cutoff value if provided:
if (is.null(n_final)) {
graphics::abline(h = similarity_cutoff, lty = 2, col = "red")
}
}
# form groups
clust_groups <- stats::cutree(hc, k = n_final,
h = similarity_cutoff)
merge_list <- lapply(unique(clust_groups),
function(i) which(clust_groups == i))
refit_method <- match.arg(refit_method, c("imposeColors", "mergeLayers"))
refit_method = "merge"
refit_method <- match.arg(refit_method, c("imposeColors", "mergeLayers"))
refit_method
if (refit_method == "imposeColors") {
# get weighted avg new colors:
for (i in 1:length(merge_list)) {
temp_colors <- centers[merge_list[[i]], ]
if (is.null(nrow(temp_colors))) {
new_color <- temp_colors
} else {
new_color <- apply(temp_colors, 2, function(j)
stats::weighted.mean(j, w = sizes[merge_list[[i]]]))
}
# make new dataframe/add new colors:
if (i == 1) {
new_centers <- data.frame(R = new_color[1],
G = new_color[2],
B = new_color[3])
} else {
new_centers <- rbind(new_centers, new_color)
}
}
# and refit:
final_fit <- imposeColors(init_fit$original_img,
centers = new_centers,
plotting = FALSE)
} else if (refit_method == "mergeLayers") {
# doop doop:
final_fit <- mergeLayers(init_fit,
merge_list = merge_list,
plotting = FALSE)
}
plot(final_fit)
plot(init_fit)
# default: histogram, 2 bins/channel
rfit <- recolorize(img, bins = 4)
clust_groups <- cutree(hclust(dist(convertColor(rfit$centers, from = "sRGB", to = "Lab"))),
h = 60)
clust_groups
# form groups
clust_groups <- stats::cutree(hc, k = n_final,
h = similarity_cutoff)
clust_groups
n_final
similarity_cutoff
lab_init
zero_idx
which(rfit$pixel_assignments == 53)
merge_list
unique(unlist(merge_list))
rangeunique(unlist(merge_list)))
range(unique(unlist(merge_list)))
nrow(rfit$centers)
# filepath to image
img <- system.file("extdata/chongi.png", package = "recolorize")
# default: histogram, 2 bins/channel
rfit <- recolorize(img, bins = 4)
rfit$sizes
# filepath to image
img <- system.file("extdata/ocellata.png", package = "recolorize")
# default: histogram, 2 bins/channel
rfit <- recolorize(img, bins = 4)
rfit$sizes
# filepath to image
img <- system.file("extdata/corbetti.png", package = "recolorize")
# default: histogram, 2 bins/channel
rfit <- recolorize(img, bins = 5)
rfit$sizes
# default: histogram, 2 bins/channel
rfit <- recolorize(img, bins = 3); rfit$sizes
devtools::load_all(".")
# default: histogram, 2 bins/channel
rfit <- recolorize(img, bins = 3); rfit$sizes
test <- recluster(rfit, refit_method = "merge")
test2 <- editLayers(test)
test$centers
# default: histogram, 2 bins/channel
rfit <- recolorize(img, bins = 4); rfit$sizes
test <- recluster(rfit, refit_method = "merge")
test2 <- editLayers(test)
devtools::load_all(".")
?imposeColors
# RGB extremes (white, black, red, green, blue, yellow, magenta, cyan)
ctrs <- matrix(c(1, 1, 1,
0, 0, 0,
1, 0, 0,
0, 1, 0,
0, 0, 1,
1, 1, 0,
1, 0, 1,
0, 1, 1), byrow = TRUE, ncol = 3)
#
# get image paths
ocellata <- system.file("extdata/ocellata.png", package = "recolorize")
# map to rgb extremes
ocellata_fixed <- recolorize::imposeColors(ocellata, ctrs,
adjust_centers = FALSE)
ctrs
is.matrix(ctrs)
# RGB extremes (white, black, red, green, blue, yellow, magenta, cyan)
ctrs <- matrix(c(1, 1, 1,
0, 0, 0,
1, 0, 0,
0, 1, 0,
0, 0, 1,
1, 1, 0,
1, 0, 1,
0, 1, 1), byrow = TRUE, ncol = 3)
# plot it
recolorize::plotColorPalette(ctrs)
# get image paths
ocellata <- system.file("extdata/ocellata.png", package = "recolorize")
# map to rgb extremes
ocellata_fixed <- recolorize::imposeColors(ocellata, ctrs,
adjust_centers = FALSE)
# looks much better if we recalculate the centers from the image
ocellata_adjusted <- recolorize::imposeColors(ocellata, ctrs,
adjust_centers = TRUE)
# we can map one image to extracted colors from another image
# extract ocellata colors
ocellata_colors <- recolorize(ocellata)
# map fulgidissima to ocellata colors
fulgidissima <- system.file("extdata/fulgidissima.png",
package = "recolorize")
fulgidissma_ocellata <- recolorize::imposeColors(fulgidissima,
ocellata_colors$centers,
adjust_centers = FALSE)
# RGB extremes (white, black, red, green, blue, yellow, magenta, cyan)
ctrs <- matrix(c(1, 1, 1,
0, 0, 0,
1, 0, 0,
0, 1, 0,
0, 0, 1,
1, 1, 0,
1, 0, 1,
0, 1, 1), byrow = TRUE, ncol = 3)
# plot it
recolorize::plotColorPalette(ctrs)
# get image paths
ocellata <- system.file("extdata/ocellata.png", package = "recolorize")
# map to rgb extremes
ocellata_fixed <- recolorize::imposeColors(ocellata, ctrs,
adjust_centers = FALSE)
# looks much better if we recalculate the centers from the image
ocellata_adjusted <- recolorize::imposeColors(ocellata, ctrs,
adjust_centers = TRUE)
# we can map one image to extracted colors from another image
# extract ocellata colors
ocellata_colors <- recolorize(ocellata)
# map fulgidissima to ocellata colors
fulgidissima <- system.file("extdata/fulgidissima.png",
package = "recolorize")
fulgidissma_ocellata <- recolorize::imposeColors(fulgidissima,
ocellata_colors$centers,
adjust_centers = FALSE)
dim(c(1,1,1))
img <- system.file("extdata/fulgidissima.png", package = "recolorize")
init_fit <- recolorize(img, bins = 3)
devtools::load_all(".")
init_fit <- recolorize(img, bins = 3)
devtools::load_all(".")
test <- thresholdRecolor(init_fit, pct = 0.1)
test <- thresholdRecolor(init_fit, pct = 0.1, adjust_centers = F)
test <- thresholdRecolor(init_fit, pct = 0.1, adjust_centers = T)
devtools::load_all(".")
test <- thresholdRecolor(init_fit, pct = 0.1, adjust_centers = T)
test <- thresholdRecolor(init_fit, pct = 0.1, adjust_centers = F)
thresholdRecolor(init_fit)
test <- thresholdRecolor(init_fit, pct = 15)
test <- thresholdRecolor(init_fit, pct = .15)
test <- thresholdRecolor(init_fit, pct = 1)
usethis::use_vignette("introduction")
install.packages("rmarkdown")
usethis::use_vignette("introduction")
