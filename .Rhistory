# extract the first layer
layer <- layers[[merge_vector[1]]]
# get the new color:
if (color_to == "weighted average") {
if (length(merge_vector) > 1) {
col_to <- apply(centers[merge_vector, ], 2,
function(j) stats::weighted.mean(j,
sizes[merge_vector]))
} else {
col_to <- centers[merge_vector, ]
}
} else {
col_to <- color_to[i]
col_to <- as.vector(col2rgb(col_to))
}
# add the other layers
# this is silly but doesn't seem that slow
for (j in 2:length(merge_vector)) {
layer <- layer + layers[[merge_vector[j]]]
}
# convert to pixset
layer <- imager::as.pixset(imager::as.cimg(layer))
# extract the first layer
layer <- layers[[merge_vector[1]]]
# get the new color:
if (color_to == "weighted average") {
if (length(merge_vector) > 1) {
col_to <- apply(centers[merge_vector, ], 2,
function(j) stats::weighted.mean(j,
sizes[merge_vector]))
} else {
col_to <- centers[merge_vector, ]
}
} else {
col_to <- color_to[i]
col_to <- as.vector(col2rgb(col_to))
}
# add the other layers
# this is silly but doesn't seem that slow
for (j in 2:length(merge_vector)) {
layer <- layer + layers[[merge_vector[j]]]
}
dim(layer)
length(layer)
layer
i
i = 1
i = 4
# get the vector of colors to combine
merge_vector <- merge_list[[i]]
# extract the first layer
layer <- layers[[merge_vector[1]]]
# get the new color:
if (color_to == "weighted average") {
if (length(merge_vector) > 1) {
col_to <- apply(centers[merge_vector, ], 2,
function(j) stats::weighted.mean(j,
sizes[merge_vector]))
} else {
col_to <- centers[merge_vector, ]
}
} else {
col_to <- color_to[i]
col_to <- as.vector(col2rgb(col_to))
}
# add the other layers
# this is silly but doesn't seem that slow
for (j in 2:length(merge_vector)) {
layer <- layer + layers[[merge_vector[j]]]
}
layer
dim(layer)
# add the other layers
# this is silly but doesn't seem that slow
for (j in 2:length(merge_vector)) {
layer <- layer + layers[[merge_vector[j]]]
}
# convert to pixset
layer <- imager::as.pixset(imager::as.cimg(layer))
i = 1
# get the vector of colors to combine
merge_vector <- merge_list[[i]]
# extract the first layer
layer <- layers[[merge_vector[1]]]
# get the new color:
if (color_to == "weighted average") {
if (length(merge_vector) > 1) {
col_to <- apply(centers[merge_vector, ], 2,
function(j) stats::weighted.mean(j,
sizes[merge_vector]))
} else {
col_to <- centers[merge_vector, ]
}
} else {
col_to <- color_to[i]
col_to <- as.vector(col2rgb(col_to))
}
merge_vector
devtools::load_all(".")
# totally different model, a la pavo:
# you just need a list of color centers
# and a matrix of center assignments
# essentially, paint-by-numbers
# you can then define a method which will
# resurrect an image from that data when needed
img <- "/home/hannah/Dropbox/color/recolorize/inst/extdata/corbetti.png"
recolorize.obj <- recolorize(img)
test <- mergeLayers(recolorize.obj, merge_list)
devtools::load_all(".")
test <- mergeLayers(recolorize.obj, merge_list)
clust_groups
lapply(clust_groups, function(i) which(clust_groups == i))
lapply(unique(clust_groups), function(i) which(clust_groups == i))
devtools::load_all(".")
ro <- recolorize(img)
ro <- recluster(ro, plot_hclust = T, plot_final = T,
similarity_cutoff = 30, resid = FALSE)
devtools::load_all(".")
ro <- recluster(ro, plot_hclust = T, plot_final = T,
similarity_cutoff = 30, resid = FALSE)
# and merge those layers:
final_fit <- recolorize::mergeLayers(init_fit,
merge_list = merge_list,
plotting = FALSE)
# first, set nice margins and layout
graphics::par(mar = rep(0, 4))
graphics::layout(matrix(1:4, nrow = 1), widths = c(0.3, 0.3, 0.3, 0.1))
# plot original image
plotImageArray(init_fit$original.img, main = "original")
# plot initial fit
plotImageArray(init_fit$recolored.img, main = "initial fit")
# plot reclustered fit
plotImageArray(final_fit$recolored.img, main = "reclustered fit")
# and the new color palette
plotColorPalette(final_fit$centers, sizes = final_fit$sizes, horiz = FALSE)
final_fit$centers
final_fit$sizes
devtools::load_all(".")
# and merge those layers:
final_fit <- recolorize::mergeLayers(init_fit,
merge_list = merge_list,
plotting = FALSE)
ro <- recluster(ro, plot_hclust = T, plot_final = T,
similarity_cutoff = 30, resid = FALSE)
final_fit$sizes
plotColorPalette(final_fit$centers, final_fit$sizes)
plotColorPalette(final_fit$centers, final_fit$sizes)
plotColorPalette(final_fit$centers, final_fit$sizes, horiz = F)
devtools::load_all(".")
# totally different model, a la pavo:
# you just need a list of color centers
# and a matrix of center assignments
# essentially, paint-by-numbers
# you can then define a method which will
# resurrect an image from that data when needed
img <- "/home/hannah/Dropbox/color/recolorize/inst/extdata/corbetti.png"
recolorize.obj <- recolorize(img)
ro <- recolorize(img)
ro <- recluster(ro, plot_hclust = T, plot_final = T,
similarity_cutoff = 30, resid = FALSE)
install.packages("benchmark")
install.packages("rbenchmark")
rbenchmark::benchmark({recluster(ro, plot_hclust = T, plot_final = T,
similarity_cutoff = 30, resid = FALSE)},
replications = 100)
# totally different model, a la pavo:
# you just need a list of color centers
# and a matrix of center assignments
# essentially, paint-by-numbers
# you can then define a method which will
# resurrect an image from that data when needed
img <- "/home/hannah/Dropbox/color/recolorize/inst/extdata/corbetti.png"
ro <- recolorize(img)
rbenchmark::benchmark({recluster(ro, plot_hclust = T, plot_final = T,
similarity_cutoff = 30, resid = FALSE)},
replications = 10)
rbenchmark::benchmark("merge" = {recluster(ro, plot_hclust = T, plot_final = T,
similarity_cutoff = 30, resid = FALSE)},
replications = 10)
devtools::load_all(".")
rbenchmark::benchmark("impose" = {recluster(ro, plot_hclust = T, plot_final = T,
similarity_cutoff = 30, resid = FALSE)},
replications = 10)
devtools::load_all(".")
rbenchmark::benchmark("impose" = {recluster(ro, plot_hclust = T, plot_final = T,
similarity_cutoff = 30, resid = FALSE)},
replications = 10)
devtools::load_all(".")
ro <- recolorize(img)
ro <- recluster(ro, plot_hclust = T, plot_final = T,
similarity_cutoff = 30, resid = FALSE)
ro <- recluster(ro, plot_hclust = T, plot_final = T,
similarity_cutoff = 35, resid = FALSE)
ro <- recolorize(img)
ro <- recluster(ro, plot_hclust = T, plot_final = T,
similarity_cutoff = 35, resid = FALSE)
ro <- recolorize(img)
ro <- recluster(ro, plot_hclust = T, plot_final = T,
similarity_cutoff = 40, resid = FALSE)
?recolorize::colorClusters
img <- array(runif(30000), dim = c(100, 100, 3))
img.2d <- img
dim(img.2d) <- c(100 * 100, 3)
hist.clusters <- colorClusters(img.2d, method = "hist", bins = 2)
hist.clusters$pixel.assignments
?imager::colorise
# totally different model, a la pavo:
# you just need a list of color centers
# and a matrix of center assignments
# essentially, paint-by-numbers
# you can then define a method which will
# resurrect an image from that data when needed
img <- system.file("extdata/chongi.png", package = "recolorize"); img
# totally different model, a la pavo:
# you just need a list of color centers
# and a matrix of center assignments
# essentially, paint-by-numbers
# you can then define a method which will
# resurrect an image from that data when needed
img <- system.file("extdata/chongi.png", package = "recolorize")
init_fit <- recolorize(img)
# totally different model, a la pavo:
# you just need a list of color centers
# and a matrix of center assignments
# essentially, paint-by-numbers
# you can then define a method which will
# resurrect an image from that data when needed
img <- system.file("extdata/ocellata.png", package = "recolorize")
init_fit <- recolorize(img)
# totally different model, a la pavo:
# you just need a list of color centers
# and a matrix of center assignments
# essentially, paint-by-numbers
# you can then define a method which will
# resurrect an image from that data when needed
img <- system.file("extdata/fulgidissima.png", package = "recolorize")
init_fit <- recolorize(img)
# totally different model, a la pavo:
# you just need a list of color centers
# and a matrix of center assignments
# essentially, paint-by-numbers
# you can then define a method which will
# resurrect an image from that data when needed
img <- system.file("extdata/corbetti.png", package = "recolorize")
init_fit <- recolorize(img)
# to make it easier to see:
plotColorPalette(init_fit$centers, init_fit$sizes)
# to make it easier to see:
plotColorPalette(init_fit$centers)
plotImageArray(init_fit$recolored.img)
# to make it easier to see, we can plot the numbered palette:
layout(matrix(1:2, nrow = 1))
plotImageArray(init_fit$recolored.img)
plotColorPalette(init_fit$centers)
plotColorPalette(init_fit$centers, horiz = FALSE)
# to make it easier to see, we can plot the numbered palette:
layout(matrix(1:2, nrow = 1))
plotImageArray(init_fit$recolored.img)
plotColorPalette(init_fit$centers, horiz = FALSE)
vis_merge <- mergeLayers(init_fit, merge_list = merge_list)
# based on visual inspection, we should merge:
merge_list <- list(c(3, 5),
c(4, 7),
c(6, 8))
vis_merge <- mergeLayers(init_fit, merge_list = merge_list)
vis_merge <- mergeLayers(init_fit,
merge_list = redundant_list)
redundant_list <- list(1, 2, c(3, 5),
c(4, 7),
c(6, 8))
vis_merge <- mergeLayers(init_fit,
merge_list = redundant_list)
redundant_list <- list(c(3, 5),
c(4, 7),
c(6, 8),
1, 2)
vis_merge <- mergeLayers(init_fit,
merge_list = redundant_list)
# to make it easier to see, we can plot the numbered palette:
layout(matrix(1:2, nrow = 1))
plotImageArray(init_fit$recolored.img)
plotColorPalette(init_fit$centers, horiz = FALSE)
# based on visual inspection, we should merge:
mlist <- list(c(3, 5),
c(4, 7),
c(6, 8))
# we can merge with that list, leaving layers 1 & 2 intact:
vis_merge <- mergeLayers(init_fit,
merge_list = mlist)
mlist2 <- list(1, 2,
c(3, 5),
c(4, 7),
c(6, 8))
redundant_merge <- mergeLayers(init_fit,
merge_list = redundant_list)
redundant_merge <- mergeLayers(init_fit,
merge_list = mlist2)
# we can also swap their order this way:
redundant_list <- list(c(3, 5),
c(4, 7),
c(6, 8),
1, 2)
swap_layers <- mergeLayers(init_fit,
merge_list = redundant_list)
# we can include layers 1 & 2 as their own list elements,
# leaving them intact (result is identical to above):
mlist2 <- list(1, 2,
c(3, 5),
c(4, 7),
c(6, 8))
redundant_merge <- mergeLayers(init_fit,
merge_list = mlist2)
# we can also swap their order this way:
redundant_list <- list(c(3, 5),
c(4, 7),
c(6, 8),
1, 2)
swap_layers <- mergeLayers(init_fit,
merge_list = redundant_list)
# we can also swap layer order this way:
swap_list <- c(2, 5, 3, 4, 1)
swap_layers <- mergeLayers(redundant_merge,
merge_list = swap_list)
# we can also swap layer order this way without actually merging layers:
swap_list <- list(2, 5, 3, 4, 1)
swap_layers <- mergeLayers(redundant_merge,
merge_list = swap_list)
# we can merge
mergeLayers(init_fit,
merge_list = list(1, 7:8),
color_to = "magenta")
list(1, 7:8)
# we can merge
mergeLayers(init_fit,
merge_list = list(1, 2:8),
color_to = "magenta")
color_to = "magenta"
# if it's RGB triplets, change to hex codes...
if (is.numeric(color_to)) {
dim(color_to) <- c(length(color_to) / 3, 3)
color_to <- apply(color_to, 1,
function(i) rgb(i[1], i[2], i[3]))
}
# make sure that color_to, fill, and clean parameters
# are all of length == 1 | length(merge_list)
if (!length(color_to) %in% c(1, length(merge_list))) {
stop("'color_to' must be either length 1 or the
same length as 'merge_list'")
}
# repeat params if needed
if (color_to == 1) {
color_to <- rep(color_to, length(merge_list))
}
color_to
merge_list
# repeat params if needed
if (length(color_to) == 1) {
color_to <- rep(color_to, length(merge_list))
}
color_to
col_to = "magenta"
col_to <- as.vector(col2rgb(col_to))
col_to
devtools::load_all(".")
# we can merge
mergeLayers(init_fit,
merge_list = list(1, 2:8),
color_to = "magenta")
# we can merge
mergeLayers(init_fit,
merge_list = list(1, 2:8))
devtools::load_all(".")
# we can merge
mergeLayers(init_fit,
merge_list = list(1, 2:8))
# we can merge
test <- mergeLayers(init_fit,
merge_list = list(1, 2:8))
# we can merge
test <- mergeLayers(init_fit,
merge_list = list(1, 2:8), color_to = "magenta")
devtools::load_all(".")
# we can merge
test <- mergeLayers(init_fit,
merge_list = list(1, 2:8), color_to = "magenta")
# we can merge
mergeLayers(init_fit,
merge_list = list(1, 2:8),
color_to = c("weighted average", "magenta"))
# if we wanted to merge everything
mergeLayers(init_fit,
merge_list = list(1, 2:8),
color_to = c("weighted average", "orange"))
# merging everything but the first layer into a single layer,
# and making that merged layer orange for some reason:
mergeLayers(init_fit,
merge_list = c(2:8),
color_to = "orange")
# merging everything but the first layer into a single layer,
# and making that merged layer orange for some reason:
milkweed_impostor <- mergeLayers(init_fit,
merge_list = list(c(2:8)),
color_to = "orange")
# we can also shuffle all the layer colors while
# leaving their geometry intact:
centers <- vis_merge$centers
centers <- centers[sample(1:nrow(centers), nrow(centers)), ]
shuffle_layers <- mergeLayers(init_fit,
color_to = centers)
shuffle_layers <- mergeLayers(init_fit,
merge_list = list(1:5),
color_to = centers)
nrow(centers)
centers
color_to <- centers
# if it's RGB triplets, change to hex codes...
if (is.numeric(color_to)) {
dim(color_to) <- c(length(color_to) / 3, 3)
color_to <- apply(color_to, 1,
function(i) rgb(i[1], i[2], i[3]))
}
color_to
merge_list <- list(1:5)
merge_list
merge_list <- as.list(1:5)
merge_list
shuffle_layers <- mergeLayers(init_fit,
merge_list = as.list(1:5),
color_to = centers)
# we can also shuffle all the layer colors while
# leaving their geometry intact:
centers <- vis_merge$centers
centers <- centers[sample(1:nrow(centers), nrow(centers)), ]
shuffle_layers <- mergeLayers(init_fit,
merge_list = as.list(1:5),
color_to = centers)
shuffle_layers <- mergeLayers(init_fit,
merge_list = as.list(1:5),
color_to = centers)
# we can also shuffle all the layer colors while
# leaving their geometry intact:
centers <- vis_merge$centers
centers <- centers[sample(1:nrow(centers), nrow(centers)), ]
shuffle_layers <- mergeLayers(init_fit,
merge_list = as.list(1:5),
color_to = centers)
shuffle_layers <- mergeLayers(vis_merge,
merge_list = as.list(1:5),
color_to = centers)
rainbow_layers <- mergeLayers(vis_merge,
merge_list = as.list(1:5),
color_to = rainbow(5))
ro <- recolorize(system.file("extdata/chongi.png", package = "recolorize"))
# or we can change all the layers to neon colors for some pop art:
rainbow_layers <- mergeLayers(vis_merge,
merge_list = as.list(1:5),
color_to = rainbow(5))
# or we can change all the layers to neon colors for some pop art:
rainbow_layers <- mergeLayers(ro,
merge_list = as.list(1:5),
color_to = rainbow(5))
library(recolorize)
usethis::use_package("abind")
?backgroundCondition
?backgroundIndex
# if 'img' is a filepath, read in image
if (is.character(img)) {
if (file.exists(img)) {
img <- readImage(img, resize = resize, rotate = rotate)
} else {
stop(paste("Could not find", img))
}
} else if (!is.array(img) | length(dim(img)) != 3) {
# otherwise, make sure it's an image array
stop("'img' must be a path to an image or an image array.")
}
resize = NULL; rotate = NULL
# if 'img' is a filepath, read in image
if (is.character(img)) {
if (file.exists(img)) {
img <- readImage(img, resize = resize, rotate = rotate)
} else {
stop(paste("Could not find", img))
}
} else if (!is.array(img) | length(dim(img)) != 3) {
# otherwise, make sure it's an image array
stop("'img' must be a path to an image or an image array.")
}
# make background condition
alpha.channel <- dim(img)[3] == 4 # is there a transparency channel?
bg.condition <- backgroundCondition(lower = lower, upper = upper,
center = NULL, radius = NULL,
transparent = transparent,
alpha.channel = alpha.channel)
bg.condition <- "bg.t"
# index background
bg.indexed <- backgroundIndex(img, bg.condition)
bg.condition <- backgroundCondition(transparent = TRUE)
bg.condition
bg.condition <- backgroundCondition(transparent = TRUE, alpha.channel = TRUE)
bg.condition
# index background
bg.indexed <- backgroundIndex(img, bg.condition)
length(img[,,1])
dim(img)
246*116
243*116
# make a 'paint-by-numbers' array:
cluster_array <- rep(0, prod(bg.indexed$img.dims[1:2]))
cluter_array
cluster_array
?colorClusters
