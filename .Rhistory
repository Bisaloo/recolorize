lty = 2)
# but we just want to target pixels in that one region, so we can first
# determine a bounding box for it by plotting a grid:
plotImageArray(fit3$recolored_img)
# but we just want to target pixels in that one region, so we can first
# determine a bounding box for it by plotting a grid:
plotImageArray(fit3$recolored_img)
axis(1, line = 3); axis(2, line = 1)
abline(v = seq(0, 1, by = 0.1),
h = seq(0, 1, by = 0.1),
col = grey(0.8),
lty = 2)
# but we just want to target pixels in that one region, so we can first
# determine a bounding box for it by plotting a grid:
plotImageArray(fit3$recolored_img)
axis(1, line = 3); axis(2, line = 1)
abline(v = seq(0, 1, by = 0.1),
h = seq(0, 1, by = 0.1),
col = "yellow",
lty = 2)
# but we just want to target pixels in that one region, so we can first
# determine a bounding box for it by plotting a grid:
plotImageArray(fit3$recolored_img)
# but we just want to target pixels in that one region, so we can first
# determine a bounding box for it by plotting a grid:
plotImageArray(fit3$recolored_img)
axis(1, line = 3); axis(2, line = 1)
abline(v = seq(0, 1, by = 0.1),
h = seq(0, 1, by = 0.1),
col = "cyan",
lty = 2)
# but we just want to target pixels in that one region, so we can first
# determine a bounding box for it by plotting a grid:
plotImageArray(fit3$recolored_img)
axis(1, line = 3); axis(2, line = 1)
abline(v = seq(0, 1, by = 0.1),
h = seq(0, 1, by = 0.1),
col = "white",
lty = 2)
# but we just want to target pixels in that one region, so we can first
# determine a bounding box for it by plotting a grid:
plotImageArray(fit3$recolored_img)
axis(1, line = 3); axis(2, line = 1)
abline(v = seq(0, 1, by = 0.1),
h = seq(0, 1, by = 0.1),
col = "grey",
lty = 2)
# but we just want to target pixels in that one region, so we can first
# determine a bounding box for it by plotting a grid:
plotImageArray(fit3$recolored_img)
axis(1, line = 3); axis(2, line = 1)
abline(v = seq(0, 1, by = 0.1),
h = seq(0, 1, by = 0.1),
col = "grey",
lty = 2)
# but we just want to target pixels in that one region, so we can first
# determine a bounding box for it by plotting a grid:
plotImageArray(fit3$recolored_img)
axis(1, line = 3); axis(2, line = 1)
abline(v = seq(0, 1, by = 0.1),
h = seq(0, 1, by = 0.1),
col = "darkgrey",
lty = 2)
# but we just want to target pixels in that one region, so we can first
# determine a bounding box for it by plotting a grid:
plotImageArray(fit3$recolored_img)
# but we just want to target pixels in that one region, so we can first
# determine a bounding box for it by plotting a grid:
plotImageArray(fit3$recolored_img)
axis(1, line = 3); axis(2, line = 1)
abline(v = seq(0, 1, by = 0.1),
h = seq(0, 1, by = 0.1),
col = grey(0.2),
lty = 2)
# x-axis range: 0.5-0.7
# y-axis range: 0.55-0.75
# let's try it:
fit4 <- absorbLayer(fit3, layer_idx = 4,
size_condition = function(x) x < 100,
x_range = c(0.5, 0.7),
y_range = c(0.55, 0.75),
highlight_color = "cyan")
# x-axis range: 0.5-0.7
# y-axis range: 0.55-0.75
# let's try it:
fit4 <- absorbLayer(fit3, layer_idx = 4,
size_condition = function(x) x < 100,
x_range = c(0.5, 0.7),
y_range = c(0.55, 0.75),
highlight_color = "yellow")
# the brown patch is easier to deal with, since size thresholding alone is
# sufficient; we want to leave the stripes intact, so we'll absorb components
# that are 50-250 pixels OR fewer than 20 pixels (to get the tiny speckles),
# leaving the eyes intact
fit3 <- absorbLayer(fit2, layer_idx = 3,
size_condition = function(x) x <= 250 &
x >= 50 |
x < 20,
highlight_color = "cyan")
devtools::load_all(".")
?absorbLayer
fit1 <- recolorize(img, bins = 3, plotting = FALSE)
img <- system.file("extdata/fulgidissima.png", package = "recolorize")
fit1 <- recolorize(img, bins = 3, plotting = FALSE)
fit2 <- recluster(fit1, similarity_cutoff = 65)
devtools::load_all(".")
fit3 <- absorbLayer(fit2, 5)
fit3 <- absorbLayer(fit2, 5, size_condition = function(x) x < Inf)
img <- "../../beetles/machine_learning/color_maps/test3-dorsal-nopin_INIT_FIT/ICDB000059.png"
fit1 <- recolorize(img, resize = 0.5, bins = 4)
fit1 <- recolorize(img, resize = 0.5, method = "k", n = 14)
plot(fit1)
fit2 <- absorbLayer(fit1, 4)
plot(fit2)
plotImageArray(fit2$recolored_img)
plot(fit2)
plotImageArray(fit2$recolored_img)
fit2$centers
table(fit2$pixel_assignments)
devtools::load_all(".")
plotImageArray(fit2$recolored_img)
fit2 <- absorbLayer(fit1, 4)
plot(fit2)
fit3 <- absorbLayer(fit2, 8)
devtools::load_all(".")
img <- "../../beetles/machine_learning/color_maps/test3-dorsal-nopin_INIT_FIT/ICDB000059.png"
fit1 <- recolorize(img, resize = 0.5, method = "k", n = 14)
plot(fit2)
fit2 <- absorbLayer(fit1, 4)
fit1 <- recolorize(img, resize = 0.5, method = "k", n = 14)
plot(fit1)
fit2 <- absorbLayer(fit1, 3)
devtools::load_all(".")
fit2 <- absorbLayer(fit1, 3)
fit2$centers
fit2$sizes
devtools::load_all(".")
fit2 <- absorbLayer(fit1, 3)
fit2$centers
fit2$sizes
img <- "../../beetles/machine_learning/color_maps/test3-dorsal-nopin_INIT_FIT/ICDB000060.png"
fit1 <- recolorize(img, resize = 0.5, method = "k", n = 12)
devtools::load_all(".")
fit1 <- recolorize(img, resize = 0.5, method = "k", n = 12)
plot(fit1)
fit2 <- recluster(fit1, similarity_cutoff = 30)
fit3 <- absorbLayer(fit2, 3,
x_range = c(0.4, 0.6),
y_range = c(0.5, 1))
devtools::load_all(".")
fit3 <- absorbLayer(fit2, 3,
x_range = c(0.4, 0.6),
y_range = c(0.5, 1))
intersect(1:10, 7:17)
intersect(1:10, 12:22)
length(intersect(1:10, 12:22) > 0)
intersect(1:10, 12:22) > 0
length(intersect(1:10, 12:22)) > 0
length(intersect(1:10, 7:17)) > 0
?cat
?flush.console
?locator
devtools::load_all(".")
img <- system.file("extdata/fulgidissima.png", package = "recolorize")
fit1 <- recolorize(img, bins = 3, plotting = FALSE)
plotImageArray(fit1$original_img)
locator(1)
locator(4)
?options
identify(4)
library(phytools)
?phytools::cophylo
?phytools::bd
?ape::howmanytrees
rcoal(5)
tree <- rcoal(5)
images <- dir(system.file("extdata", package = "recolorize"), "png", full.names = TRUE)
images
tree <- ape::rcoal(5)
plot(tree)
plot(tree, type = "unrooted")
plotTree(tree, type = "unrooted")
add.arrow(tree, 1)
add.arrow(tree = tree, tip = "t1")
add.arrow(tree = tree, tip = "t1", arrl = 0.45)
add.arrow(tree = tree, tip = "t1", arrl = 0.45, lwd = 3, hedl = 0.1)
add.arrow(tree = tree, tip = "t1", arrl = 0.45, lwd = 3, hedl = 0.1, theta = 0)
add.arrow(tree = tree, tip = "t1", col="transparent",arrl=0.45,lwd=3,hedl=0.1)
lastPP <- get("last_plot.phylo", envir = .PlotPhyloEnv)
lastPP
lastPP$xx
xy <- data.frame(x = lastPP$xx, y = lastPP$yy)
points(xy)
points(xy[,1], col = "red")
points(xy[,1], col = "red")
xy[,1]
xy
points(xy[1, ], col = "red")
points(xy[2, ], col = "red")
points(xy[3, ], col = "red")
points(xy[4, ], col = "red")
points(xy[5, ], col = "red")
plot(tree)
lastPP <- get("last_plot.phylo", envir = .PlotPhyloEnv)
ntip <- lastPP$Ntip
xy <- data.frame(x = lastPP$xx[1:ntip],
y = lastPP$yy[1:ntip])
points(xy, col = 'red')
points(xy, col = 'red', pch = 20)
add_image(png::readPNG(images[i]), xy[1, 1], xy[1, 2], width = 0.2)
add_image(png::readPNG(images[1]), xy[1, 1], xy[1, 2], width = 0.2)
plot(tree, type = "unrooted")
lastPP <- get("last_plot.phylo", envir = .PlotPhyloEnv)
ntip <- lastPP$Ntip
xy <- data.frame(x = lastPP$xx[1:ntip],
y = lastPP$yy[1:ntip])
points(xy, col = 'red', pch = 20)
add_image(png::readPNG(images[1]), xy[1, 1], xy[1, 2], width = 0.2)
points(xy, col = viridisLite::cividis(5), pch = 20)
points(xy, col = viridisLite::viridis(5), pch = 20)
points(xy, col = c("red", "green", "blue", "pink", "orange"), pch = 20)
points(xy, col = c("red", "green", "blue", "pink", "orange"), cex = 3, pch = 20)
lastPP$align.tip.label
lastPP
tree$tip.label
# vector of images paths needs to be in the same order as the tips!
image_tree <- function(tree, image_paths, image_width = 1, ...) {
plot(tree, type = "unrooted")
lastPP <- get("last_plot.phylo", envir = .PlotPhyloEnv)
ntip <- lastPP$Ntip
xy <- data.frame(x = lastPP$xx[1:ntip],
y = lastPP$yy[1:ntip])
for (i in 1:length(image_paths)) {
add_image(png::readPNG(image_paths[i]),
xy[i, 1], xy[i, 2],
width = image_width)
}
}
image_tree(tree, images, image_width = 0.5, type = "unrooted")
par(mar = rep(0, 4))
image_tree(tree, images, image_width = 0.5, type = "unrooted")
# vector of images paths needs to be in the same order as the tips!
image_tree <- function(tree, image_paths, image_width = 1, ...) {
plotTree(tree, ...)
lastPP <- get("last_plot.phylo", envir = .PlotPhyloEnv)
ntip <- lastPP$Ntip
xy <- data.frame(x = lastPP$xx[1:ntip],
y = lastPP$yy[1:ntip])
for (i in 1:length(image_paths)) {
add_image(png::readPNG(image_paths[i]),
xy[i, 1], xy[i, 2],
width = image_width)
}
}
# vector of images paths needs to be in the same order as the tips!
image_tree <- function(tree, image_paths, image_width = 1, ...) {
phytools::plotTree(tree, ...)
lastPP <- get("last_plot.phylo", envir = .PlotPhyloEnv)
ntip <- lastPP$Ntip
xy <- data.frame(x = lastPP$xx[1:ntip],
y = lastPP$yy[1:ntip])
for (i in 1:length(image_paths)) {
add_image(png::readPNG(image_paths[i]),
xy[i, 1], xy[i, 2],
width = image_width)
}
}
par(mar = rep(0, 4))
image_tree(tree, images, image_width = 0.5, type = "unrooted")
image_tree(tree, images, image_width = 0.5)
image_tree(tree, images, image_width = 0.01)
image_tree(tree, images, image_width = 0.1)
par(mar = rep(1, 4))
image_tree(tree, images, type = "unrooted", image_width = 0.1)
par(mar = rep(1, 4))
image_tree(tree, images, type = "unrooted", image_width = 0.1)
# vector of images paths needs to be in the same order as the tips!
image_tree <- function(tree, image_paths, image_width = 1, ...) {
phytools::plotTree(tree, ...)
lastPP <- get("last_plot.phylo", envir = .PlotPhyloEnv)
ntip <- lastPP$Ntip
xy <- data.frame(x = lastPP$xx[1:ntip],
y = lastPP$yy[1:ntip])
for (i in 1:length(image_paths)) {
add_image(png::readPNG(image_paths[i]),
xy[i, 1], xy[i, 2],
width = image_width)
}
}
par(mar = rep(1, 4))
image_tree(tree, images, type = "unrooted", image_width = 0.1)
# vector of images paths needs to be in the same order as the tips!
image_tree <- function(tree, image_paths, image_width = 1, ...) {
plot(tree)
lastPP <- get("last_plot.phylo", envir = .PlotPhyloEnv)
ntip <- lastPP$Ntip
xy <- data.frame(x = lastPP$xx[1:ntip],
y = lastPP$yy[1:ntip])
for (i in 1:length(image_paths)) {
add_image(png::readPNG(image_paths[i]),
xy[i, 1], xy[i, 2],
width = image_width)
}
}
# vector of images paths needs to be in the same order as the tips!
image_tree <- function(tree, image_paths, image_width = 1, ...) {
require(ape)
plot(tree)
lastPP <- get("last_plot.phylo", envir = .PlotPhyloEnv)
ntip <- lastPP$Ntip
xy <- data.frame(x = lastPP$xx[1:ntip],
y = lastPP$yy[1:ntip])
for (i in 1:length(image_paths)) {
add_image(png::readPNG(image_paths[i]),
xy[i, 1], xy[i, 2],
width = image_width)
}
}
par(mar = rep(1, 4))
image_tree(tree, images, type = "unrooted", image_width = 0.1)
image_tree(tree, images, image_width = 0.1, type = "unrooted")
# vector of images paths needs to be in the same order as the tips!
image_tree <- function(tree, image_paths, image_width = 1, ...) {
require(ape)
plot(tree)
lastPP <- get("last_plot.phylo", envir = .PlotPhyloEnv)
ntip <- lastPP$Ntip
xy <- data.frame(x = lastPP$xx[1:ntip],
y = lastPP$yy[1:ntip])
for (i in 1:length(image_paths)) {
add_image(png::readPNG(image_paths[i]),
xy[i, 1], xy[i, 2],
width = image_width)
}
}
par(mar = rep(1, 4))
image_tree(tree, images, image_width = 0.1, type = "unrooted")
image_tree(tree, images, image_width = 0.1, type = "fan")
plot(tree, type = "radial")
par(mar = rep(1, 4))
# vector of images paths needs to be in the same order as the tips!
image_tree <- function(tree, image_paths, image_width = 1, ...) {
require(ape)
plot(tree, type = "radial")
lastPP <- get("last_plot.phylo", envir = .PlotPhyloEnv)
ntip <- lastPP$Ntip
xy <- data.frame(x = lastPP$xx[1:ntip],
y = lastPP$yy[1:ntip])
for (i in 1:length(image_paths)) {
add_image(png::readPNG(image_paths[i]),
xy[i, 1], xy[i, 2],
width = image_width)
}
}
par(mar = rep(1, 4))
image_tree(tree, images, image_width = 0.1, type = "radial")
image_tree(tree, images, image_width = 0.1, type = "radial")
image_tree(tree, images, image_width = 0.5, type = "radial")
image_tree(tree, images, image_width = 0.2, type = "radial")
image_tree(tree, images, image_width = 0.2, type = "fan")
image_tree(tree, images, image_width = 0.2, type = "fan")
# vector of images paths needs to be in the same order as the tips!
image_tree <- function(tree, image_paths, image_width = 1, ...) {
require(ape)
plot(tree, ...)
lastPP <- get("last_plot.phylo", envir = .PlotPhyloEnv)
ntip <- lastPP$Ntip
xy <- data.frame(x = lastPP$xx[1:ntip],
y = lastPP$yy[1:ntip])
for (i in 1:length(image_paths)) {
add_image(png::readPNG(image_paths[i]),
xy[i, 1], xy[i, 2],
width = image_width)
}
}
par(mar = rep(1, 4))
image_tree(tree, images, image_width = 0.2, type = "fan")
image_tree(tree, images, image_width = 0.2, type = "unrooted")
cdm <- colordistance::imageClusterPipeline(images, lower = NULL)
cdm
?nj
njoin <- nj(dist(cdm))
njoin$tip.label
images
par(mar = rep(1, 4))
image_tree(tree, images, image_width = 0.2, type = "unrooted")
image_tree(njoin, images, image_width = 0.2, type = "unrooted")
lastPP
# vector of images paths needs to be in the same order as the tips!
image_tree <- function(tree, image_paths, image_width = 1, ...) {
require(ape)
plot(tree, ...)
lastPP <- get("last_plot.phylo", envir = .PlotPhyloEnv)
ntip <- lastPP$Ntip
xy <- data.frame(x = lastPP$xx[1:ntip],
y = lastPP$yy[1:ntip])
image_width <- range(lastPP$x.lim) * image_width
for (i in 1:length(image_paths)) {
add_image(png::readPNG(image_paths[i]),
xy[i, 1], xy[i, 2],
width = image_width)
}
}
cdm <- colordistance::imageClusterPipeline(images, lower = NULL)
njoin <- nj(dist(cdm))
par(mar = rep(1, 4))
image_tree(njoin, images, image_width = 0., type = "unrooted")
image_tree(njoin, images, image_width = 0.2, type = "unrooted")
image_tree(njoin, images, image_width = 0.1, type = "unrooted")
images <- dir(system.file("extdata/", package = "recolorize"),
"png", full.names = TRUE)
nj(as.dist(cdm))
njoin <- nj(as.dist(cdm))
njoin$tip.label
par(mar = rep(1, 4))
image_tree(njoin, images, image_width = 0.1, type = "unrooted")
dist(cdm)
as.dist(cdm)
cdm
image_tree(njoin, images, image_width = 0.1, type = "phylogram")
image_tree(njoin, images, image_width = 0.1, type = "unrooted")
?get
get(last_plot.phylo)
get("last_plot.phylo")
images <- system.file("extdata", package = "recolorize")
images <- dir(system.file("extdata", package = "recolorize"),
"png", full.names = TRUE)
img <- images[1]
img <- images[2]
img <- images[4]
library(raster)
devtools::load_all(".")
image <- readImage(img)
dim(image)
object.size(image)
print(object.size(image), units = "Mb")
print(object.size(image), units = "Kb")
print(object.size(image), units = "Mb")
?object.size
print(object.size(image), units = "Mb", digits = 2)
size <- function(x, units = "Mb", digits = 2) {
print(object.size(x), units = units, digits = digits)
}
size(image)
rimg <- as.raster(image)
size(rimg)
rimg <- raster(image)
?as.raster
rimg <- grDevices::as.raster(image, )
size(rimg)
rimg <- raster::as.raster(image, )
size(rimg)
size(image)
rimg <- raster::as.raster(image, )
plotRGB(rimg)
rimg <- raster::as.raster(image)
size(rimg)
plotRGB(rimg)
library(raster)
plotRGB(rimg)
?raster
rimg <- raster(image)
class(image)
rimg <- as.raster(image)
class(rimg)
plot(rimg)
plotRGB(rimg)
dim(rimg)
usethis::use_package("raster", type = "Suggests")
# collapse a recolorize object
collapse_recolorize <- function(recolorize_obj,
include_original = TRUE) {
# create output
output <- list(color_map = recolorize_obj$pixel_assignments,
centers = recolorize_obj$centers)
if (include_original) {
# convert the original image to a raster as well:
original_img <- grDevices::as.raster(recolorize_obj$original_img)
# add it:
output$original_img <- original_img
}
class(output) <- "collapsed_recolorize"
return(output)
}
require(raster, quietly = TRUE)
# convert from an array to a raster stack
array_to_RasterStack <- function(img_array,
type = "stack",
alpha_mask = TRUE,
return_alpha = FALSE) {
require(raster, quietly = TRUE)
type <- match.arg(type, c("stack", "brick"))
r <- apply(img_array * 255, 3, raster::raster)
if (type == "stack") {
r2 <- raster::stack(r)
} else {
r2 <- raster::brick(r)
}
output <- r2
if (alpha_mask) {
if (dim(r2)[3] != 4) {
warning("No alpha channel included; not masking output")
} else {
r3 <- raster::mask(raster::subset(r2, 1:3),
raster::subset(r2, 4),
maskvalue = 0)
output <- r3
}
}
crs(output) <- "+proj=longlat"
return(output)
}
