# copy non-background pixels to change them
pix.recolor <- bg.indexed$non.bg
# index for removing empty centers
core.removal <- c()
nrow(color.clusters$centers)
i
i = 1
# get the new color
new.color <- color.clusters$centers[i, ]
new.color
# find which pixels should be changed
# IMPORTANT: we're assuming that color.clusters$pixel.assignments matches
# the indices of bg.indexed$non.bg
pix.idx <- which(color.clusters$pixel.assignments == i)
length(pix.id)
length(pix.idx)
dim(ig)
dim(img)
plotImageArray(img)
replacements <- matrix(new.color, ncol = 3, byrow = TRUE,
nrow = length(pix.idx))
dim(replacements)
length(pix.idx)
head(replacements)
new.color
# and stick it back in!
pix.recolor[pix.idx, 1:3] <- replacements
# for every color cluster:
for (i in 1:nrow(color.clusters$centers)) {
# get the new color
new.color <- color.clusters$centers[i, ]
# find which pixels should be changed
# IMPORTANT: we're assuming that color.clusters$pixel.assignments matches
# the indices of bg.indexed$non.bg
pix.idx <- which(color.clusters$pixel.assignments == i)
if (length(pix.idx) == 0) {
core.removal <- c(core.removal, i)
next
} else {
# repeat the new color for a substitute matrix
replacements <- matrix(new.color, ncol = 3, byrow = TRUE,
nrow = length(pix.idx))
# and stick it back in!
pix.recolor[pix.idx, 1:3] <- replacements
}
}
# slot new pixels back in
recolored.img <- bg.indexed$flattened.img
dim(recolored.img)
prod(bg.indexed$img.dims)
prod(dim(recolored.img))
# reshape
dim(recolored.img) <- bg.indexed$img.dims
plotImageArray(recolored.img)
plotImageArray(recolored.img)
# copy non-background pixels to change them
pix.recolor <- bg.indexed$non.bg
# index for removing empty centers
core.removal <- c()
# for every color cluster:
for (i in 1:nrow(color.clusters$centers)) {
# get the new color
new.color <- color.clusters$centers[i, ]
# find which pixels should be changed
# IMPORTANT: we're assuming that color.clusters$pixel.assignments matches
# the indices of bg.indexed$non.bg
pix.idx <- which(color.clusters$pixel.assignments == i)
if (length(pix.idx) == 0) {
core.removal <- c(core.removal, i)
next
} else {
# repeat the new color for a substitute matrix
replacements <- matrix(new.color, ncol = 3, byrow = TRUE,
nrow = length(pix.idx))
# and stick it back in!
pix.recolor[pix.idx, 1:3] <- replacements
}
}
# slot new pixels back in
recolored.img <- bg.indexed$flattened.img
# if there's no background...
if (length(bg.indexed$idx.flat) == 0) {
recolored.img <- pix.recolor
} else {
recolored.img[-bg.indexed$idx.flat, ] <- pix.recolor
# color background in white or transparent
if (bg.recolor == "white") {
recolored.img[bg.indexed$idx.flat, ] <- 1
} else if (bg.recolor == "transparent") {
if (bg.indexed$img.dims[3] == 4) {
recolored.img[bg.indexed$idx.flat , 4] <- 0
} else {
alpha.channel <- rep(1, nrow(recolored.img))
alpha.channel[bg.indexed$idx.flat] <- 0
recolored.img <- cbind(recolored.img, alpha.channel)
colnames(recolored.img) <- NULL
bg.indexed$img.dims[3] <- 4
}
}
}
# reshape
dim(recolored.img) <- bg.indexed$img.dims
plotImageArray(recolored.img, main = main)
main = ""
# copy non-background pixels to change them
pix.recolor <- bg.indexed$non.bg
i = 1
# get the new color
new.color <- color.clusters$centers[i, ]
# find which pixels should be changed
# IMPORTANT: we're assuming that color.clusters$pixel.assignments matches
# the indices of bg.indexed$non.bg
pix.idx <- which(color.clusters$pixel.assignments == i)
if (length(pix.idx) == 0) {
core.removal <- c(core.removal, i)
next
} else {
# repeat the new color for a substitute matrix
replacements <- matrix(new.color, ncol = 3, byrow = TRUE,
nrow = length(pix.idx))
# and stick it back in!
pix.recolor[pix.idx, 1:3] <- replacements
}
# slot new pixels back in
recolored.img <- bg.indexed$flattened.img
# if there's no background...
if (length(bg.indexed$idx.flat) == 0) {
recolored.img <- pix.recolor
} else {
recolored.img[-bg.indexed$idx.flat, ] <- pix.recolor
# color background in white or transparent
if (bg.recolor == "white") {
recolored.img[bg.indexed$idx.flat, ] <- 1
} else if (bg.recolor == "transparent") {
if (bg.indexed$img.dims[3] == 4) {
recolored.img[bg.indexed$idx.flat , 4] <- 0
} else {
alpha.channel <- rep(1, nrow(recolored.img))
alpha.channel[bg.indexed$idx.flat] <- 0
recolored.img <- cbind(recolored.img, alpha.channel)
colnames(recolored.img) <- NULL
bg.indexed$img.dims[3] <- 4
}
}
}
# copy non-background pixels to change them
pix.recolor <- bg.indexed$non.bg
dim(pix.recolor)
dim(bg.indexed$non.bg)
i
i = 1
# get the new color
new.color <- color.clusters$centers[i, ]
new.color
# find which pixels should be changed
# IMPORTANT: we're assuming that color.clusters$pixel.assignments matches
# the indices of bg.indexed$non.bg
pix.idx <- which(color.clusters$pixel.assignments == i)
# repeat the new color for a substitute matrix
replacements <- matrix(new.color, ncol = 3, byrow = TRUE,
nrow = length(pix.idx))
# and stick it back in!
pix.recolor[pix.idx, 1:3] <- replacements
dim(pix.recolor)
# slot new pixels back in
recolored.img <- bg.indexed$flattened.img
# if there's no background...
if (length(bg.indexed$idx.flat) == 0) {
recolored.img <- pix.recolor
} else {
recolored.img[-bg.indexed$idx.flat, ] <- pix.recolor
# color background in white or transparent
if (bg.recolor == "white") {
recolored.img[bg.indexed$idx.flat, ] <- 1
} else if (bg.recolor == "transparent") {
if (bg.indexed$img.dims[3] == 4) {
recolored.img[bg.indexed$idx.flat , 4] <- 0
} else {
alpha.channel <- rep(1, nrow(recolored.img))
alpha.channel[bg.indexed$idx.flat] <- 0
recolored.img <- cbind(recolored.img, alpha.channel)
colnames(recolored.img) <- NULL
bg.indexed$img.dims[3] <- 4
}
}
}
length(bg.indexed$idx.flat)
recolored.img[-bg.indexed$idx.flat, ] <- pix.recolor
# reshape
dim(recolored.img) <- bg.indexed$img.dims
# copy non-background pixels to change them
pix.recolor <- bg.indexed$non.bg
# index for removing empty centers
core.removal <- c()
# for every color cluster:
for (i in 1:nrow(color.clusters$centers)) {
# get the new color
new.color <- color.clusters$centers[i, ]
# find which pixels should be changed
# IMPORTANT: we're assuming that color.clusters$pixel.assignments matches
# the indices of bg.indexed$non.bg
pix.idx <- which(color.clusters$pixel.assignments == i)
if (length(pix.idx) == 0) {
core.removal <- c(core.removal, i)
next
} else {
# repeat the new color for a substitute matrix
replacements <- matrix(new.color, ncol = 3, byrow = TRUE,
nrow = length(pix.idx))
# and stick it back in!
pix.recolor[pix.idx, 1:3] <- replacements
}
}
dim(pix.recolor)
# slot new pixels back in
recolored.img <- bg.indexed$flattened.img
# if there's no background...
if (length(bg.indexed$idx.flat) == 0) {
recolored.img <- pix.recolor
} else {
recolored.img[-bg.indexed$idx.flat, ] <- pix.recolor
# color background in white or transparent
if (bg.recolor == "white") {
recolored.img[bg.indexed$idx.flat, ] <- 1
} else if (bg.recolor == "transparent") {
if (bg.indexed$img.dims[3] == 4) {
recolored.img[bg.indexed$idx.flat , 4] <- 0
} else {
alpha.channel <- rep(1, nrow(recolored.img))
alpha.channel[bg.indexed$idx.flat] <- 0
recolored.img <- cbind(recolored.img, alpha.channel)
colnames(recolored.img) <- NULL
bg.indexed$img.dims[3] <- 4
}
}
}
bg.recolor
bg.indexed$img.dims
bg.indexed$img.dims[3] == 4
if (bg.indexed$img.dims[3] == 4) {
recolored.img[bg.indexed$idx.flat , 4] <- 0
} else {
alpha.channel <- rep(1, nrow(recolored.img))
alpha.channel[bg.indexed$idx.flat] <- 0
recolored.img <- cbind(recolored.img, alpha.channel)
colnames(recolored.img) <- NULL
bg.indexed$img.dims[3] <- 4
}
recolored.img[bg.indexed$idx.flat , 4] <- 0
dim(recolored.img)
dim(bg.indexed$flattened.img)
# index background
bg.indexed <- backgroundIndex(img, bg.condition)
bg.indexed$img.dims
# copy non-background pixels to change them
pix.recolor <- bg.indexed$non.bg
# index for removing empty centers
core.removal <- c()
# for every color cluster:
for (i in 1:nrow(color.clusters$centers)) {
# get the new color
new.color <- color.clusters$centers[i, ]
# find which pixels should be changed
# IMPORTANT: we're assuming that color.clusters$pixel.assignments matches
# the indices of bg.indexed$non.bg
pix.idx <- which(color.clusters$pixel.assignments == i)
if (length(pix.idx) == 0) {
core.removal <- c(core.removal, i)
next
} else {
# repeat the new color for a substitute matrix
replacements <- matrix(new.color, ncol = 3, byrow = TRUE,
nrow = length(pix.idx))
# and stick it back in!
pix.recolor[pix.idx, 1:3] <- replacements
}
}
# slot new pixels back in
recolored.img <- bg.indexed$flattened.img
# if there's no background...
if (length(bg.indexed$idx.flat) == 0) {
recolored.img <- pix.recolor
} else {
recolored.img[-bg.indexed$idx.flat, ] <- pix.recolor
# color background in white or transparent
if (bg.recolor == "white") {
recolored.img[bg.indexed$idx.flat, ] <- 1
} else if (bg.recolor == "transparent") {
if (bg.indexed$img.dims[3] == 4) {
recolored.img[bg.indexed$idx.flat , 4] <- 0
} else {
alpha.channel <- rep(1, nrow(recolored.img))
alpha.channel[bg.indexed$idx.flat] <- 0
recolored.img <- cbind(recolored.img, alpha.channel)
colnames(recolored.img) <- NULL
bg.indexed$img.dims[3] <- 4
}
}
}
# reshape
dim(recolored.img) <- bg.indexed$img.dims
plotImageArray(recolored.img, main = main)
dim(recolored.img)
images
img.path <- images[2]
# get method
method <- match.arg(tolower(method), c("kmeans", "histogram"))
# read in image
img.ext <- tolower(tools::file_ext(img.path))
if (img.ext %in% c("jpeg", "jpg", "png", "bmp")) {
img <- imager::load.image(img.path)
} else {
stop("Image must be either JPG, PNG, or BMP")
}
# resize if specified
if (!is.null(resize)) {
img <- imager::imresize(img, scale = resize, interpolation = 6)
}
# rotate if specified
if (!is.null(rotate)) {
img <- imager::imrotate(img, angle = rotate)
}
# undo what cimg does for some reason
img <- imager::imrotate(img, -90)
# drop depth channel
# i don't want to talk about this
# someday we'll do it all with cimg objects
temp <- array(dim = dim(img)[c(1:2, 4)])
temp <- img[ , , 1, ]
img <- temp
rm(temp)
plotImageArray(img)
# make background condition
alpha.channel <- dim(img)[3] == 4 # is there a transparency channel?
bg.condition <- backgroundCondition(lower = lower, upper = upper,
center = NULL, radius = NULL,
transparent = transparent,
alpha.channel = alpha.channel)
bg.condition
# index background
bg.indexed <- backgroundIndex(img, bg.condition)
# color clusters & assign pixels
color.clusters <- colorClusters(bg.indexed$non.bg, method = method,
n = n, bins = bins)
plotColorPalette(color.clusters$centers)
table(color.clusters$pixel.assignments)
# recolor based on assignments/centers
recolored <- recolorImage(bg.indexed, color.clusters, plotting = T)
images
img.path <- images[4]
# get method
method <- match.arg(tolower(method), c("kmeans", "histogram"))
# read in image
img.ext <- tolower(tools::file_ext(img.path))
if (img.ext %in% c("jpeg", "jpg", "png", "bmp")) {
img <- imager::load.image(img.path)
} else {
stop("Image must be either JPG, PNG, or BMP")
}
# resize if specified
if (!is.null(resize)) {
img <- imager::imresize(img, scale = resize, interpolation = 6)
}
# rotate if specified
if (!is.null(rotate)) {
img <- imager::imrotate(img, angle = rotate)
}
# undo what cimg does for some reason
img <- imager::imrotate(img, -90)
# drop depth channel
# i don't want to talk about this
# someday we'll do it all with cimg objects
temp <- array(dim = dim(img)[c(1:2, 4)])
temp <- img[ , , 1, ]
img <- temp
rm(temp)
# make background condition
alpha.channel <- dim(img)[3] == 4 # is there a transparency channel?
bg.condition <- backgroundCondition(lower = lower, upper = upper,
center = NULL, radius = NULL,
transparent = transparent,
alpha.channel = alpha.channel)
# index background
bg.indexed <- backgroundIndex(img, bg.condition)
# color clusters & assign pixels
color.clusters <- colorClusters(bg.indexed$non.bg, method = method,
n = n, bins = bins)
# recolor based on assignments/centers
recolored <- recolorImage(bg.indexed, color.clusters, plotting = T)
plotColorPalette(color.centers = color.clusters$centers)
colordistance::getImageHist(img.path, bins = 2)
colordistance::getImageHist(img.path, bins = 2, lower = lower, upper = upper)
table(color.clusters$pixel.assignments)
x <- table(color.clusters$pixel.assignments)
x <- x / sum(x)
x
# format bins
if (length(bins) == 1) {
message(paste("\nUsing ", bins, "^3 = ", paste(bins^3),
" total bins", sep = ""))
bins <- rep(bins, 3)
} else {
message(paste("\nUsing ", bins[1], "*", bins[2],
"*", bins[3], " = ", bins[1] * bins[2] * bins[3],
" bins", sep = ""))
}
# from bins, generate breaks/ranges
breaks <- lapply(bins + 1, function(x) seq(0, 1, length = x))
# bin the image?
binned.image <- data.frame(R = cut(pixel.matrix[, 1], breaks = breaks[[1]],
include.lowest = T, labels = F),
G = cut(pixel.matrix[, 2], breaks = breaks[[2]],
include.lowest = T, labels = F),
B = cut(pixel.matrix[, 3], breaks = breaks[[3]],
include.lowest = T, labels = F))
# possible bins!
possible.bins <- expand.grid(c(1:bins[1]),
c(1:bins[2]),
c(1:bins[3]))
# defaults = centers of bins
break.means <- lapply(breaks, function(i) sapply(2:length(i),
function(m) mean(c(i[m-1], i[m]))))
centers <- as.matrix(expand.grid(break.means))
centers
plotColorPalette(centers)
color.clusters <- list(pixel.assignments = color.clusters$pixel.assignments, centers = centers)
class(color.clusters) <- "color.clusters"
# copy non-background pixels to change them
pix.recolor <- bg.indexed$non.bg
# index for removing empty centers
core.removal <- c()
# for every color cluster:
for (i in 1:nrow(color.clusters$centers)) {
# get the new color
new.color <- color.clusters$centers[i, ]
# find which pixels should be changed
# IMPORTANT: we're assuming that color.clusters$pixel.assignments matches
# the indices of bg.indexed$non.bg
pix.idx <- which(color.clusters$pixel.assignments == i)
if (length(pix.idx) == 0) {
core.removal <- c(core.removal, i)
next
} else {
# repeat the new color for a substitute matrix
replacements <- matrix(new.color, ncol = 3, byrow = TRUE,
nrow = length(pix.idx))
# and stick it back in!
pix.recolor[pix.idx, 1:3] <- replacements
}
}
# slot new pixels back in
recolored.img <- bg.indexed$flattened.img
# if there's no background...
if (length(bg.indexed$idx.flat) == 0) {
recolored.img <- pix.recolor
} else {
recolored.img[-bg.indexed$idx.flat, ] <- pix.recolor
# color background in white or transparent
if (bg.recolor == "white") {
recolored.img[bg.indexed$idx.flat, ] <- 1
} else if (bg.recolor == "transparent") {
if (bg.indexed$img.dims[3] == 4) {
recolored.img[bg.indexed$idx.flat , 4] <- 0
} else {
alpha.channel <- rep(1, nrow(recolored.img))
alpha.channel[bg.indexed$idx.flat] <- 0
recolored.img <- cbind(recolored.img, alpha.channel)
colnames(recolored.img) <- NULL
bg.indexed$img.dims[3] <- 4
}
}
}
# reshape
dim(recolored.img) <- bg.indexed$img.dims
plotImageArray(recolored.img, main = main)
refhist <- colordistance::getImageHist(img.path, bins = 2)
refhist <- colordistance::getImageHist(img.path, bins = 2, lower = lower, upper = upper)
refhist
# color clusters & assign pixels
color.clusters <- colorClusters(bg.indexed$non.bg, method = method,
n = n, bins = bins)
color.clusters$centers
refhist
# how many pixels in each bin?
d <- mgcv::uniquecombs(binned.image, ordered = TRUE)
d
pixel.matrix
dim(pixel.matrix)
# bin the image?
binned.image <- data.frame(R = cut(pixel.matrix[, 1], breaks = breaks[[1]],
include.lowest = T, labels = F),
G = cut(pixel.matrix[, 2], breaks = breaks[[2]],
include.lowest = T, labels = F),
B = cut(pixel.matrix[, 3], breaks = breaks[[3]],
include.lowest = T, labels = F))
# possible bins!
possible.bins <- expand.grid(c(1:bins[1]),
c(1:bins[2]),
c(1:bins[3]))
# defaults = centers of bins
break.means <- lapply(breaks, function(i) sapply(2:length(i),
function(m) mean(c(i[m-1], i[m]))))
centers <- as.matrix(expand.grid(break.means))
# how many pixels in each bin?
d <- mgcv::uniquecombs(binned.image, ordered = TRUE)
d
?mgcv::uniquecombs
# how many pixels in each bin?
d <- mgcv::uniquecombs(binned.image)
d
centers
recolorize(img.path, method = "kmeans")
