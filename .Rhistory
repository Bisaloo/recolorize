new_img <- constructImage(map2,
recolorize_obj$centers)
# then, get new sizes (minus background)
recolorize_obj$sizes <- table(map2)[-1]
# if we completely eliminated a patch, remove it from the color centers
if (!any(map2 == layer_idx)) {
recolorize_obj$centers <- recolorize_obj$centers[-layer_idx, ]
}
# get boundaries of original pixels & make highlighted array
components <- layer_split[condition_met]
layer_px <- imager::as.pixset(imager::add(components) > 0)
# get boundaries of original pixels & make highlighted array
components <- layer_split[condition_met]
layer_px <- imager::as.pixset(imager::add(components) > 0)
components
condition_met
layer_idx
x_range
y_range
size_condition
size_condition = function(x < Inf)
size_condition = function(x) x < Inf
# get object layer
layers <- splitByColor(recolorize_obj, plot_method = "none")
layer <- layers[[layer_idx]]
# convert to an imager pixset for splitting
px <- imager::as.pixset(imager::as.cimg(layer) > 0)
# split separate components
layer_split <- imager::split_connected(px)
# get component sizes
component_sizes <- unlist(lapply(layer_split, sum))
# find which components satisfy the size condition
condition_met <- which(ifelse(size_condition(component_sizes), TRUE, FALSE))
# location condition - bounding box
# get bounding box (in pixel coordinates) of each component:
component_bbox <- lapply(layer_split, function(l) apply(which(l[ , , 1, 1],
arr.ind = TRUE), 2,
range))
# convert to fraction of image dimensions:
imdim <- dim(recolorize_obj$original_img)[1:2]
norm_matrix <- matrix(imdim, nrow = 2, ncol = 2, byrow = TRUE)
component_bbox_norm <- lapply(component_bbox,
function(b) round(b / norm_matrix, 3))
# important - remember that imager rotates images 90 degrees (argh),
# so y-axis is rows and x-axis is columns
y_range <- 1 - y_range # also the y-axis is flipped
bbox_condition_met <- lapply(component_bbox_norm,
function(b) any(any(b[ , 1] >= y_range[2]) &
any(b[ , 1] <= y_range[1])) &
any(any(b[ , 2] >= x_range[1]) &
any(b[ , 2] <= x_range[2])))
condition_met <- intersect(condition_met,
which(unlist(bbox_condition_met)))
# make a color center map from the pixel assignments (this will make sense in
# a bit)
map <- imager::as.cimg(recolorize_obj$pixel_assignments)
# for every component that meets the size condition:
for (i in condition_met) {
# extract the component
component <- layer_split[[i]]
# get indices of immediately adjacent pixels
px_contour <- imager::boundary(imager::grow(component, 3))
# count which color patches those pixels are assigned to
border_cols <- table(map[px_contour])
# we don't want to turn these pixels transparent, so we'll ignore
# any borders with the background (patch 0):
if(names(border_cols)[1] == "0") {
border_cols <- border_cols[-1]
}
# get name of longest border
ctr_idx <- names(which(border_cols == max(border_cols)))
ctr_idx <- as.numeric(ctr_idx)
# if there is more than one color patch bordering it...
if (length(ctr_idx) > 1) {
# ...switch that component to the color of the patch
# with which it shares the longest border
majority_rule <- which(recolorize_obj$sizes[ctr_idx] ==
max(recolorize_obj$sizes[ctr_idx]))
ctr_idx <- ctr_idx[majority_rule]
}
# and change the indices
map[component] <- as.numeric(ctr_idx)
i <- i + 1
}
# switch the new patch map in
map2 <- recolorize:::cimg_to_array(map)
recolorize_obj$pixel_assignments <- map2
# and make the image
new_img <- constructImage(map2,
recolorize_obj$centers)
# then, get new sizes (minus background)
recolorize_obj$sizes <- table(map2)[-1]
# if we completely eliminated a patch, remove it from the color centers
if (!any(map2 == layer_idx)) {
recolorize_obj$centers <- recolorize_obj$centers[-layer_idx, ]
}
# get boundaries of original pixels & make highlighted array
components <- layer_split[condition_met]
components
layer_px <- imager::as.pixset(imager::add(components) > 0)
px_bound <- imager::boundary(imager::grow(layer_px, 1))
old_img <- array_to_cimg(recolorize_obj$recolored_img)
highlight_img <- imager::colorise(imager::imrotate(old_img, 90),
px_bound, col = highlight_color)
plot(highlight_img)
highlight_img <- imager::colorise(old_img,
px_bound, col = highlight_color)
plot(highlight_img)
highlight_img <- cimg_to_array(highlight_img)
plotImageArray(highlight_img)
#' @examples
#' img <- system.file("extdata/ephippigera.png", package = "recolorize"); img
#' fit1 <- recolorize(img, bins = 3)
#' fit2 <- recluster(fit1)
#' fit3 <- absorbLayer(recolorize_obj = fit3, layer_idx = 4,
#'                    size_condition = function(x) x <= 30 & x > 0,
#'                    highlight_color = "cyan")
#'
#'
#' @export
absorbLayer <- function(recolorize_obj,
layer_idx,
size_condition = function(s) s <= 100,
x_range = c(0, 1),
y_range = c(0, 1),
highlight_color = "yellow",
lwd = 0.25,
plotting = TRUE) {
# get object layer
layers <- splitByColor(recolorize_obj, plot_method = "none")
layer <- layers[[layer_idx]]
# convert to an imager pixset for splitting
px <- imager::as.pixset(imager::as.cimg(layer) > 0)
# split separate components
layer_split <- imager::split_connected(px)
# get component sizes
component_sizes <- unlist(lapply(layer_split, sum))
# find which components satisfy the size condition
condition_met <- which(ifelse(size_condition(component_sizes), TRUE, FALSE))
# location condition - bounding box
# get bounding box (in pixel coordinates) of each component:
component_bbox <- lapply(layer_split, function(l) apply(which(l[ , , 1, 1],
arr.ind = TRUE), 2,
range))
# convert to fraction of image dimensions:
imdim <- dim(recolorize_obj$original_img)[1:2]
norm_matrix <- matrix(imdim, nrow = 2, ncol = 2, byrow = TRUE)
component_bbox_norm <- lapply(component_bbox,
function(b) round(b / norm_matrix, 3))
# important - remember that imager rotates images 90 degrees (argh),
# so y-axis is rows and x-axis is columns
y_range <- 1 - y_range # also the y-axis is flipped
bbox_condition_met <- lapply(component_bbox_norm,
function(b) any(any(b[ , 1] >= y_range[2]) &
any(b[ , 1] <= y_range[1])) &
any(any(b[ , 2] >= x_range[1]) &
any(b[ , 2] <= x_range[2])))
condition_met <- intersect(condition_met,
which(unlist(bbox_condition_met)))
# make a color center map from the pixel assignments (this will make sense in
# a bit)
map <- imager::as.cimg(recolorize_obj$pixel_assignments)
# for every component that meets the size condition:
for (i in condition_met) {
# extract the component
component <- layer_split[[i]]
# get indices of immediately adjacent pixels
px_contour <- imager::boundary(imager::grow(component, 3))
# count which color patches those pixels are assigned to
border_cols <- table(map[px_contour])
# we don't want to turn these pixels transparent, so we'll ignore
# any borders with the background (patch 0):
if(names(border_cols)[1] == "0") {
border_cols <- border_cols[-1]
}
# get name of longest border
ctr_idx <- names(which(border_cols == max(border_cols)))
ctr_idx <- as.numeric(ctr_idx)
# if there is more than one color patch bordering it...
if (length(ctr_idx) > 1) {
# ...switch that component to the color of the patch
# with which it shares the longest border
majority_rule <- which(recolorize_obj$sizes[ctr_idx] ==
max(recolorize_obj$sizes[ctr_idx]))
ctr_idx <- ctr_idx[majority_rule]
}
# and change the indices
map[component] <- as.numeric(ctr_idx)
i <- i + 1
}
# switch the new patch map in
map2 <- recolorize:::cimg_to_array(map)
recolorize_obj$pixel_assignments <- map2
# and make the image
new_img <- constructImage(map2,
recolorize_obj$centers)
# then, get new sizes (minus background)
recolorize_obj$sizes <- table(map2)[-1]
# if we completely eliminated a patch, remove it from the color centers
if (!any(map2 == layer_idx)) {
recolorize_obj$centers <- recolorize_obj$centers[-layer_idx, ]
}
# plot if we're plotting
if (plotting) {
# get boundaries of original pixels & make highlighted array
components <- layer_split[condition_met]
layer_px <- imager::as.pixset(imager::add(components) > 0)
px_bound <- imager::boundary(imager::grow(layer_px, 1))
old_img <- array_to_cimg(recolorize_obj$recolored_img)
highlight_img <- imager::colorise(old_img,
px_bound, col = highlight_color)
highlight_img <- cimg_to_array(highlight_img)
# plot highlighted
layout(matrix(1:3, 1), widths = c(0.4, 0.4, 0.2))
plotImageArray(highlight_img, main = paste("selected components"))
plotImageArray(new_img, paste("result"))
plotColorPalette(recolorize_obj$centers,
recolorize_obj$sizes,
horiz = FALSE)
}
# tidying up
# first, swap out the new image
recolorize_obj$recolored_img <- new_img
return(recolorize_obj)
}
# we want to leave the stripes intact, so we'll absorb components that
# are 50-250 pixels OR fewer than 20 pixels (to get the tiny speckles),
# leaving the eyes intact
fit3 <- absorbLayer(fit2, layer_idx = 3,
size_condition = function(x) x <= 250 &
x >= 50 |
x < 20,
highlight_color = "cyan")
# what about the orange speckles? if we want to keep the bordering around
# the dark brown components but remove the speckles around the pin,
# we can first do a pass with editLayer
fit4 <- absorbLayer(fit3, layer_idx = 4,
size_condition = function(x) x < 30 & x > 5,
x_range = c(0.6, 0.7),
y_range = c(0.55, 0.75),
highlight_color = "cyan")
# what about the orange speckles? if we want to keep the bordering around
# the dark brown components but remove the speckles around the pin,
# we can first do a pass with editLayer
fit4 <- absorbLayer(fit3, layer_idx = 4,
size_condition = function(x) x < 100,
x_range = c(0.6, 0.7),
y_range = c(0.55, 0.75),
highlight_color = "cyan")
# what about the orange speckles? if we want to keep the bordering around
# the dark brown components but remove the speckles around the pin,
# we can first do a pass with editLayer
fit4 <- absorbLayer(fit2, layer_idx = 4,
size_condition = function(x) x < 100,
x_range = c(0.6, 0.7),
y_range = c(0.55, 0.75),
highlight_color = "cyan")
# we want to leave the stripes intact, so we'll absorb components that
# are 50-250 pixels OR fewer than 20 pixels (to get the tiny speckles),
# leaving the eyes intact
fit3 <- absorbLayer(fit4, layer_idx = 3,
size_condition = function(x) x <= 250 &
x >= 50 |
x < 20,
highlight_color = "cyan")
?&
# the brown patch is easier to deal with, since size thresholding alone is
# sufficient; we want to leave the stripes intact, so we'll absorb components
# that are 50-250 pixels OR fewer than 20 pixels (to get the tiny speckles),
# leaving the eyes intact
fit3 <- absorbLayer(fit2, layer_idx = 3,
size_condition = function(x) x <= 250 &
x >= 50 |
x < 20,
highlight_color = "cyan")
# what about the orange speckles? this is more difficult, because
# we want to retain the border around the brown stripes, but those patches
# are quite small, so size thresholding won't work:
fit_bad <- absorbLayer(fit3, layer_idx = 4,
size_condition = function(x) x < 100)
# what about the orange speckles? this is more difficult, because
# we want to retain the border around the brown stripes, but those patches
# are quite small, so size thresholding won't work:
fit_bad <- absorbLayer(fit3, layer_idx = 4,
size_condition = function(x) x < 500)
# what about the orange speckles? this is more difficult, because
# we want to retain the border around the brown stripes, but those patches
# are quite small, so size thresholding won't work:
fit_bad <- absorbLayer(fit3, layer_idx = 4,
size_condition = function(x) x < 50)
# what about the orange speckles? this is more difficult, because
# we want to retain the border around the brown stripes, but those patches
# are quite small, so size thresholding won't work:
fit_bad <- absorbLayer(fit3, layer_idx = 4,
size_condition = function(x) x < 20)
# what about the orange speckles? this is more difficult, because
# we want to retain the border around the brown stripes, but those patches
# are quite small, so size thresholding won't work:
fit_bad <- absorbLayer(fit3, layer_idx = 4,
size_condition = function(x) x < 21)
# what about the orange speckles? this is more difficult, because
# we want to retain the border around the brown stripes, but those patches
# are quite small, so size thresholding won't work:
fit_bad <- absorbLayer(fit3, layer_idx = 4,
size_condition = function(x) x < 22)
# what about the orange speckles? this is more difficult, because
# we want to retain the border around the brown stripes, but those patches
# are quite small, so size thresholding won't work:
fit_bad <- absorbLayer(fit3, layer_idx = 4,
size_condition = function(x) x < 23)
# what about the orange speckles? this is more difficult, because
# we want to retain the border around the brown stripes, but those patches
# are quite small, so size thresholding won't work:
fit_bad <- absorbLayer(fit3, layer_idx = 4,
size_condition = function(x) x < 24)
# what about the orange speckles? this is more difficult, because
# we want to retain the border around the brown stripes, but those patches
# are quite small, so size thresholding won't work:
fit_bad <- absorbLayer(fit3, layer_idx = 4,
size_condition = function(x) x < 25)
# but we just want to target pixels in that one region, so we can first
# determine a bounding box for it by plotting a grid:
plotImageArray(fit3$recolored_img)
# but we just want to target pixels in that one region, so we can first
# determine a bounding box for it by plotting a grid:
layout(1)
plotImageArray(fit3$recolored_img)
axis(c(1, 2))
plotImageArray(fit3$recolored_img)
axis(1, at = -1)
plotImageArray(fit3$recolored_img)
axis(1, line = -1)
axis(1, line = -3)
axis(1, line = 1)
axis(1, line = 0)
axis(1, line = 3)
axis(1, line = 3)
plotImageArray(fit3$recolored_img)
axis(1, line = 3)
axis(1, line = 3); axis(2, line = 3)
plotImageArray(fit3$recolored_img)
axis(1, line = 3); axis(2, line = 1)
abline(v = seq(0, 1, by = 0.05),
h = seq(0, 1, by = 0.05), lty = 2)
# what about the orange speckles? this is more difficult, because
# we want to retain the border around the brown stripes, but those patches
# are quite small, so size thresholding won't work:
fit_bad <- absorbLayer(fit3, layer_idx = 4,
size_condition = function(x) x < 25)
# but we just want to target pixels in that one region, so we can first
# determine a bounding box for it by plotting a grid:
plotImageArray(fit3$recolored_img)
axis(1, line = 3); axis(2, line = 1)
abline(v = seq(0, 1, by = 0.05),
h = seq(0, 1, by = 0.05), lty = 2)
# but we just want to target pixels in that one region, so we can first
# determine a bounding box for it by plotting a grid:
plotImageArray(fit3$recolored_img)
axis(1, line = 3); axis(2, line = 1)
abline(v = seq(0, 1, by = 0.1),
h = seq(0, 1, by = 0.1), lty = 2)
abline(v = seq(0, 1, by = 0.1),
h = seq(0, 1, by = 0.1),
col = grey(0.8),
lty = 2)
# but we just want to target pixels in that one region, so we can first
# determine a bounding box for it by plotting a grid:
plotImageArray(fit3$recolored_img)
axis(1, line = 3); axis(2, line = 1)
abline(v = seq(0, 1, by = 0.1),
h = seq(0, 1, by = 0.1),
col = grey(0.8),
lty = 2)
# but we just want to target pixels in that one region, so we can first
# determine a bounding box for it by plotting a grid:
plotImageArray(fit3$recolored_img)
axis(1, line = 3); axis(2, line = 1)
abline(v = seq(0, 1, by = 0.1),
h = seq(0, 1, by = 0.1),
col = grey(0.8),
lty = 2)
# but we just want to target pixels in that one region, so we can first
# determine a bounding box for it by plotting a grid:
plotImageArray(fit3$recolored_img)
axis(1, line = 3); axis(2, line = 1)
abline(v = seq(0, 1, by = 0.05),
h = seq(0, 1, by = 0.05),
col = grey(0.8),
lty = 2)
# but we just want to target pixels in that one region, so we can first
# determine a bounding box for it by plotting a grid:
plotImageArray(fit3$recolored_img)
# but we just want to target pixels in that one region, so we can first
# determine a bounding box for it by plotting a grid:
plotImageArray(fit3$recolored_img)
axis(1, line = 3); axis(2, line = 1)
abline(v = seq(0, 1, by = 0.1),
h = seq(0, 1, by = 0.1),
col = grey(0.8),
lty = 2)
# but we just want to target pixels in that one region, so we can first
# determine a bounding box for it by plotting a grid:
plotImageArray(fit3$recolored_img)
axis(1, line = 3); axis(2, line = 1)
abline(v = seq(0, 1, by = 0.1),
h = seq(0, 1, by = 0.1),
col = "yellow",
lty = 2)
# but we just want to target pixels in that one region, so we can first
# determine a bounding box for it by plotting a grid:
plotImageArray(fit3$recolored_img)
# but we just want to target pixels in that one region, so we can first
# determine a bounding box for it by plotting a grid:
plotImageArray(fit3$recolored_img)
axis(1, line = 3); axis(2, line = 1)
abline(v = seq(0, 1, by = 0.1),
h = seq(0, 1, by = 0.1),
col = "cyan",
lty = 2)
# but we just want to target pixels in that one region, so we can first
# determine a bounding box for it by plotting a grid:
plotImageArray(fit3$recolored_img)
axis(1, line = 3); axis(2, line = 1)
abline(v = seq(0, 1, by = 0.1),
h = seq(0, 1, by = 0.1),
col = "white",
lty = 2)
# but we just want to target pixels in that one region, so we can first
# determine a bounding box for it by plotting a grid:
plotImageArray(fit3$recolored_img)
axis(1, line = 3); axis(2, line = 1)
abline(v = seq(0, 1, by = 0.1),
h = seq(0, 1, by = 0.1),
col = "grey",
lty = 2)
# but we just want to target pixels in that one region, so we can first
# determine a bounding box for it by plotting a grid:
plotImageArray(fit3$recolored_img)
axis(1, line = 3); axis(2, line = 1)
abline(v = seq(0, 1, by = 0.1),
h = seq(0, 1, by = 0.1),
col = "grey",
lty = 2)
# but we just want to target pixels in that one region, so we can first
# determine a bounding box for it by plotting a grid:
plotImageArray(fit3$recolored_img)
axis(1, line = 3); axis(2, line = 1)
abline(v = seq(0, 1, by = 0.1),
h = seq(0, 1, by = 0.1),
col = "darkgrey",
lty = 2)
# but we just want to target pixels in that one region, so we can first
# determine a bounding box for it by plotting a grid:
plotImageArray(fit3$recolored_img)
# but we just want to target pixels in that one region, so we can first
# determine a bounding box for it by plotting a grid:
plotImageArray(fit3$recolored_img)
axis(1, line = 3); axis(2, line = 1)
abline(v = seq(0, 1, by = 0.1),
h = seq(0, 1, by = 0.1),
col = grey(0.2),
lty = 2)
# x-axis range: 0.5-0.7
# y-axis range: 0.55-0.75
# let's try it:
fit4 <- absorbLayer(fit3, layer_idx = 4,
size_condition = function(x) x < 100,
x_range = c(0.5, 0.7),
y_range = c(0.55, 0.75),
highlight_color = "cyan")
# x-axis range: 0.5-0.7
# y-axis range: 0.55-0.75
# let's try it:
fit4 <- absorbLayer(fit3, layer_idx = 4,
size_condition = function(x) x < 100,
x_range = c(0.5, 0.7),
y_range = c(0.55, 0.75),
highlight_color = "yellow")
# the brown patch is easier to deal with, since size thresholding alone is
# sufficient; we want to leave the stripes intact, so we'll absorb components
# that are 50-250 pixels OR fewer than 20 pixels (to get the tiny speckles),
# leaving the eyes intact
fit3 <- absorbLayer(fit2, layer_idx = 3,
size_condition = function(x) x <= 250 &
x >= 50 |
x < 20,
highlight_color = "cyan")
devtools::load_all(".")
?absorbLayer
fit1 <- recolorize(img, bins = 3, plotting = FALSE)
img <- system.file("extdata/fulgidissima.png", package = "recolorize")
fit1 <- recolorize(img, bins = 3, plotting = FALSE)
fit2 <- recluster(fit1, similarity_cutoff = 65)
devtools::load_all(".")
fit3 <- absorbLayer(fit2, 5)
fit3 <- absorbLayer(fit2, 5, size_condition = function(x) x < Inf)
img <- "../../beetles/machine_learning/color_maps/test3-dorsal-nopin_INIT_FIT/ICDB000059.png"
fit1 <- recolorize(img, resize = 0.5, bins = 4)
fit1 <- recolorize(img, resize = 0.5, method = "k", n = 14)
plot(fit1)
fit2 <- absorbLayer(fit1, 4)
plot(fit2)
plotImageArray(fit2$recolored_img)
plot(fit2)
plotImageArray(fit2$recolored_img)
fit2$centers
table(fit2$pixel_assignments)
devtools::load_all(".")
plotImageArray(fit2$recolored_img)
fit2 <- absorbLayer(fit1, 4)
plot(fit2)
fit3 <- absorbLayer(fit2, 8)
