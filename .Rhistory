recolored.images$1
# increasing numbers of kmean colors
recolored.images <- setNames(vector("list", length = 10),
as.character(c(1:10)))
recolored.images
for (i in 1:10) {
recolored.images[[i]] <- classifyColorManual(img, method = "kmeans",
n = i)
}
# increasing numbers of kmean colors
recolored.images <- setNames(vector("list", length = 10))
# increasing numbers of kmean colors
recolored.images <- vector("list", length = 10)
for (i in 1:10) {
recolored.images[[i]] <- classifyColorManual(img, method = "kmeans",
n = i)
}
layout(matrix(1:10, nrow = 2))
lapply(recolored.images,
function(i) hist(i$color.residuals$sq_residuals,
border = NA, main = paste(i, "clusters")), freq = FALSE,
xlim = c(0, 1))
recolored.images[[1]]
recolored.images[[1]]$color.residuals$sq_residuals
lapply(recolored.images, function(i) hist(i$color.residuals$sq_residuals))
lapply(recolored.images,
function(i) hist(i$color.residuals$sq_residuals))
lapply(recolored.images,
function(i) hist(i$color.residuals$sq_residuals,
border = NA))
lapply(recolored.images,
function(i) hist(i$color.residuals$sq_residuals,
border = NA, main = paste(i, "clusters")))
lapply(recolored.images,
function(i) hist(i$color.residuals$sq_residuals,
border = NA, main = paste(i, "clusters")))
sapply(1:length(recolored.images),
function(i) hist(recolored.images[[i]]$color.residuals$sq_residuals,
border = NA, main = paste(i, "clusters")))
layout(matrix(1:10, nrow = 2))
sapply(1:length(recolored.images),
function(i) hist(recolored.images[[i]]$color.residuals$sq_residuals,
border = NA, main = paste(i, "clusters")))
sapply(1:length(recolored.images),
function(i) hist(recolored.images[[i]]$color.residuals$sq_residuals,
border = NA, main = paste(i, "cluster(s)"),
freq = FALSE, xlim = c(0, 1)))
layout(matrix(1:10, nrow = 2, byrow = TRUE))
sapply(1:length(recolored.images),
function(i) hist(recolored.images[[i]]$color.residuals$sq_residuals,
border = NA, main = paste(i, "cluster(s)"),
freq = FALSE, xlim = c(0, 1)))
sapply(1:length(recolored.images),
function(i) hist(recolored.images[[i]]$color.residuals$sq_residuals,
border = NA, main = paste(i, "cluster(s)"),
freq = FALSE, xlab = "Squared residual",
xlim = c(0, 1)), ylim = c(0, 50))
sapply(1:length(recolored.images),
function(i) hist(recolored.images[[i]]$color.residuals$sq_residuals,
border = NA, main = paste(i, "cluster(s)"),
freq = FALSE, xlab = "Squared residual",
xlim = c(0, 1)))
residual_vec <- sapply(1:length(recolored.images),
function(i) recolored.images[[i]]$color.residuals$tot_residuals)
plot(residual_vec, type = 'b')
plot(residual_vec, type = 'b')
devtools::load_all(".")
?colorResiduals
?classifyColorManual
plot(residual_vec, type = 'b',
ylab = "Sum of squared residuals",
xlab = "Cluster number")
werner <- read.csv("../werner_nomenclature/werner_colors.csv")
hex <- werner$hex
rgb <- werner[grep("rgb", colnames(werner)), ]
rgb
grep("rgb", colnames(werner))
rgb <- werner[ , grep("rgb", colnames(werner))]
rgb
hex_palette <- werner$hex
rgb_palette <- werner[ , grep("rgb", colnames(werner))]
werner <- read.csv("../werner_nomenclature/werner_colors.csv")
hex_palette <- werner$hex
rgb_palette <- werner[ , grep("rgb", colnames(werner))]
hex_palette
rgb_palette
devtools::load_all(".")
plotColorPalette(rgb_palette)
plotColorPalette(rgb_palette, cex.text = 0)
plotColorPalette(rgb_palette, cex.text = NA)
par(mar = rep(0, 4))
plotColorPalette(rgb_palette, cex.text = NA)
plotColorPalette(rgb_palette)
plotColorPalette(rgb_palette, horiz = FALSE)
is.numeric(rgb_palette)
is.numeric(rgb_palette$rgb_R)
dim(rgb_palette)
typeof(rgb_palette)
typeof(hex_palette)
class(rgb_palette)
class(hex_palette)
grep("#", hex_palette)
is.vector(hex_palette)
is.vector(rgb_palette)
dim(hex_palette)
dim(rgb_palette)
dim(hex_palette) == 2
dim(rgb_palette) == c(110, 3)
dim(rgb_palette)[2] == 3
dim(hex_palette)[2] == 2
if(dim(hex_palette)[2] == 2) {print("i")}
plotColorPalette <- function(color.centers, sizes = NULL,
cex.text = 2, horiz = TRUE, ...) {
# check if hex codes
if (is.vector(color.centers)) {
if (sum(grepl("#", color.centers)) == length(color.centers)) {
rgb.exp <- color.centers
} else {
stop("'color.centers' must be either a numeric RGB matrix with colors\n
as rows or a character vector of hex codes")
}
} else if (dim(color.centers)[2] != 3) {
stop("'color.centers' must have colors as rows and RGB coordinates as columns")
}
# make color vector
rgb.exp <- grDevices::rgb(color.centers[, 1],
color.centers[, 2],
color.centers[, 3])
# make a plot
if (is.null(sizes)) {
# if sizes are not included, make bars equal in size
colorbar <- rep(1, nrow(color.centers))
stats::setNames(colorbar, as.character(1:nrow(color.centers)))
# we're making the palettes in different ways, so horizontal plotting is
# reversed; this makes it consistent
horiz <- !horiz
} else {
# if so, make a fake "table" with counts
# this is a bit hacky, but it does make the bars adjacent instead of stacked
sizes <- sizes / sum(sizes)
sizes <- round(sizes * 1000)
colorbar <- unlist(sapply(1:length(sizes),
function(j) rep(j, sizes[j])))
colorbar <- table(colorbar, rep("", length(colorbar)))
# remove any empty values
if (any(sizes == 0)) {
rgb.exp <- rgb.exp[-which(sizes == 0)]
}
}
# plot the colors as a uniform bar
graphics::barplot(colorbar, col = rgb.exp,
axes = FALSE, space = 0, horiz = horiz,
border = NA, axisnames = FALSE, ...)
# text colors - black if the color is light, white if the color is dark
hsv.exp <- grDevices::rgb2hsv(t(color.centers), maxColorValue = 1)
text.colors <- round(hsv.exp[3, ]) + 1
# make text locations
if (horiz == FALSE) {
text.x <- seq(0.5, length(rgb.exp) - 0.5)
text.y <- 0.5
} else {
text.y <- seq(0.5, length(rgb.exp) - 0.5)
text.x <- 0.5
}
# only plot numbers if the sizes are equal
# when they're distorted by sizes it gets too wacky
if (is.null(sizes) & cex.text > 0) {
graphics::text(text.x, text.y,
cex = cex.text,
col = c("white", "black")[text.colors])
}
}
plotColorPalette(rgb_palette, cex.text = 0)
colordistance::plotClusters(cbind(rgb_palette, Pct = rep(1 / 110, 110)))
colordistance::plotClusters(cbind(rgb_palette, Pct = rep(1 / 200, 110)))
rand.colors <- matrix(runif(30), ncol = 3)
rand.colors
rgb(rand.colors)
# copy non-background pixels to change them
pix.recolor <- bg.indexed$non.bg
?recolorImages
?recolorImage
devtools::load_all(".")
?recolorImage
img.path <- system.file("extdata/corbetti.png", package = "recolorize")
img <- readImage(img.path)
bg.condition <- backgroundCondition(transparent = TRUE,
alpha.channel = TRUE)
bg.indexed <- backgroundIndex(img, bg.condition)
# histogram binning
hist.colors <- colorClusters(bg.indexed$non.bg,
method = "hist", bins = 2)
# shuffle colors
shuffle <- function(m) {
m[sample(1:nrow(m), nrow(m)), ]
}
hist.shuffle <- hist.colors
hist.shuffle$centers <- shuffle(hist.shuffle$centers)
# recolor based on the two cluster sets
hist.recolor <- recolorImage(bg.indexed, hist.colors)
shuffle.recolor <- recolorImage(bg.indexed, hist.shuffle)
# copy non-background pixels to change them
pix.recolor <- bg.indexed$non.bg
# clusters with any pixels assigned to them
cluster_idx <- as.numeric(names(color.clusters$sizes))
color.clusters <- hist.colors
color.clusters$centers
rownames(color.clusters)
# clusters with any pixels assigned to them
cluster_idx <- as.numeric(1:nrow(color.clusters$centers))
cluster_idx
?assignPixels
ctrs <- matrix(c(1, 1, 1,
0, 0, 0,
1, 0, 0,
0, 1, 0,
0, 0, 1,
1, 1, 0,
1, 0, 1,
0, 1, 1), byrow = TRUE, ncol = 3)
# plot it
recolorize::plotColorPalette(ctrs)
# create a pixel matrix of random colors
pixel.matrix <- matrix(runif(3000), ncol = 3)
# assign pixels
reassigned <- recolorize::assignPixels(ctrs, pixel.matrix, adjust.centers = TRUE)
recolorize::plotColorPalette(reassigned$centers)
color.centers <- ctrs
# I'm not sure this is really as fast as it could be
tmp <- sapply(1:nrow(pixel.matrix),
function(i) apply(color.centers, 1,
function(v) sum((pixel.matrix[i, ]-v)^2)))
tmp
dim(tmp)
# make returnables
pixel.assignments <- max.col(-t(tmp))  # find index of min distance
sizes <- table(pixel.assignments) # empty clusters?
sizes
ctrs <- matrix(c(1, 1, 1,
0, 0, 0,
1, 0, 0,
0, 1, 0,
0, 0, 1,
1, 1, 0,
1, 0, 1,
0, 1, 1), byrow = TRUE, ncol = 3)
# plot it
recolorize::plotColorPalette(ctrs)
# create a pixel matrix of random colors
pixel.matrix <- matrix(runif(300), ncol = 3)
# assign pixels
reassigned <- recolorize::assignPixels(ctrs, pixel.matrix, adjust.centers = TRUE)
recolorize::plotColorPalette(reassigned$centers)
werner
werner <- read.csv("../werner_nomenclature/werner_colors.csv")
werner <- werner[,grep("rgb", colnames(werner))]
ctrs <- werner
ctrs
color.centers <- werner
# I'm not sure this is really as fast as it could be
tmp <- sapply(1:nrow(pixel.matrix),
function(i) apply(color.centers, 1,
function(v) sum((pixel.matrix[i, ]-v)^2)))
# make returnables
pixel.assignments <- max.col(-t(tmp))  # find index of min distance
sizes <- table(pixel.assignments) # empty clusters?
sizes
length(sizes)
sum(sizes)
sizes <- rep(0, nrow(color.centers))
sizes
assignments <- table(pixel.assignments)
sizes[as.numeric(names(assignments))] <- assignments
sizes
devtools::load_all(".")
# load image (recolorize and imposeColors do this automatically)
img.path <- system.file("extdata/corbetti.png", package = "recolorize")
img <- readImage(img.path)
bg.condition <- backgroundCondition(transparent = TRUE,
alpha.channel = TRUE)
bg.indexed <- backgroundIndex(img, bg.condition)
# histogram binning
hist.colors <- colorClusters(bg.indexed$non.bg,
method = "hist", bins = 2)
# shuffle colors
shuffle <- function(m) {
m[sample(1:nrow(m), nrow(m)), ]
}
hist.shuffle <- hist.colors
hist.shuffle$centers <- shuffle(hist.shuffle$centers)
# recolor based on the two cluster sets
hist.recolor <- recolorImage(bg.indexed, hist.colors)
shuffle.recolor <- recolorImage(bg.indexed, hist.shuffle)
# plot them
layout(matrix(c(1, 2, 3), ncol = 3))
plotImageArray(img, main = "original")
plotImageArray(hist.recolor$recolored.img, main = "binning")
plotImageArray(shuffle.recolor$recolored.img, main = "shuffled colors")
library(recolorize)
?imposeColors
# RGB extremes (white, black, red, green, blue, yellow, magenta, cyan)
ctrs <- matrix(c(1, 1, 1,
0, 0, 0,
1, 0, 0,
0, 1, 0,
0, 0, 1,
1, 1, 0,
1, 0, 1,
0, 1, 1), byrow = TRUE, ncol = 3)
#
recolorize::plotColorPalette(ctrs)
# get image paths
ocellata <- system.file("extdata/ocellata.png", package = "recolorize")
# map to rgb extremes
recolorize::imposeColors(ocellata, ctrs, adjust.centers = FALSE)
# looks much better if we recalculate the centers from the image
recolorize::imposeColors(ocellata, ctrs, adjust.centers = TRUE)
# we can map one image to extracted colors from another image
# extract ocellata colors
ocellata.colors <- recolorize(ocellata)
# map fulgidissima to ocellata colors
fulgidissima <- system.file("extdata/ocellata.png",
package = "recolorize")
recolorize::imposeColors(fulgidissima,
ocellata.colors$centers,
adjust.centers = FALSE)
plotColorPalette(ocellata.colors$centers, sizes = ocellata.colors$sizes)
ctrs
color.centers
sizes
plotColorPalette(color.centers, sizes = sizes)
sizes
sizes
plotColorPalette(color.centers, sizes = sizes)
imposeColors(ocellata, color.centers)
# read in image
img <- readImage(img.path, resize = resize, rotate = rotate)
resize = NULL; rotate = NULL
# read in image
img <- readImage(img.path, resize = resize, rotate = rotate)
# make background condition
alpha.channel <- dim(img)[3] == 4 # is there a transparency channel?
bg.condition <- backgroundCondition(lower = lower, upper = upper,
center = NULL, radius = NULL,
transparent = transparent,
alpha.channel = alpha.channel)
bg.condition <- backgroundCondition(transparent = TRUE, alpha.channel = T)
# index background
bg.indexed <- backgroundIndex(img, bg.condition)
# color clusters & assign pixels
color.clusters <- assignPixels(color.centers, bg.indexed$non.bg,
adjust.centers = adjust.centers)
?assignPixels
ctrs <- matrix(c(1, 1, 1,
0, 0, 0,
1, 0, 0,
0, 1, 0,
0, 0, 1,
1, 1, 0,
1, 0, 1,
0, 1, 1), byrow = TRUE, ncol = 3)
# create a pixel matrix of random colors
pixel.matrix <- matrix(runif(3000), ncol = 3)
# assign pixels
reassigned <- recolorize::assignPixels(ctrs, pixel.matrix, adjust.centers = TRUE)
recolorize::plotColorPalette(reassigned$centers)
# color clusters & assign pixels
color.clusters <- assignPixels(color.centers, bg.indexed$non.bg,
adjust.centers = adjust.centers)
adjust.centers
adjust.centers = TRUE
adjust.centers = FALSE
# color clusters & assign pixels
color.clusters <- assignPixels(color.centers, bg.indexed$non.bg,
adjust.centers = adjust.centers)
# recolor based on assignments/centers
recolored <- recolorImage(bg.indexed, color.clusters,
plotting = FALSE,
remove.empty.clusters = FALSE)
color.clusters
# recolor based on assignments/centers
recolored <- recolorImage(bg.indexed, color.clusters,
plotting = FALSE,
remove.empty.clusters = FALSE)
# copy non-background pixels to change them
pix.recolor <- bg.indexed$non.bg
# clusters with any pixels assigned to them
cluster_idx <- as.numeric(1:nrow(color.clusters$centers))
# empty centers
empty_centers <- which(color.clusters$sizes == 0)
# for every non-empty cluster:
for (i in cluster_idx) {
# get the new color
new_color <- as.matrix(color.clusters$centers[i, ])
# get pixels assigned to that color
pix.idx <- which(color.clusters$pixel.assignments == i)
# repeat the new color for a substitute matrix
replacements <- matrix(new_color, ncol = 3, byrow = TRUE,
nrow = length(pix.idx))
# and stick it back in!
pix.recolor[pix.idx, 1:3] <- replacements
}
cluster_idx
devtools::load_all(".")
# for every non-empty cluster:
for (i in cluster_idx) {
# get the new color
new_color <- as.matrix(color.clusters$centers[i, ])
# get pixels assigned to that color
pix.idx <- which(color.clusters$pixel.assignments == i)
# repeat the new color for a substitute matrix
replacements <- matrix(new_color, ncol = 3, byrow = TRUE,
nrow = length(pix.idx))
# and stick it back in!
pix.recolor[pix.idx, 1:3] <- replacements
}
# copy non-background pixels to change them
pix.recolor <- bg.indexed$non.bg
# clusters with any pixels assigned to them
cluster_idx <- which(color.clusters$sizes != 0)
# empty centers
empty_centers <- which(color.clusters$sizes == 0)
# for every non-empty cluster:
for (i in cluster_idx) {
# get the new color
new_color <- as.matrix(color.clusters$centers[i, ])
# get pixels assigned to that color
pix.idx <- which(color.clusters$pixel.assignments == i)
# repeat the new color for a substitute matrix
replacements <- matrix(new_color, ncol = 3, byrow = TRUE,
nrow = length(pix.idx))
# and stick it back in!
pix.recolor[pix.idx, 1:3] <- replacements
}
# slot new pixels back in
recolored.img <- bg.indexed$flattened.img
# if there's no background...
if (length(bg.indexed$idx.flat) == 0) {
recolored.img <- pix.recolor
} else {
recolored.img[-bg.indexed$idx.flat, ] <- pix.recolor
# color background in white or transparent
if (bg.recolor == "white") {
recolored.img[bg.indexed$idx.flat, ] <- 1
} else if (bg.recolor == "transparent") {
alpha.channel <- rep(1, nrow(recolored.img))
alpha.channel[bg.indexed$idx.flat] <- 0
recolored.img <- cbind(recolored.img, alpha.channel)
colnames(recolored.img) <- NULL
bg.indexed$img.dims[3] <- 4
}
}
# reshape
dim(recolored.img) <- bg.indexed$img.dims
if (plotting) {
plotImageArray(recolored.img, main = main)
}
plotImageArray(recolored.img, main = main)
devtools::load_all(".")
?imposeColors
recolorize::imposeColors(fulgidissima,
ocellata.colors$centers,
adjust.centers = FALSE)
devtools::load_all(".")
recolorize::imposeColors(fulgidissima,
ocellata.colors$centers,
adjust.centers = FALSE)
# read in image
img <- readImage(img.path, resize = resize, rotate = rotate)
# make background condition
alpha.channel <- dim(img)[3] == 4 # is there a transparency channel?
bg.condition <- backgroundCondition(lower = lower, upper = upper,
center = NULL, radius = NULL,
transparent = transparent,
alpha.channel = alpha.channel)
bg.condition
# index background
bg.indexed <- backgroundIndex(img, bg.condition)
# color clusters & assign pixels
color.clusters <- assignPixels(color.centers, bg.indexed$non.bg,
adjust.centers = adjust.centers)
# recolor based on assignments/centers
recolored <- recolorImage(bg.indexed, color.clusters,
plotting = FALSE,
remove.empty.clusters = FALSE)
color.clusters$sizes
# get sizes vector
sizes <- color.clusters$sizes
if (scale.palette) { s <- sizes } else { s <- NULL }
scale.palette = TRUE
if (scale.palette) { s <- sizes } else { s <- NULL }
s
plotRecolorized(recolored$recolored.img, img,
plot.original = TRUE,
recolored$centers, horiz = horiz,
cex.text = cex.text,
sizes = s)
horiz = TRUE
plotRecolorized(recolored$recolored.img, img,
plot.original = TRUE,
recolored$centers, horiz = horiz,
cex.text = cex.text,
sizes = s)
plotRecolorized(recolored$recolored.img, img,
plot.original = TRUE,
recolored$centers, horiz = horiz,
cex.text = 2,
sizes = s)
devtools::load_all(".")
recolorize::imposeColors(fulgidissima,
ocellata.colors$centers,
adjust.centers = FALSE)
