# ...switch that component to the color of the patch
# with which it shares the longest border
majority_rule <- which(recolorize_obj$sizes[ctr_idx] ==
max(recolorize_obj$sizes[ctr_idx]))
ctr_idx <- ctr_idx[majority_rule]
}
# and change the indices
map[component] <- as.numeric(ctr_idx)
i <- i + 1
}
plot(map)
# switch the new patch map in
map <- cimg_to_array(map)
# if we completely eliminated a patch...
if (length(condition_met) == length(layer_split)) {
# change the higher indices to match new centers
if (layer_idx < nrow(recolorize_obj$centers)) {
map[map > layer_idx] <- map[map > layer_idx] - 1
}
# remove it from the color centers
recolorize_obj$centers <- recolorize_obj$centers[-layer_idx, ]
rownames(recolorize_obj$centers) <- 1:nrow(recolorize_obj$centers)
}
# switch in the new map
recolorize_obj$pixel_assignments <- map
# and make the image
new_img <- constructImage(map,
recolorize_obj$centers)
plotImageArray(new_img)
# then, get new sizes (minus background)
recolorize_obj$sizes <- table(map)[-1]
table(map)
# get boundaries of original pixels & make highlighted array
components <- layer_split[condition_met]
layer_px <- imager::as.pixset(imager::add(components) > 0)
px_bound <- imager::boundary(imager::grow(layer_px, 1))
old_img <- array_to_cimg(constructImage(old_map,
recolorize_obj$centers))
highlight_img <- imager::colorise(old_img,
px_bound, col = highlight_color)
highlight_img <- cimg_to_array(highlight_img)
# plot highlighted
graphics::layout(matrix(1:3, 1), widths = c(0.4, 0.4, 0.2))
plotImageArray(highlight_img, main = paste("selected components"))
old_img <- array_to_cimg(constructImage(old_map,
recolorize_obj$centers))
range(old_img)
hist(old_img)
hist(old_img)
devtools::load_all(".")
test <- absorbLayer(recolorize_obj, 1, size_condition = function(s) s <= Inf)
devtools::load_all(".")
test <- absorbLayer(recolorize_obj, 1, size_condition = function(s) s <= Inf)
recolorize_obj <- recolorize2(img, cutoff = 45)
rc <- absorbLayer(recolorize_obj, 1)
img
img <- system.file("extdata/corbetti.png", package = "recolorize")
recolorize_obj <- recolorize2(img, cutoff = 45)
# get layer
layer <- splitByColor(recolorize_obj,
layers = layer_idx,
plot_method = "none")[[1]]
layer_idx = 1
# get layer
layer <- splitByColor(recolorize_obj,
layers = layer_idx,
plot_method = "none")[[1]]
cimg_layer <- imager::as.cimg(layer)
# edit
new_layer <- apply_imager_operation(cimg_layer, operation, px_size)
operation = 'clean'
px_size = 2
# get layer
layer <- splitByColor(recolorize_obj,
layers = layer_idx,
plot_method = "none")[[1]]
cimg_layer <- imager::as.cimg(layer)
# edit
new_layer <- apply_imager_operation(cimg_layer, operation, px_size)
# set the original layer to background
original_idx <- which(recolorize_obj$pixel_assignments == layer_idx)
recolorize_obj$pixel_assignments[original_idx] <- 0
# set the new layer
array_layer <- cimg_to_array(new_layer)
recolorize_obj$pixel_assignments[which(array_layer > 0)] <- layer_idx
recolorize_obj$sizes[layer_idx] <- sum(array_layer)
# and reconstruct the image
recolorize_obj$recolored_img <- constructImage(recolorize_obj$pixel_assignments,
recolorize_obj$centers)
# for resetting
user_par <- graphics::par(no.readonly = TRUE)
graphics::layout(matrix(1:3, nrow = 1))
plotImageArray(layer, main = "original layer")
plotImageArray(array_layer, main = "edited layer")
plotImageArray(recolorize_obj$recolored_img,
main = "resulting color map")
# reset parameters
graphics::par(user_par)
layer_idx = "all"
operations = "clean"
px_sizes = 2
if (!is.numeric(layer_idx)) {
if (layer_idx == "all") {
layer_idx <- 1:nrow(recolorize_obj$centers)
} else {
stop("'layer_idx' must be either 'all' or a numeric
vector of layer indices to edit")
}
}
# make sure operations and px_sizes are the same length
if (length(layer_idx) != length(operations)) {
operations <- rep(operations, length.out = length(layer_idx))
}
if (length(layer_idx) != length(px_sizes)) {
px_sizes <- rep(px_sizes, length.out = length(layer_idx))
}
# for every layer...
for (i in 1:length(layer_idx)) {
# edit it accordingly
recolorize_obj <- editLayer(recolorize_obj,
layer_idx = layer_idx[i],
operation = operations[i],
px_size = px_sizes[i],
plotting = FALSE)
}
plot(recolorize_obj)
devtools::load_all(".")
?imDist
fulgidissima <- system.file("extdata/fulgidissima.png",
package = "recolorize")
fulgidissima_2bin <- recolorize(fulgidissima, "hist", bins = 2)
dist_2bin <- imDist(fulgidissima_2bin$original_img,
fulgidissima_2bin$recolored_img)
fulgidissima <- png::readPNG(fulgidissima)
fulgidissima_2bin <- recolorize(fulgidissima, "hist", bins = 2)
devtools::load_all(".")
?imDist
fulgidissima <- system.file("extdata/fulgidissima.png",
package = "recolorize")
# make an initial histogram fit
# this doesn't look great:
fulgidissima_2bin <- recolorize(fulgidissima, "hist", bins = 2)
# and we can see that everywhere but the head has pretty high residuals:
dist_2bin <- imDist(fulgidissima_2bin$original_img,
fulgidissima_2bin$recolored_img)
# using 3 bins/channel looks much better:
fulgidissima_3bin <- recolorize(fulgidissima, "hist", bins = 3)
# and we can see that on the heatmap:
dist_3bin <- imDist(fulgidissima_3bin$original_img,
fulgidissima_3bin$recolored_img)
# default behavior is to se the color range to the range of distances
# in a single matrix; to compare two different fits, we have to provide
# the same `zlim` scale for both
r <- range(c(dist_2bin, dist_3bin), na.rm = TRUE)
# now we can plot them to compare the fits:
layout(matrix(1:2, nrow = 1))
imHeatmap(dist_2bin, range = r)
imHeatmap(dist_3bin, range = r)
# we can also use other color spaces:
rgb_3bin <- imDist(fulgidissima_3bin$original_img,
fulgidissima_3bin$recolored_img,
color_space = "sRGB")
# looks oddly worse, but to keep things in perspective,
# you can set the range to the maximum color distance in RGB space:
imHeatmap(rgb_3bin, range = c(0, sqrt(3)))
# not useful for troubleshooting, but broadly reassuring!
fulgidissima <- system.file("extdata/fulgidissima.png",
package = "recolorize")
# make an initial histogram fit
# this doesn't look great:
fulgidissima_2bin <- recolorize(fulgidissima, "hist", bins = 2)
?imDist
fulgidissima <- system.file("extdata/fulgidissima.png",
package = "recolorize")
fulgidissima <- png::readPNG(fulgidissima)
# make an initial histogram fit
# this doesn't look great:
fulgidissima_2bin <- recolorize(fulgidissima, "hist", bins = 2)
# we can compare with the original image by creating the recolored
# image from the colormap
recolored_2bin <- constructImage(fulgidissima_2bin$pixel_assignments,
fulgidissima_2bin$centers)
dist_2bin <- imDist(im1 = fulgidissima,
im2 = recolored_2bin)
# using 3 bins/channel looks much better:
fulgidissima_3bin <- recolorize(fulgidissima, "hist", bins = 3)
# and we can see that on the heatmap:
recolored_3bin <- constructImage(fulgidissima_3bin$pixel_assignments,
fulgidissima_3bin$centers)
dist_3bin <- imDist(im1 = fulgidissima,
im2 = recolored_3bin)
# default behavior is to set the color range to the range of distances
# in a single matrix; to compare two different fits, we have to provide
# the same `zlim` scale for both
r <- range(c(dist_2bin, dist_3bin), na.rm = TRUE)
# now we can plot them to compare the fits:
layout(matrix(1:2, nrow = 1))
imHeatmap(dist_2bin, range = r)
imHeatmap(dist_3bin, range = r)
# we can also use other color spaces:
rgb_3bin <- imDist(fulgidissima,
recolored_3bin,
color_space = "sRGB")
# looks oddly worse, but to keep things in perspective,
# you can set the range to the maximum color distance in RGB space:
imHeatmap(rgb_3bin, range = c(0, sqrt(3)))
chongi <- png::readPNG(chongi)
chongi <- system.file("extdata/chongi.png", package = "recolorize")
chongi <- png::readPNG(chongi)
chongi_k <- recolorize(chongi, "k", n = 5)
recolored_chongi <- constructImage(chongi_k$pixel_assignments, chongi_k$centers)
?imHeatmap
chongi <- system.file("extdata/chongi.png", package = "recolorize")
chongi <- png::readPNG(chongi)
chongi_k <- recolorize(chongi, "k", n = 5)
recolored_chongi <- constructImage(chongi_k$pixel_assignments,
chongi_k$centers)
d <- imDist(chongi,
recolored_chongi, plotting = FALSE)
# original flavor
imHeatmap(d)
# bit offputting
imHeatmap(d, palette = colorRamps::ygobb(100))
# just dreadful
imHeatmap(d, palette = colorRamps::primary.colors(100))
devtools::load_all(".")
?mergeLayers
# image path:
img <- system.file("extdata/corbetti.png", package = "recolorize")
# initial fit, 8 bins:
init_fit <- recolorize(img)
# redundant green, red, and blue clusters
# to make it easier to see, we can plot the numbered palette:
layout(matrix(1:2, nrow = 1))
plotImageArray(init_fit$recolored_img)
plotColorPalette(init_fit$centers, horiz = FALSE)
# based on visual inspection, we should merge:
mlist <- list(c(3, 5),
c(4, 7),
c(6, 8))
# we can merge with that list, leaving layers 1 & 2 intact:
vis_merge <- mergeLayers(init_fit,
merge_list = mlist)
# we can include layers 1 & 2 as their own list elements,
# leaving them intact (result is identical to above):
mlist2 <- list(1, 2,
c(3, 5),
c(4, 7),
c(6, 8))
redundant_merge <- mergeLayers(init_fit,
merge_list = mlist2)
# we can also swap layer order this way without actually merging layers:
swap_list <- list(2, 5, 3, 4, 1)
swap_layers <- mergeLayers(redundant_merge,
merge_list = swap_list)
# merging everything but the first layer into a single layer,
# and making that merged layer orange (result looks
# a bit like a milkweed bug):
milkweed_impostor <- mergeLayers(init_fit,
merge_list = list(c(2:8)),
color_to = "orange")
# we can also shuffle all the layer colors while
# leaving their geometry intact:
centers <- vis_merge$centers
centers <- centers[sample(1:nrow(centers), nrow(centers)), ]
shuffle_layers <- mergeLayers(vis_merge,
merge_list = as.list(1:5),
color_to = centers)
# (this is not really the intended purpose of this function)
# image path:
img <- system.file("extdata/corbetti.png", package = "recolorize")
# initial fit, 8 bins:
init_fit <- recolorize(img)
# redundant green, red, and blue clusters
# to make it easier to see, we can plot the numbered palette:
layout(matrix(1:2, nrow = 1))
plotImageArray(init_fit$recolored_img)
plotColorPalette(init_fit$centers, horiz = FALSE)
# based on visual inspection, we should merge:
mlist <- list(c(3, 5),
c(4, 7),
c(6, 8))
# we can merge with that list, leaving layers 1 & 2 intact:
vis_merge <- mergeLayers(init_fit,
merge_list = mlist)
# we can include layers 1 & 2 as their own list elements,
# leaving them intact (result is identical to above):
mlist2 <- list(1, 2,
c(3, 5),
c(4, 7),
c(6, 8))
redundant_merge <- mergeLayers(init_fit,
merge_list = mlist2)
# we can also swap layer order this way without actually merging layers:
swap_list <- list(2, 5, 3, 4, 1)
swap_layers <- mergeLayers(redundant_merge,
merge_list = swap_list)
# merging everything but the first layer into a single layer,
# and making that merged layer orange (result looks
# a bit like a milkweed bug):
milkweed_impostor <- mergeLayers(init_fit,
merge_list = list(c(2:8)),
color_to = "orange")
# we can also shuffle all the layer colors while
# leaving their geometry intact:
centers <- vis_merge$centers
centers <- centers[sample(1:nrow(centers), nrow(centers)), ]
shuffle_layers <- mergeLayers(vis_merge,
merge_list = as.list(1:5),
color_to = centers)
# (this is not really the intended purpose of this function)
plot(init_fit)
devtools::load_all(".")
?mergeLayers
# image path:
img <- system.file("extdata/corbetti.png", package = "recolorize")
# initial fit, 8 bins:
init_fit <- recolorize(img)
# redundant green, red, and blue clusters
# to make it easier to see, we can plot the numbered palette:
plot(init_fit)
# based on visual inspection, we should merge:
mlist <- list(c(3, 5),
c(4, 7),
c(6, 8))
# we can merge with that list, leaving layers 1 & 2 intact:
vis_merge <- mergeLayers(init_fit,
merge_list = mlist)
devtools::load_all(".")
# we can merge with that list, leaving layers 1 & 2 intact:
vis_merge <- mergeLayers(init_fit,
merge_list = mlist)
?mergeLayers
# image path:
img <- system.file("extdata/corbetti.png", package = "recolorize")
# initial fit, 8 bins:
init_fit <- recolorize(img)
# redundant green, red, and blue clusters
# to make it easier to see, we can plot the numbered palette:
layout(matrix(1:2, nrow = 1))
plotImageArray(init_fit$recolored_img)
plotColorPalette(init_fit$centers, horiz = FALSE)
devtools::load_all(".")
devtools::load_all(".")
?mergeLayers
# image path:
img <- system.file("extdata/corbetti.png", package = "recolorize")
# initial fit, 8 bins:
init_fit <- recolorize(img)
# redundant green, red, and blue clusters
# to make it easier to see, we can plot the numbered palette:
plot(init_fit)
# based on visual inspection, we should merge:
mlist <- list(c(3, 5),
c(4, 7),
c(6, 8))
# we can merge with that list, leaving layers 1 & 2 intact:
vis_merge <- mergeLayers(init_fit,
merge_list = mlist)
# we can include layers 1 & 2 as their own list elements,
# leaving them intact (result is identical to above):
mlist2 <- list(1, 2,
c(3, 5),
c(4, 7),
c(6, 8))
redundant_merge <- mergeLayers(init_fit,
merge_list = mlist2)
# we can also swap layer order this way without actually merging layers:
swap_list <- list(2, 5, 3, 4, 1)
swap_layers <- mergeLayers(redundant_merge,
merge_list = swap_list)
# merging everything but the first layer into a single layer,
# and making that merged layer orange (result looks
# a bit like a milkweed bug):
milkweed_impostor <- mergeLayers(init_fit,
merge_list = list(c(2:8)),
color_to = "orange")
# we can also shuffle all the layer colors while
# leaving their geometry intact:
centers <- vis_merge$centers
centers <- centers[sample(1:nrow(centers), nrow(centers)), ]
shuffle_layers <- mergeLayers(vis_merge,
merge_list = as.list(1:5),
color_to = centers)
# (this is not really the intended purpose of this function)
?pixelAssignMatrix
?recolorize
devtools::load_all(".")
?recolorize
img <- system.file("extdata/chongi.png", package = "recolorize")
rc <- recolorize(img)
rc <- recolorize(img, bins = c(4, 1, 1))
rc <- recolorize(img, method = "kmeans", n = 8)
recolored_images <- setNames(vector("list", length = 10), c(1:10))
for (i in 1:10) {
kmeans_recolor <- recolorize(img, method = "kmeans", n = i) }
kmeans_recolor <- recolorize(img, method = "kmeans", n = 8, plotting = F)
hist_recolor <- recolorize(img, method = "hist", bins = 2, plotting = F)
layout(matrix(c(1, 2, 3), ncol = 3))
plot(kmeans_recolor$original_img, main = "original")
plot(recoloredImage(kmeans_recolor, type = "raster"), main = "kmeans")
plot(recoloredImage(hist_recolor, type = "raster), main = "binning")
plot(recoloredImage(hist_recolor, type = "raster"), main = "binning")
plot(recoloredImage(hist_recolor, type = "raster"), title = "fda")
plot(recoloredImage(hist_recolor, type = "raster"))
plot(recoloredImage(hist_recolor, type = "raster"), "fdsjkal")
?plot.raster
?recolorize
# filepath to image
img <- system.file("extdata/chongi.png", package = "recolorize")
# default: histogram, 2 bins/channel
rc <- recolorize(img)
# we can also have different numbers of bins per channel
rc <- recolorize(img, bins = c(4, 1, 1)) # mostly red
rc <- recolorize(img, bins = c(1, 4, 1)) # mostly green
rc <- recolorize(img, bins = c(1, 1, 4)) # mostly blue
# kmeans can produce a better fit with fewer colors
rc <- recolorize(img, method = "kmeans", n = 8)
# increasing numbers of kmean colors
recolored_images <- setNames(vector("list", length = 10), c(1:10))
for (i in 1:10) {
kmeans_recolor <- recolorize(img, method = "kmeans",
n = i)
}
# kmeans, 10 colors
kmeans_recolor <- recolorize(img, method = "kmeans",
n = 8, plotting = FALSE)
hist_recolor <- recolorize(img, method = "hist",
bins = 2, plotting = FALSE)
# compare binning vs. kmeans clustering
layout(matrix(c(1, 2, 3), ncol = 3))
plot(kmeans_recolor$original_img); title("original")
plot(recoloredImage(kmeans_recolor, type = "raster")); title("kmeans")
plot(recoloredImage(hist_recolor, type = "raster")); title("binning")
img <- system.file("extdata/fulgidissima.png", package = "recolorize")
init_fit <- recolorize(img, bins = 3)
thresh_fit <- thresholdRecolor(init_fit, pct = 0.1)
pct = .1
# threshold cutoff:
pct <- 1 - pct
# get sizes:
sizes <- recolorize_obj$sizes
recolorize_obj <- thresh_fit
recolorize_obj <- init_fit
# get sizes:
sizes <- recolorize_obj$sizes
# get size order:
size_order <- order(sizes, decreasing = TRUE)
# normalize so we get proportions:
size_norm <- sizes[size_order] / sum(sizes)
# take cumulative sum, and only take those clusters whose cumulative
# sum is enough to reach the cutoff:
keep_idx <- size_order[1:which(cumsum(size_norm) >= pct)[1]]
# refit, using those colors
img <- raster_to_array(recolorize_obj$original_img)
refit <- imposeColors(img = img,
centers = recolorize_obj$centers[keep_idx, ],
plotting = FALSE,
...)
refit <- imposeColors(img = img,
centers = recolorize_obj$centers[keep_idx, ],
plotting = FALSE)
?thresholdRecolor
img <- system.file("extdata/fulgidissima.png", package = "recolorize")
init_fit <- recolorize(img, bins = 3)
thresh_fit <- thresholdRecolor(init_fit, pct = 0.1)
# if you take it too far, you just get one color back:
thresh_fit_oops <- thresholdRecolor(init_fit, pct = 1)
devtools::load_all(".")
img <- system.file("extdata/fulgidissima.png", package = "recolorize")
init_fit <- recolorize(img, bins = 3)
thresh_fit <- thresholdRecolor(init_fit, pct = 0.1)
# if you take it too far, you just get one color back:
thresh_fit_oops <- thresholdRecolor(init_fit, pct = 1)
graphics::par(mar = rep(1, 4))
devtools::load_all(".")
img <- system.file("extdata/fulgidissima.png", package = "recolorize")
init_fit <- recolorize(img, bins = 3)
thresh_fit <- thresholdRecolor(init_fit, pct = 0.1)
# if you take it too far, you just get one color back:
thresh_fit_oops <- thresholdRecolor(init_fit, pct = 1)
?wernerColor
corbetti <- system.file("extdata/corbetti.png", package = "recolorize")
recolored_corbetti <- recolorize(corbetti, plotting = FALSE)
corbetti_werner <- wernerColor(recolored_corbetti,
which_img = "original",
n_colors = 6)
recolorize_obj$centers
recolorize_obj <- recluster(recolorize_obj, similarity_cutoff = 30)
recolorize_obj <- recluster(recolorize_obj, similarity_cutoff = 60)
# first, convert werner colors to lab
werner_rgb <- t(grDevices::col2rgb(recolorize::werner$hex)) / 255
werner_lab <- grDevices::convertColor(werner_rgb,
"sRGB", "Lab")
# get centers
centers <- recolorize_obj$centers
centers <- grDevices::convertColor(centers,
"sRGB", "Lab")
# get distances
tmp <- sapply(1:nrow(centers),
function(i) apply(werner_lab, 1,
function(v) sqrt(sum((centers[i, ]-v)^2))))
# find index of min distance
werner_idx <- max.col(-t(tmp))
# get new colors
werner_centers <- werner_rgb[werner_idx, ]
img <- raster_to_array(recolorize_obj$original_img)
dim(img)
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
