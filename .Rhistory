test <- absorbLayer(recolorize_obj, 1, size_condition = function(s) s <= 10)
size_condition
plot(recolorize_obj)
# get object layer
layer <- splitByColor(recolorize_obj, layers = layer_idx,
plot_method = "none")[[1]]
# convert to an imager pixset for splitting
px <- imager::as.pixset(imager::as.cimg(layer) > 0)
# split separate components
layer_split <- imager::split_connected(px)
# get component sizes
component_sizes <- unlist(lapply(layer_split, sum))
# find which components satisfy the size condition
condition_met <- which(ifelse(size_condition(component_sizes), TRUE, FALSE))
# location condition - bounding box
# get bounding box (in pixel coordinates) of each component:
component_bbox <- lapply(layer_split, function(l) apply(which(l[ , , 1, 1],
arr.ind = TRUE), 2,
range))
# convert to fraction of image dimensions:
imdim <- dim(recolorize_obj$original_img)[1:2]
norm_matrix <- matrix(imdim, nrow = 2, ncol = 2, byrow = TRUE)
component_bbox_norm <- lapply(component_bbox,
function(b) round(b / norm_matrix, 3))
# important - remember that imager rotates images 90 degrees (argh),
# so y-axis is rows and x-axis is columns
y_range <- 1 - y_range # also the y-axis is flipped
bbox_condition_met <- lapply(component_bbox_norm,
function(b) any(any(b[ , 1] >= y_range[2]) &
any(b[ , 1] <= y_range[1])) &
any(any(b[ , 2] >= x_range[1]) &
any(b[ , 2] <= x_range[2])))
condition_met <- intersect(condition_met,
which(unlist(bbox_condition_met)))
# make a color center map from the pixel assignments (this will make sense in
# a bit)
old_map <- recolorize_obj$pixel_assignments
map <- imager::as.cimg(old_map)
# for every component that meets the size condition:
for (i in condition_met) {
# extract the component
component <- layer_split[[i]]
# get indices of immediately adjacent pixels
px_contour <- imager::boundary(imager::grow(component, 3))
# count which color patches those pixels are assigned to
border_cols <- table(map[px_contour])
# we don't want to turn these pixels transparent, so we'll ignore
# any borders with the background (patch 0):
if(names(border_cols)[1] == "0") {
border_cols <- border_cols[-1]
}
# get name of longest border
ctr_idx <- names(which(border_cols == max(border_cols)))
ctr_idx <- as.numeric(ctr_idx)
# if there is more than one color patch bordering it...
if (length(ctr_idx) > 1) {
# ...switch that component to the color of the patch
# with which it shares the longest border
majority_rule <- which(recolorize_obj$sizes[ctr_idx] ==
max(recolorize_obj$sizes[ctr_idx]))
ctr_idx <- ctr_idx[majority_rule]
}
# and change the indices
map[component] <- as.numeric(ctr_idx)
i <- i + 1
}
# switch the new patch map in
map <- cimg_to_array(map)
map
# if we completely eliminated a patch...
if (length(condition_met) == length(layer_split)) {
# change the higher indices to match new centers
if (layer_idx < nrow(recolorize_obj$centers)) {
map[map > layer_idx] <- map[map > layer_idx] - 1
}
# remove it from the color centers
recolorize_obj$centers <- recolorize_obj$centers[-layer_idx, ]
rownames(recolorize_obj$centers) <- 1:nrow(recolorize_obj$centers)
}
# switch in the new map
recolorize_obj$pixel_assignments <- map
# and make the image
new_img <- constructImage(map,
recolorize_obj$centers)
# then, get new sizes (minus background)
recolorize_obj$sizes <- table(map)[-1]
# plot if we're plotting
if (plotting) {
# get boundaries of original pixels & make highlighted array
components <- layer_split[condition_met]
layer_px <- imager::as.pixset(imager::add(components) > 0)
px_bound <- imager::boundary(imager::grow(layer_px, 1))
old_img <- array_to_cimg(constructImage(old_map,
recolorize_obj$centers))
highlight_img <- imager::colorise(old_img,
px_bound, col = highlight_color)
highlight_img <- cimg_to_array(highlight_img)
# plot highlighted
graphics::layout(matrix(1:3, 1), widths = c(0.4, 0.4, 0.2))
plotImageArray(highlight_img, main = paste("selected components"))
plotImageArray(new_img, paste("result"))
plotColorPalette(recolorize_obj$centers,
recolorize_obj$sizes,
horiz = FALSE)
}
# get boundaries of original pixels & make highlighted array
components <- layer_split[condition_met]
layer_px <- imager::as.pixset(imager::add(components) > 0)
px_bound <- imager::boundary(imager::grow(layer_px, 1))
# get boundaries of original pixels & make highlighted array
components <- layer_split[condition_met]
layer_px <- imager::as.pixset(imager::add(components) > 0)
components
condition_met
devtools::load_all(".")
test <- absorbLayer(recolorize_obj, 1, size_condition = function(s) s <= 10)
devtools::load_all(".")
test <- absorbLayer(recolorize_obj, 1, size_condition = function(s) s <= 10)
length(condition_met == 0)
length(condition_met) == 0
devtools::load_all(".")
test <- absorbLayer(recolorize_obj, 1, size_condition = function(s) s <= 10)
test <- absorbLayer(recolorize_obj, 1, size_condition = function(s) s <= Inf)
length(condition_met) == 0
size_condition = function(s) s <= Inf
# get object layer
layer <- splitByColor(recolorize_obj, layers = layer_idx,
plot_method = "none")[[1]]
# convert to an imager pixset for splitting
px <- imager::as.pixset(imager::as.cimg(layer) > 0)
# split separate components
layer_split <- imager::split_connected(px)
# get component sizes
component_sizes <- unlist(lapply(layer_split, sum))
# find which components satisfy the size condition
condition_met <- which(ifelse(size_condition(component_sizes), TRUE, FALSE))
# location condition - bounding box
# get bounding box (in pixel coordinates) of each component:
component_bbox <- lapply(layer_split, function(l) apply(which(l[ , , 1, 1],
arr.ind = TRUE), 2,
range))
# convert to fraction of image dimensions:
imdim <- dim(recolorize_obj$original_img)[1:2]
norm_matrix <- matrix(imdim, nrow = 2, ncol = 2, byrow = TRUE)
component_bbox_norm <- lapply(component_bbox,
function(b) round(b / norm_matrix, 3))
# important - remember that imager rotates images 90 degrees (argh),
# so y-axis is rows and x-axis is columns
y_range <- 1 - y_range # also the y-axis is flipped
bbox_condition_met <- lapply(component_bbox_norm,
function(b) any(any(b[ , 1] >= y_range[2]) &
any(b[ , 1] <= y_range[1])) &
any(any(b[ , 2] >= x_range[1]) &
any(b[ , 2] <= x_range[2])))
condition_met <- intersect(condition_met,
which(unlist(bbox_condition_met)))
condition_met
# make a color center map from the pixel assignments (this will make sense in
# a bit)
old_map <- recolorize_obj$pixel_assignments
map <- imager::as.cimg(old_map)
plot(map)
# for every component that meets the size condition:
for (i in condition_met) {
# extract the component
component <- layer_split[[i]]
# get indices of immediately adjacent pixels
px_contour <- imager::boundary(imager::grow(component, 3))
# count which color patches those pixels are assigned to
border_cols <- table(map[px_contour])
# we don't want to turn these pixels transparent, so we'll ignore
# any borders with the background (patch 0):
if(names(border_cols)[1] == "0") {
border_cols <- border_cols[-1]
}
# get name of longest border
ctr_idx <- names(which(border_cols == max(border_cols)))
ctr_idx <- as.numeric(ctr_idx)
# if there is more than one color patch bordering it...
if (length(ctr_idx) > 1) {
# ...switch that component to the color of the patch
# with which it shares the longest border
majority_rule <- which(recolorize_obj$sizes[ctr_idx] ==
max(recolorize_obj$sizes[ctr_idx]))
ctr_idx <- ctr_idx[majority_rule]
}
# and change the indices
map[component] <- as.numeric(ctr_idx)
i <- i + 1
}
plot(map)
# switch the new patch map in
map <- cimg_to_array(map)
# if we completely eliminated a patch...
if (length(condition_met) == length(layer_split)) {
# change the higher indices to match new centers
if (layer_idx < nrow(recolorize_obj$centers)) {
map[map > layer_idx] <- map[map > layer_idx] - 1
}
# remove it from the color centers
recolorize_obj$centers <- recolorize_obj$centers[-layer_idx, ]
rownames(recolorize_obj$centers) <- 1:nrow(recolorize_obj$centers)
}
# switch in the new map
recolorize_obj$pixel_assignments <- map
# and make the image
new_img <- constructImage(map,
recolorize_obj$centers)
plotImageArray(new_img)
# then, get new sizes (minus background)
recolorize_obj$sizes <- table(map)[-1]
table(map)
# get boundaries of original pixels & make highlighted array
components <- layer_split[condition_met]
layer_px <- imager::as.pixset(imager::add(components) > 0)
px_bound <- imager::boundary(imager::grow(layer_px, 1))
old_img <- array_to_cimg(constructImage(old_map,
recolorize_obj$centers))
highlight_img <- imager::colorise(old_img,
px_bound, col = highlight_color)
highlight_img <- cimg_to_array(highlight_img)
# plot highlighted
graphics::layout(matrix(1:3, 1), widths = c(0.4, 0.4, 0.2))
plotImageArray(highlight_img, main = paste("selected components"))
old_img <- array_to_cimg(constructImage(old_map,
recolorize_obj$centers))
range(old_img)
hist(old_img)
hist(old_img)
devtools::load_all(".")
test <- absorbLayer(recolorize_obj, 1, size_condition = function(s) s <= Inf)
devtools::load_all(".")
test <- absorbLayer(recolorize_obj, 1, size_condition = function(s) s <= Inf)
recolorize_obj <- recolorize2(img, cutoff = 45)
rc <- absorbLayer(recolorize_obj, 1)
img
img <- system.file("extdata/corbetti.png", package = "recolorize")
recolorize_obj <- recolorize2(img, cutoff = 45)
# get layer
layer <- splitByColor(recolorize_obj,
layers = layer_idx,
plot_method = "none")[[1]]
layer_idx = 1
# get layer
layer <- splitByColor(recolorize_obj,
layers = layer_idx,
plot_method = "none")[[1]]
cimg_layer <- imager::as.cimg(layer)
# edit
new_layer <- apply_imager_operation(cimg_layer, operation, px_size)
operation = 'clean'
px_size = 2
# get layer
layer <- splitByColor(recolorize_obj,
layers = layer_idx,
plot_method = "none")[[1]]
cimg_layer <- imager::as.cimg(layer)
# edit
new_layer <- apply_imager_operation(cimg_layer, operation, px_size)
# set the original layer to background
original_idx <- which(recolorize_obj$pixel_assignments == layer_idx)
recolorize_obj$pixel_assignments[original_idx] <- 0
# set the new layer
array_layer <- cimg_to_array(new_layer)
recolorize_obj$pixel_assignments[which(array_layer > 0)] <- layer_idx
recolorize_obj$sizes[layer_idx] <- sum(array_layer)
# and reconstruct the image
recolorize_obj$recolored_img <- constructImage(recolorize_obj$pixel_assignments,
recolorize_obj$centers)
# for resetting
user_par <- graphics::par(no.readonly = TRUE)
graphics::layout(matrix(1:3, nrow = 1))
plotImageArray(layer, main = "original layer")
plotImageArray(array_layer, main = "edited layer")
plotImageArray(recolorize_obj$recolored_img,
main = "resulting color map")
# reset parameters
graphics::par(user_par)
layer_idx = "all"
operations = "clean"
px_sizes = 2
if (!is.numeric(layer_idx)) {
if (layer_idx == "all") {
layer_idx <- 1:nrow(recolorize_obj$centers)
} else {
stop("'layer_idx' must be either 'all' or a numeric
vector of layer indices to edit")
}
}
# make sure operations and px_sizes are the same length
if (length(layer_idx) != length(operations)) {
operations <- rep(operations, length.out = length(layer_idx))
}
if (length(layer_idx) != length(px_sizes)) {
px_sizes <- rep(px_sizes, length.out = length(layer_idx))
}
# for every layer...
for (i in 1:length(layer_idx)) {
# edit it accordingly
recolorize_obj <- editLayer(recolorize_obj,
layer_idx = layer_idx[i],
operation = operations[i],
px_size = px_sizes[i],
plotting = FALSE)
}
plot(recolorize_obj)
devtools::load_all(".")
?imDist
fulgidissima <- system.file("extdata/fulgidissima.png",
package = "recolorize")
fulgidissima_2bin <- recolorize(fulgidissima, "hist", bins = 2)
dist_2bin <- imDist(fulgidissima_2bin$original_img,
fulgidissima_2bin$recolored_img)
fulgidissima <- png::readPNG(fulgidissima)
fulgidissima_2bin <- recolorize(fulgidissima, "hist", bins = 2)
devtools::load_all(".")
?imDist
fulgidissima <- system.file("extdata/fulgidissima.png",
package = "recolorize")
# make an initial histogram fit
# this doesn't look great:
fulgidissima_2bin <- recolorize(fulgidissima, "hist", bins = 2)
# and we can see that everywhere but the head has pretty high residuals:
dist_2bin <- imDist(fulgidissima_2bin$original_img,
fulgidissima_2bin$recolored_img)
# using 3 bins/channel looks much better:
fulgidissima_3bin <- recolorize(fulgidissima, "hist", bins = 3)
# and we can see that on the heatmap:
dist_3bin <- imDist(fulgidissima_3bin$original_img,
fulgidissima_3bin$recolored_img)
# default behavior is to se the color range to the range of distances
# in a single matrix; to compare two different fits, we have to provide
# the same `zlim` scale for both
r <- range(c(dist_2bin, dist_3bin), na.rm = TRUE)
# now we can plot them to compare the fits:
layout(matrix(1:2, nrow = 1))
imHeatmap(dist_2bin, range = r)
imHeatmap(dist_3bin, range = r)
# we can also use other color spaces:
rgb_3bin <- imDist(fulgidissima_3bin$original_img,
fulgidissima_3bin$recolored_img,
color_space = "sRGB")
# looks oddly worse, but to keep things in perspective,
# you can set the range to the maximum color distance in RGB space:
imHeatmap(rgb_3bin, range = c(0, sqrt(3)))
# not useful for troubleshooting, but broadly reassuring!
fulgidissima <- system.file("extdata/fulgidissima.png",
package = "recolorize")
# make an initial histogram fit
# this doesn't look great:
fulgidissima_2bin <- recolorize(fulgidissima, "hist", bins = 2)
?imDist
fulgidissima <- system.file("extdata/fulgidissima.png",
package = "recolorize")
fulgidissima <- png::readPNG(fulgidissima)
# make an initial histogram fit
# this doesn't look great:
fulgidissima_2bin <- recolorize(fulgidissima, "hist", bins = 2)
# we can compare with the original image by creating the recolored
# image from the colormap
recolored_2bin <- constructImage(fulgidissima_2bin$pixel_assignments,
fulgidissima_2bin$centers)
dist_2bin <- imDist(im1 = fulgidissima,
im2 = recolored_2bin)
# using 3 bins/channel looks much better:
fulgidissima_3bin <- recolorize(fulgidissima, "hist", bins = 3)
# and we can see that on the heatmap:
recolored_3bin <- constructImage(fulgidissima_3bin$pixel_assignments,
fulgidissima_3bin$centers)
dist_3bin <- imDist(im1 = fulgidissima,
im2 = recolored_3bin)
# default behavior is to set the color range to the range of distances
# in a single matrix; to compare two different fits, we have to provide
# the same `zlim` scale for both
r <- range(c(dist_2bin, dist_3bin), na.rm = TRUE)
# now we can plot them to compare the fits:
layout(matrix(1:2, nrow = 1))
imHeatmap(dist_2bin, range = r)
imHeatmap(dist_3bin, range = r)
# we can also use other color spaces:
rgb_3bin <- imDist(fulgidissima,
recolored_3bin,
color_space = "sRGB")
# looks oddly worse, but to keep things in perspective,
# you can set the range to the maximum color distance in RGB space:
imHeatmap(rgb_3bin, range = c(0, sqrt(3)))
chongi <- png::readPNG(chongi)
chongi <- system.file("extdata/chongi.png", package = "recolorize")
chongi <- png::readPNG(chongi)
chongi_k <- recolorize(chongi, "k", n = 5)
recolored_chongi <- constructImage(chongi_k$pixel_assignments, chongi_k$centers)
?imHeatmap
chongi <- system.file("extdata/chongi.png", package = "recolorize")
chongi <- png::readPNG(chongi)
chongi_k <- recolorize(chongi, "k", n = 5)
recolored_chongi <- constructImage(chongi_k$pixel_assignments,
chongi_k$centers)
d <- imDist(chongi,
recolored_chongi, plotting = FALSE)
# original flavor
imHeatmap(d)
# bit offputting
imHeatmap(d, palette = colorRamps::ygobb(100))
# just dreadful
imHeatmap(d, palette = colorRamps::primary.colors(100))
devtools::load_all(".")
?mergeLayers
# image path:
img <- system.file("extdata/corbetti.png", package = "recolorize")
# initial fit, 8 bins:
init_fit <- recolorize(img)
# redundant green, red, and blue clusters
# to make it easier to see, we can plot the numbered palette:
layout(matrix(1:2, nrow = 1))
plotImageArray(init_fit$recolored_img)
plotColorPalette(init_fit$centers, horiz = FALSE)
# based on visual inspection, we should merge:
mlist <- list(c(3, 5),
c(4, 7),
c(6, 8))
# we can merge with that list, leaving layers 1 & 2 intact:
vis_merge <- mergeLayers(init_fit,
merge_list = mlist)
# we can include layers 1 & 2 as their own list elements,
# leaving them intact (result is identical to above):
mlist2 <- list(1, 2,
c(3, 5),
c(4, 7),
c(6, 8))
redundant_merge <- mergeLayers(init_fit,
merge_list = mlist2)
# we can also swap layer order this way without actually merging layers:
swap_list <- list(2, 5, 3, 4, 1)
swap_layers <- mergeLayers(redundant_merge,
merge_list = swap_list)
# merging everything but the first layer into a single layer,
# and making that merged layer orange (result looks
# a bit like a milkweed bug):
milkweed_impostor <- mergeLayers(init_fit,
merge_list = list(c(2:8)),
color_to = "orange")
# we can also shuffle all the layer colors while
# leaving their geometry intact:
centers <- vis_merge$centers
centers <- centers[sample(1:nrow(centers), nrow(centers)), ]
shuffle_layers <- mergeLayers(vis_merge,
merge_list = as.list(1:5),
color_to = centers)
# (this is not really the intended purpose of this function)
# image path:
img <- system.file("extdata/corbetti.png", package = "recolorize")
# initial fit, 8 bins:
init_fit <- recolorize(img)
# redundant green, red, and blue clusters
# to make it easier to see, we can plot the numbered palette:
layout(matrix(1:2, nrow = 1))
plotImageArray(init_fit$recolored_img)
plotColorPalette(init_fit$centers, horiz = FALSE)
# based on visual inspection, we should merge:
mlist <- list(c(3, 5),
c(4, 7),
c(6, 8))
# we can merge with that list, leaving layers 1 & 2 intact:
vis_merge <- mergeLayers(init_fit,
merge_list = mlist)
# we can include layers 1 & 2 as their own list elements,
# leaving them intact (result is identical to above):
mlist2 <- list(1, 2,
c(3, 5),
c(4, 7),
c(6, 8))
redundant_merge <- mergeLayers(init_fit,
merge_list = mlist2)
# we can also swap layer order this way without actually merging layers:
swap_list <- list(2, 5, 3, 4, 1)
swap_layers <- mergeLayers(redundant_merge,
merge_list = swap_list)
# merging everything but the first layer into a single layer,
# and making that merged layer orange (result looks
# a bit like a milkweed bug):
milkweed_impostor <- mergeLayers(init_fit,
merge_list = list(c(2:8)),
color_to = "orange")
# we can also shuffle all the layer colors while
# leaving their geometry intact:
centers <- vis_merge$centers
centers <- centers[sample(1:nrow(centers), nrow(centers)), ]
shuffle_layers <- mergeLayers(vis_merge,
merge_list = as.list(1:5),
color_to = centers)
# (this is not really the intended purpose of this function)
plot(init_fit)
devtools::load_all(".")
?mergeLayers
# image path:
img <- system.file("extdata/corbetti.png", package = "recolorize")
# initial fit, 8 bins:
init_fit <- recolorize(img)
# redundant green, red, and blue clusters
# to make it easier to see, we can plot the numbered palette:
plot(init_fit)
# based on visual inspection, we should merge:
mlist <- list(c(3, 5),
c(4, 7),
c(6, 8))
# we can merge with that list, leaving layers 1 & 2 intact:
vis_merge <- mergeLayers(init_fit,
merge_list = mlist)
devtools::load_all(".")
# we can merge with that list, leaving layers 1 & 2 intact:
vis_merge <- mergeLayers(init_fit,
merge_list = mlist)
