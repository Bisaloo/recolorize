layout(matrix(1:5, nrow = 1))
for (i in 1:5) {
if (i == 1) {kmeans.repeat <- vector("list", 5)}
kmeans.repeat[[i]] <- recolorize(images[5], n = 4,color_space = "sRGB",
method = "kmeans",
plotting = FALSE)
plotImageArray(kmeans.repeat[[i]]$recolored_img,
main = paste0("Iteration ", i))
}
# you get different clusters each time you run kmeans:
layout(matrix(1:5, nrow = 1))
for (i in 1:5) {
if (i == 1) {kmeans.repeat <- vector("list", 5)}
kmeans.repeat[[i]] <- recolorize(images[1], n = 4,color_space = "sRGB",
method = "kmeans",
plotting = FALSE)
plotImageArray(kmeans.repeat[[i]]$recolored_img,
main = paste0("Iteration ", i))
}
# you get different clusters each time you run kmeans:
layout(matrix(1:5, nrow = 1))
for (i in 1:5) {
if (i == 1) {kmeans.repeat <- vector("list", 5)}
kmeans.repeat[[i]] <- recolorize(images[2], n = 4,
color_space = "sRGB",
method = "kmeans",
plotting = FALSE)
plotImageArray(kmeans.repeat[[i]]$recolored_img,
main = paste0("Iteration ", i))
}
# you get different clusters each time you run kmeans:
layout(matrix(1:5, nrow = 1))
for (i in 1:5) {
if (i == 1) {kmeans.repeat <- vector("list", 5)}
kmeans.repeat[[i]] <- recolorize(images[3], n = 4,
color_space = "sRGB",
method = "kmeans",
plotting = FALSE)
plotImageArray(kmeans.repeat[[i]]$recolored_img,
main = paste0("Iteration ", i))
}
# you get different clusters each time you run kmeans:
layout(matrix(1:5, nrow = 1))
for (i in 1:5) {
if (i == 1) {kmeans.repeat <- vector("list", 5)}
kmeans.repeat[[i]] <- recolorize(images[4], n = 4,
color_space = "sRGB",
method = "kmeans",
plotting = FALSE)
plotImageArray(kmeans.repeat[[i]]$recolored_img,
main = paste0("Iteration ", i))
}
# compare binning vs. kmeans
for (i in 1:length(images)) {
# kmeans recolor
kmeans.recolor <- recolorize(images[i], method = "kmeans",
n = 8, plotting = FALSE)
# hist recolor
hist.recolor <- recolorize(images[i], method = "hist",
bins = 2, plotting = FALSE)
# plot all three side by side
layout(matrix(c(1:3), ncol = 3))
plotImageArray(kmeans.recolor$original.img, main = "original")
plotImageArray(kmeans.recolor$recolored.img, main = "kmeans")
plotImageArray(hist.recolor$recolored.img, main = "binning")
# pausing
invisible(readline(prompt = "Press [enter] to continue or [esc] to exit"))
}
# compare binning vs. kmeans
for (i in 1:length(images)) {
# kmeans recolor
kmeans.recolor <- recolorize(images[i], method = "kmeans",
n = 8, plotting = FALSE)
# hist recolor
hist.recolor <- recolorize(images[i], method = "hist",
bins = 2, plotting = FALSE)
# plot all three side by side
layout(matrix(c(1:3), ncol = 3))
plotImageArray(kmeans.recolor$original_img, main = "original")
plotImageArray(kmeans.recolor$recolored_img, main = "kmeans")
plotImageArray(hist.recolor$recolored_img, main = "binning")
# pausing
invisible(readline(prompt = "Press [enter] to continue or [esc] to exit"))
}
# imposeColors: you can map an image to custom colors ####
# RGB extremes (white, black, red, green, blue, yellow, magenta, cyan)
ctrs <- matrix(c(1, 1, 1,
0, 0, 0,
1, 0, 0,
0, 1, 0,
0, 0, 1,
1, 1, 0,
1, 0, 1,
0, 1, 1), byrow = TRUE, ncol = 3)
# yuck (but you get the point):
sapply(1:5, function(i) imposeColors(images[i], ctrs,
adjust.centers = FALSE))
# yuck (but you get the point):
sapply(1:5, function(i) imposeColors(images[i], ctrs,
adjust_centers = FALSE))
# it looks nicer if you let the centers adjust to average
# colors after pixels are assigned:
imposeColors(images[5], ctrs, adjust.centers = TRUE)
# it looks nicer if you let the centers adjust to average
# colors after pixels are assigned:
imposeColors(images[5], ctrs, adjust_centers = TRUE)
# it looks nicer if you let the centers adjust to average
# colors after pixels are assigned:
imposeColors(images[5],
ctrs, color_space = "sRGB",
adjust_centers = TRUE)
# it looks nicer if you let the centers adjust to average
# colors after pixels are assigned:
imposeColors(images[5],
ctrs, color_space = "Lab",
adjust_centers = TRUE)
# it looks nicer if you let the centers adjust to average
# colors after pixels are assigned:
imposeColors(images[5],
ctrs, color_space = "Luv",
adjust_centers = TRUE)
# but...you can take colors from one image:
ocellata.colors <- recolorize(images[5], method = "kmeans", n = 10)
# and map them to another:
ephippigera_to_ocellata <- imposeColors(images[3],
ocellata.colors$centers,
adjust.centers = FALSE)
# and map them to another:
ephippigera_to_ocellata <- imposeColors(images[3],
ocellata.colors$centers,
adjust_centers = FALSE)
# this one doesn't look so good (big surprise)
corbetti_to_ocellata <- imposeColors(images[2],
ocellata.colors$centers,
adjust.centers = FALSE)
# this one doesn't look so good (big surprise)
corbetti_to_ocellata <- imposeColors(images[2],
ocellata.colors$centers,
adjust_centers = FALSE)
# try it out with heliconius:
# install.packages("colordistance")
heliconius <- dir(system.file("extdata", package = "colordistance"),
pattern = "Heliconius",
recursive = TRUE, full.names = TRUE)
# plot them to see what we're working with:
layout(matrix(c(1:8), nrow = 2, byrow = TRUE))
sapply(heliconius, function(i) plotImageArray(readImage(i),
main = basename(i)))
# get one set of colors...
# (notice we have to mask the white background)
heliconius.colors <- recolorize(heliconius[7],
lower = rep(0.9, 3), upper = rep(1, 3),
method = "kmeans", n = 3)
# map all the other images to those colors
for (i in 1:length(heliconius)) {
imposeColors(heliconius[i], heliconius.colors$centers,
adjust.centers = FALSE,
lower = rep(0.9, 3), upper = rep(1, 3))
} # not bad!
# map all the other images to those colors
for (i in 1:length(heliconius)) {
imposeColors(heliconius[i], heliconius.colors$centers,
adjust_centers = FALSE,
lower = rep(0.9, 3), upper = rep(1, 3))
} # not bad!
# recluster: correct over-clustering ####
chongi <- system.file("extdata/chongi.png", package = "recolorize")
# using 3 bins/channel splits uniform regions (e.g. the navy):
recolored_chongi <- recolorize(chongi, bins = 2,
color_space = "sRGB")
# using 3 bins/channel splits uniform regions (e.g. the navy):
recolored_chongi <- recolorize(chongi, bins = 2,
color_space = "Lab")
# using 3 bins/channel splits uniform regions (e.g. the navy):
recolored_chongi <- recolorize(chongi, bins = 2,
color_space = "sRGB")
# we can group together the most similar clusters:
reclustered_chongi <- recluster(recolored_chongi,
similarity_cutoff = 40,
color.space.fit = "sRGB",
plot_hclust = TRUE)
# we can group together the most similar clusters:
reclustered_chongi <- recluster(recolored_chongi,
similarity_cutoff = 40,
color_space_fit = "sRGB",
plot_hclust = TRUE)
# we can also specify our final number of colors, as with kmeans:
recluster_chongi <- recluster(recolored_chongi,
n_final = 6,
plot_hclust = TRUE)
# compare with actual kmeans with n = 6; the navy is usually split into 2-3
# colors, and we get different results every time (!):
kmeans_chongi <- recolorize(chongi, "k", n = 6)
kmeans_chongi <- recolorize(chongi, "k", n = 6)
kmeans_chongi <- recolorize(chongi, "k", n = 6)
# you can also recluster a kmeans fit, which is nice
# the cutoff typically has to be lower and you do still have the issue of
# different results every time, but the recluster fit tends to be stable
kmeans_chongi <- recolorize(chongi, "k", n = 20)
kmeans_recluster <- recluster(kmeans_chongi, similarity_cutoff = 45)
# note the 'residuals' option (also now in imposeColors and recolorize):
kmeans_chongi <- recolorize(chongi, "k", n = 20, resid = TRUE)
kmeans_recluster <- recluster(kmeans_chongi,
resid = TRUE,
similarity_cutoff = 45)
# note the 'residuals' option (also now in imposeColors and recolorize):
kmeans_chongi <- recolorize(chongi, "k", n = 20, resid = TRUE)
boa <- read.csv("~/Dropbox/projects/john_boas/boa_rotations.csv")
head(boa)
library(tidyverse)
colnames(boa)
pivot_longer(boa, c(13:15), names_to = "rotation")
test <- pivot_longer(boa, c(13:15), names_to = "rotation")
head(test)
test$value
test$rotation
test <- pivot_longer(boa, c(13:15), names_to = "axis", values_to = "rotation")
colnames(test)
ggplot(test, aes(x = axis, y = rotation)) +
geom_boxplot(aes(color = axis)) +
facet_wrap(~individual*posture*behavior)
ggplot(test, aes(x = axis, y = rotation)) +
geom_boxplot(aes(color = axis)) +
facet_wrap(~individual*location*behavior)
ggplot(test, aes(x = axis, y = rotation)) +
geom_boxplot(aes(color = axis)) +
facet_wrap(~individual*location*behavior) + theme_bw(base_size = 9)
ggplot(test, aes(x = axis, y = rotation)) +
geom_boxplot(aes(color = axis)) +
facet_wrap(~individual*location*behavior) + theme_classic(base_size = 9)
ggplot(test, aes(x = axis, y = rotation)) +
geom_boxplot(aes(color = axis)) +
facet_wrap(~individual*location*behavior) + theme_minimal(base_size = 9)
ggplot(test, aes(x = axis, y = rotation)) +
geom_boxplot(aes(color = axis)) +
facet_wrap(~individual*location*behavior) + theme_bw(base_size = 9)
ggplot(test, aes(x = axis, y = rotation)) +
geom_boxplot(aes(color = axis)) +
facet_wrap(~individual*behavior*location)
ggplot(test, aes(x = axis, y = rotation)) +
geom_boxplot(aes(color = axis)) +
facet_wrap(~individual*behavior*location) +
theme_bw(base_size = 10)
length(unique(test$trial))
test$trial
test$filename
length(test$filename)
length(unique(test$filename))
3*2*2
ggplot(test, aes(x = axis, y = rotation)) +
geom_boxplot(aes(color = axis)) +
facet_wrap(~individual*behavior*location) +
theme_bw(base_size = 10)
ggplot(test, aes(x = axis, y = rotation)) +
geom_boxplot(aes(color = axis)) +
facet_wrap(~individual*location*behavior) +
theme_bw(base_size = 10)
?recluster
corbetti <- system.file("extdata/corbetti.png", package = "recolorize")
recolored_corbetti <- recolorize(corbetti, bins = 3)
library(recolorize)
devtools::load_all(".")
recolored_corbetti <- recolorize(corbetti, bins = 3)
recluster_obj <- recluster(recolored_corbetti,
similarity_cutoff = 60,
plot_hclust = TRUE)
recluster_obj <- recluster(recolored_corbetti,
similarity_cutoff = 50,
plot_hclust = TRUE)
recolorize_obj <- recolored_corbetti
# rename, to keep things clear
init_fit <- recolorize_obj
# first, ignore empty clusters -- they're not informative
sizes <- init_fit$sizes
centers <- init_fit$centers
# if any are empty, remove them
if (any(sizes == 0)) {
zero_idx <- which(sizes == 0)
sizes <- sizes[-zero_idx]
centers <- init_fit$centers[-zero_idx, ]
}
# convert to Lab space for better clustering
lab_init <- grDevices::convertColor(centers,
from = "sRGB",
to = color_space,
to.ref.white = ref_white)
color_space = "Lab"
ref_white = "D65"
# convert to Lab space for better clustering
lab_init <- grDevices::convertColor(centers,
from = "sRGB",
to = color_space,
to.ref.white = ref_white)
# get distance matrix
d <- stats::dist(lab_init)
# perform clustering
# hc <- hclust(d / max(d))
hc <- stats::hclust(d)
plot(hc, xlab = "")
similarity_cutoff = 60
graphics::abline(h = similarity_cutoff, lty = 2, col = "red")
# form groups
clust_groups <- stats::cutree(hc, k = n_final,
h = similarity_cutoff)
n_final = NULL
# form groups
clust_groups <- stats::cutree(hc, k = n_final,
h = similarity_cutoff)
merge_list <- lapply(unique(clust_groups),
function(i) which(clust_groups == i))
merge_list
i
i = 1
centers[merge_list[i], ]
centers[merge_list[[i]], ]
temp_colors <- centers[merge_list[[i]], ]
apply(temp_colors, 2, weighted.mean(w = sizes[merge_list[[i]]]))
apply(temp_colors, 2, function(j)
weighted.mean(j, w = sizes[merge_list[[i]]]))
recluster_obj
recluster_obj$centers
recolored_corbetti <- recolorize(corbetti, bins = 5)
recluster_obj <- recluster(recolored_corbetti,
similarity_cutoff = 60,
plot_hclust = TRUE)
recluster_obj <- recluster(recolored_corbetti,
similarity_cutoff = 70,
plot_hclust = TRUE)
# with imposeColors:
for (i in 1:length(merge_list)) {
temp_colors <- centers[merge_list[[i]], ]
new_color <- apply(temp_colors, 2, function(j)
weighted.mean(j, w = sizes[merge_list[[i]]]))
if (i == 1) {
new_centers <- new_color
colnames(new_centers) <- c("R", "G", "B")
} else {
new_centers <- rbind(new_centers, new_color)
}
}
new_centers <- data.frame(R = new_color[1],
G = new_color[2]
B = new_color[3])
new_centers <- data.frame(R = new_color[1],
G = new_color[2],
B = new_color[3])
new_centers
# with imposeColors:
for (i in 1:length(merge_list)) {
temp_colors <- centers[merge_list[[i]], ]
new_color <- apply(temp_colors, 2, function(j)
weighted.mean(j, w = sizes[merge_list[[i]]]))
if (i == 1) {
new_centers <- data.frame(R = new_color[1],
G = new_color[2],
B = new_color[3])
} else {
new_centers <- rbind(new_centers, new_color)
}
}
new_centers
# and merge those layers:
# final_fit <- recolorize::mergeLayers(init_fit,
#                                      merge_list = merge_list,
#                                      plotting = FALSE)
final_fit <- imposeColors(init_fit$original_img,
centers = new_centers,
plotting = FALSE)
devtools::load_all(".")
# get an image
corbetti <- system.file("extdata/corbetti.png", package = "recolorize")
# too many color centers
recolored_corbetti <- recolorize(corbetti, bins = 3)
# just enough!
# check previous plot for clustering cutoff
recluster_obj <- recluster(recolored_corbetti,
similarity_cutoff = 60,
plot_hclust = TRUE)
# compare to the result using k-means clustering and the same n:
kmeans_fit <- recolorize(corbetti, "k", n = 6)
# (you also get different clusters every time you run this)
# a cutoff that's too severe will usually just produce "light",
# "dark", and "other" colors:
recluster_obj <- recluster(recolored_corbetti,
similarity_cutoff = 100,
plot_hclust = TRUE)
devtools::load_all(".")
recluster_obj <- recluster(recolored_corbetti,
similarity_cutoff = 60,
plot_hclust = TRUE, refit_method = "impose")
recluster_obj <- recluster(recolored_corbetti,
similarity_cutoff = 60,
plot_hclust = TRUE, refit_method = "merge")
?recluster
# get an image
corbetti <- system.file("extdata/corbetti.png", package = "recolorize")
# too many color centers
recolored_corbetti <- recolorize(corbetti, bins = 3)
# just enough!
# check previous plot for clustering cutoff
recluster_obj <- recluster(recolored_corbetti,
similarity_cutoff = 60,
plot_hclust = TRUE,
refit_method = "impose")
# compare to merging layers - quite different results:
recluster_merge <- recluster(recolored_corbetti,
similarity_cutoff = 60,
plot_hclust = TRUE,
refit_method = "merge")
devtools::load_all(".")
# get an image
corbetti <- system.file("extdata/corbetti.png", package = "recolorize")
# too many color centers
recolored_corbetti <- recolorize(corbetti, bins = 3)
# just enough!
# check previous plot for clustering cutoff
recluster_obj <- recluster(recolored_corbetti,
similarity_cutoff = 60,
plot_hclust = TRUE,
refit_method = "impose")
# compare to merging layers - quite different results:
recluster_merge <- recluster(recolored_corbetti,
similarity_cutoff = 60,
plot_hclust = TRUE,
refit_method = "merge")
# compare to the result using k-means clustering and the same n:
kmeans_fit <- recolorize(corbetti, "k", n = 6)
# (you also get different clusters every time you run this)
# a cutoff that's too severe will usually just produce "light",
# "dark", and "other" colors:
recluster_obj <- recluster(recolored_corbetti,
similarity_cutoff = 100,
plot_hclust = TRUE)
?wernerColor
# get an initial fit:
corbetti <- system.file("extdata/corbetti.png", package = "recolorize")
recolored_corbetti <- recolorize(corbetti, plotting = FALSE)
# recolor original image
corbetti_werner <- wernerColor(recolored_corbetti,
which_img = "original",
n_colors = 6)
# get an initial fit:
corbetti <- system.file("extdata/corbetti.png", package = "recolorize")
recolored_corbetti <- recolorize(corbetti, plotting = FALSE)
# recolor original image
corbetti_werner <- wernerColor(recolored_corbetti,
which_img = "original",
n_colors = 6)
# we can simplify the colors and then do it again:
corbetti_recluster <- recluster(recolored_corbetti,
similarity_cutoff = 45,
plot_hclust = FALSE)
recolorize_obj <- recolored_corbetti
# rename, to keep things clear
init_fit <- recolorize_obj
# first, ignore empty clusters -- they're not informative
sizes <- init_fit$sizes
centers <- init_fit$centers
# if any are empty, remove them
if (any(sizes == 0)) {
zero_idx <- which(sizes == 0)
sizes <- sizes[-zero_idx]
centers <- init_fit$centers[-zero_idx, ]
}
# convert to Lab space for better clustering
lab_init <- grDevices::convertColor(centers,
from = "sRGB",
to = color_space,
to.ref.white = ref_white)
color_space = "Lab"
ref_white = "D65"
# convert to Lab space for better clustering
lab_init <- grDevices::convertColor(centers,
from = "sRGB",
to = color_space,
to.ref.white = ref_white)
# get distance matrix
d <- stats::dist(lab_init)
# perform clustering
# hc <- hclust(d / max(d))
hc <- stats::hclust(d)
plot(hc, xlab = "")
similarity_cutoff = 45
graphics::abline(h = similarity_cutoff, lty = 2, col = "red")
# form groups
clust_groups <- stats::cutree(hc, k = n_final,
h = similarity_cutoff)
merge_list <- lapply(unique(clust_groups),
function(i) which(clust_groups == i))
n_final = NULL
merge_list <- lapply(unique(clust_groups),
function(i) which(clust_groups == i))
# form groups
clust_groups <- stats::cutree(hc, k = n_final,
h = similarity_cutoff)
merge_list <- lapply(unique(clust_groups),
function(i) which(clust_groups == i))
merge_list
i = 1
temp_colors <- centers[merge_list[[i]], ]
temp_colors
nrow(temp_colors)
devtools::load_all(".")
# we can simplify the colors and then do it again:
corbetti_recluster <- recluster(recolored_corbetti,
similarity_cutoff = 45,
plot_hclust = FALSE)
corbetti_werner <- wernerColor(corbetti_recluster,
which_img = "recolored")
images <- dir("~/Dropbox/beetles/Images/transparent/",
".png", full.names = TRUE)
images
