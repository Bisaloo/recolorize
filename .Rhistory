layout(matrix(1:8, nrow = 2))
for (i in k_vec) {
kmeans_fit <- recolorize(corbetti, "k", n = i, plotting = FALSE)
plotColorClusters(centers = kmeans_fit$centers,
sizes = kmeans_fit$sizes, scaling = 10,
tick.marks = F,
xlab = "", ylab = "", zlab = "",
main = paste("n =", i),
mar = c(2, 1, 2, 1),
xlim = 0:1, ylim = 0:1, zlim = 0:1)
}
```
But the main issue with this method is that it's implemented heuristically, which means you're not guaranteed to get the same results every time you run it; and although you should get similar ones, you'll also get the color centers returned to you in a random order. We can see this by running the exact same k-means clustering code 3 times:
```{r, fig.width = 6, fig.height = 4}
kmeans_1 <- recolorize(corbetti, method = "k", n = 8, plotting = FALSE)
kmeans_2 <- recolorize(corbetti, method = "k", n = 8, plotting = FALSE)
kmeans_3 <- recolorize(corbetti, method = "k", n = 8, plotting = FALSE)
layout(matrix(1:6, nrow = 1), widths = c(rep(.25, 3),
rep(.25/3, 3)))
for (i in list(kmeans_1, kmeans_2, kmeans_3)) {
par(mar = rep(0, 4))
plotImageArray(i$recolored_img)
}
for (i in list(kmeans_1, kmeans_2, kmeans_3)) {
par(mar = rep(0, 4))
plotColorPalette(i$centers, i$sizes, horiz = FALSE)
}
```
The differences in the color maps are subtle (but noticeable), but notice especially the order of the colors in the color palettes on the right. More or less the same color centers pop up, but their index values don't match. If you run this code one day and pull out all the red clusters by their index, or merge the multiple green clusters, those values will change the next time you run the code. That and the need to specify cluster numbers for each image are more or less why I recommend not using this method unless you have a reason.
#### Color spaces
There is a lot to be said about color spaces, and most of it is complicated and requires a hefty dose of math. Check out [this vignette](https://cran.r-project.org/web/packages/colordistance/vignettes/color-spaces.html) for a quick overview of why they matter for color clustering. I'll go ahead and quote myself here:
> A mathematically defined color space maps perceived colors onto a system of coordinates. Because human beings have trichromatic color vision (cone cells that have peak sensitivities at red, green, and blue wavelengths), most color spaces are three-dimensional. The most familiar of these is probably RGB, or red-green-blue, the tri-channel system that most computers use to store and display color images; other common ones include HSV (hue, saturation, and value) and CMYK (cyan, magenta, yellow, and key).
>
> No color space is a perfect representation of color, and most of the existing ones are tuned specifically for standard human color vision. Different color spaces are usually designed to address some issues more than others. For example, RGB provides a computationally tractable storage format for images and is a decent representation of human color vision; this comes at the cost of displaying a smaller range of colors than human eyes can perceive. Color spaces that attempt to more closely mimic human color perception require additional information about lighting in a scene, and are shaped irregularly.
For our purposes, that means that the color space you choose to do your clustering in can have profound effects on your results, because it determines the Euclidean distances between different colors. For example, in RGB space, red and yellow are as far apart from each other as red and black, but black and yellow are farther apart than black and red are. That doesn't really line up with our perception, but it's how the color space is arranged. CIE Lab color space is specifically designed to mimic human color perception (so the Euclidean distances reflect perceived distances), but it's also a weird blob shape, so we usually need more initial partitions to separate out the colors. We can try out different color spaces:
```{r, fig.width = 6, fig.height = 2.5}
rgb_fit <- recolorize(corbetti, color_space = "sRGB", plotting = FALSE)
lab_fit <- recolorize(corbetti, color_space = "Lab", plotting = FALSE)
layout(matrix(1:4, nrow = 1), widths = c(.4, .1, .4, .1))
plotImageArray(rgb_fit$recolored_img, "RGB space")
plotColorPalette(rgb_fit$centers, rgb_fit$sizes)
plotImageArray(lab_fit$recolored_img, "CIE Lab space")
plotColorPalette(lab_fit$centers, lab_fit$sizes)
```
You may notice that for all I talked it up, the CIE Lab space option looks terrible. That's because unlike RGB space, CIE Lab colors aren't evenly distributed across a cube, so most of the different colors are in the center of the range. 2 bins per channel doesn't do a great job with splitting that up. We get much better results if we allow for more than 2 bins per channel:
```{r}
lab_fit_3 <- recolorize(corbetti, bins = 4, color_space = "Lab")
```
That said, I usually find myself using RGB space for the initial clustering step, and CIE Lab space for refining those results. One thing to note is that regardless of which color space you use for clustering, the `centers` matrix is *always in RGB color space*. That's because it's used for plotting.
I don't have much general guidance for how to choose between all of these parameters at this stage; I would recommend using histogram binning in RGB space, with as many bins as needed to separate out all of the different colors. But part of the reason I'm including more options than that is because it really does depend on the color distribution in your images. This *Chrysochroa corbetti* image, for example, is literally red, green, and blue; that makes RGB space pretty appropriate for a first pass!
It's convenient to use the same scheme for every image in your dataset, so you might end up using whatever values are needed for your most complex image and over-splitting most of your other images. That's usually fine, because the next set of steps will try to lump colors together or remove minor details. You want to be just granular enough to capture the details you care about, and it's okay if some colors are split up.
# Refining fits automatically and semi-automatically
# Overview of package functions
1. Functions that do the initial clustering (i.e. take a raw image).
2. Functions that automatically edit the initial clustering (i.e. refine an initial fit).
3. Functions that allow users to make manual-ish changes.
4. Functions to export to other packages.
# Worked example on a single image
corbetti! Go from initial problem
1. hey, 5 clusters? uhhh, 6? wait, why does this give me a different answer every time
2. too many clusters, but it looks good
3. refinement options: drop small clusters, recluster based on similarity, imposing colors
4. DIY options: manual layer editing, smushing clusters together
5. export options: well, you can save the image or export a single layer
as a bitmap, etc
# Worked example on a more complicated image
That shiny bastard, *Chrysochroa fulgidissima*
# Worked example on a batch of images
Just our Five Guys.
# Some considerations
### How do I choose a procedure?
Most things will more or less work; if it looks reasonable, it is.
Keep in mind that there is a big difference between getting slightly different color maps and getting qualitatively different results. Keep your final goal in mind. You can also try lots of different things and see if it makes a real difference. etc.
### How much does the color space matter?
Dude: a lot!
### What if my parameters work well for some images, but not others?
It does what it does, man. You can get way fancier with cutoffs than
I have here. This package is built on some pretty simple scaffolding:
you get a starting set of clusters, then you modify them. If you have a
better/more refined way of deciding which colors to cluster, then go
for it.
```{r, echo=FALSE,message=FALSE, fig.width=7, fig.height = 3.5, fig.cap="Pixels from the above image in RGB color space, viewed from two angles."}
library(colordistance)
layout(matrix(1:2, nrow = 1))
plotPixels(images[2], angle = 30, main = "", cex.lab = 0.5, cex.axis = 0.5)
plotPixels(images[2], angle = -30, main = "", cex.lab = 0.5, cex.axis = 0.5)
```
There's certainly a blob of green pixels in there, but they're not all the exact same color. In order to extract all the green pixels, we either have to specify a range of colors that we'll call 'green', or open up the original image in a image editing software like ImageJ or Photoshop and manually select the green region. You can probably see how this would start to get out of hand as you increase the number of images or the diversity of colors in a dataset, because we have to introduce more and more subjectivity, and most images will not have such clear boundaries between color patches.
This is pretty convenient and relatively lightweight. It also means we can swap the colors to whatever we like.
```{r, fig.width = 6, fig.height = 2.5}
rgb_fit <- recolorize(corbetti, color_space = "sRGB", plotting = FALSE)
lab_fit <- recolorize(corbetti, color_space = "Lab", plotting = FALSE)
layout(matrix(1:4, nrow = 1), widths = c(.4, .1, .4, .1))
par(mar = c(0, 2, 0, 0))
plotImageArray(rgb_fit$recolored_img, "RGB space")
plotColorPalette(rgb_fit$centers, rgb_fit$sizes)
plotImageArray(lab_fit$recolored_img, "CIE Lab space")
# bookkeeping
library(recolorize)
images <- dir(system.file("extdata/", package = "recolorize"), "png", full.names = TRUE)
img <- readImage(images[2])
# get fit
init_fit <- recolorize(img, plotting = FALSE)
re_fit <- recluster(init_fit, similarity_cutoff = 45, plot_final = FALSE)
re_fit <- recluster(init_fit, similarity_cutoff = 45, plot_final = FALSE)
# plot it
layout(matrix(1:3, nrow = 1), widths = c(0.45, 0.1, 0.45))
# plot it
layout(matrix(1:3, nrow = 1), widths = c(0.45, 0.1, 0.45))
par(mar = c(0, 0, 2, 0))
plotImageArray(re_fit$original_img, main = "Original")
plotColorPalette(re_fit$centers, re_fit$sizes, horiz = FALSE)
plotImageArray(re_fit$recolored_img, main = "Color map")
```{r, eval=F}
# get the path to the image (comes with the package, so we use system.file):
img <- system.file("extdata/corbetti.png", package = "recolorize")
# perform initial clustering:
init_fit <- recolorize(img)
# and refine:
re_fit <- recluster(init_fit, similarity_cutoff = 45)
layout(matrix(1:5, nrow = 1))
layers <- splitByColor(re_fit)
# define image path - we're using an image that comes with the package
img_path <- system.file("extdata/corbetti.png", package = "recolorize")
# load image
img <- readImage(img_path)
# it's just an array with 4 channels:
dim(img)
layout(matrix(1:5, nrow = 1))
plotImageArray(img, main = "RGB image")
plotImageArray(img[ , , 1], main = "R channel")
plotImageArray(img[ , , 2], main = "G channel")
plotImageArray(img[ , , 3], main = "B channel")
plotImageArray(img[ , , 4], main = "Alpha channel")
layout(matrix(1:5, nrow = 1))
plotImageArray(img, main = "RGB image")
plotImageArray(img[ , , 1], main = "R channel")
plotImageArray(img[ , , 2], main = "G channel")
plotImageArray(img[ , , 3], main = "B channel")
plotImageArray(img[ , , 4], main = "Alpha channel")
corbetti <- system.file("extdata/corbetti.png", package = "recolorize")
# using all the default parameters:
recolorize_defaults <- recolorize(img = corbetti)
# you can also read in the image as an array:
corbetti_array <- readImage(corbetti)
# and then pass it to the recolorize function
# (not plotting this time since it gives you identical results)
recolorize_defaults <- recolorize(img = corbetti_array, plotting = FALSE)
class(recolorize_defaults)
attributes(recolorize_defaults)
summary(recolorize_defaults)
dim(recolorize_defaults$recolored_img)
dim(recolorize_defaults$pixel_assignments)
# using just the pixel_assignments and centers to recreate the recolored image:
recolored_img <- constructImage(pixel_assignments = recolorize_defaults$pixel_assignments,
centers = recolorize_defaults$centers)
# we can also pass a different set of centers:
new_centers <- viridisLite::viridis(8)
new_centers <- t(col2rgb(new_centers) / 255)
viridis_img <- constructImage(pixel_assignments = recolorize_defaults$pixel_assignments,
centers = new_centers)
layout(matrix(1:2, nrow = 1))
plotImageArray(recolored_img, main = "recolored image")
plotImageArray(viridis_img, main = "swapped centers")
# where we're going, we don't need figure margins!
par(mar = rep(0, 4))
# all colors the same size, with printed numbers for their index
plotColorPalette(centers = recolorize_defaults$centers)
# colors proportional to their region size in the image
plotColorPalette(centers = recolorize_defaults$centers,
sizes = recolorize_defaults$sizes)
# where we're going, we don't need figure margins!
par(mar = rep(0, 4))
# all colors the same size, with printed numbers for their index
plotColorPalette(centers = recolorize_defaults$centers)
# number of bins is ^3, so we'll specify 2 bins and 8 kmeans clusters to get 8 color centers either way:
hist_obj <- recolorize(corbetti, method = "histogram", bins = 2)
kmeans_obj <- recolorize(corbetti, method = "kmeans", n = 8)
layout(matrix(1:3, nrow = 1))
# using increasing numbers of bins per channel:
for (i in 2:4) {
hist_fit <- recolorize(corbetti, method = "hist", bins = i, plotting = FALSE)
plotColorClusters(centers = hist_fit$centers,
sizes = hist_fit$sizes, scaling = 10,
tick.marks = F, xlab = "R", ylab = "G", zlab = "B",
main = paste(i, "bins per channel"))
}
plot(hist_fit, sizes = TRUE)
library(recolorize)
k_vec <- 3:10
layout(matrix(1:8, nrow = 2))
for (i in k_vec) {
kmeans_fit <- recolorize(corbetti, "k", n = i, plotting = FALSE)
plotColorClusters(centers = kmeans_fit$centers,
sizes = kmeans_fit$sizes, scaling = 10,
tick.marks = F,
xlab = "", ylab = "", zlab = "",
main = paste("n =", i),
mar = c(2, 1, 2, 1),
xlim = 0:1, ylim = 0:1, zlim = 0:1)
}
```{r, fig.width = 6, fig.height = 4}
kmeans_1 <- recolorize(corbetti, method = "k", n = 8, plotting = FALSE)
kmeans_2 <- recolorize(corbetti, method = "k", n = 8, plotting = FALSE)
kmeans_3 <- recolorize(corbetti, method = "k", n = 8, plotting = FALSE)
layout(matrix(1:6, nrow = 1), widths = c(rep(.25, 3),
rep(.25/3, 3)))
for (i in list(kmeans_1, kmeans_2, kmeans_3)) {
par(mar = rep(0, 4))
plotImageArray(i$recolored_img)
}
for (i in list(kmeans_1, kmeans_2, kmeans_3)) {
par(mar = rep(0, 4))
plotColorPalette(i$centers, i$sizes, horiz = FALSE)
}
# image path
corbetti <- system.file("extdata/corbetti.png", package = "recolorize")
# using default settings
init_fit <- recolorize(corbetti, method = "histogram", bins = 2, color_sapce = "sRGB")
# using default settings
init_fit <- recolorize(corbetti, method = "histogram", bins = 2, color_space = "sRGB")
recluster_fit <- recluster(init_fit, color_space = "Lab", similarity_cutoff = 60, plot_hclust = TRUE)
recluster_fit <- recluster(init_fit, color_space = "Lab", similarity_cutoff = 45, plot_hclust = TRUE)
threshold_fit <- thresholdRecolor(init_fit, pct = 0.05)
threshold_fit <- thresholdRecolor(init_fit, pct = 0.01)
# this isn't as effective
threshold_fit <- thresholdRecolor(init_fit, pct = 0.02)
init_fit <- recolorize(corbetti, method = "histogram", bins = 3, color_space = "sRGB")
# this isn't as effective
threshold_fit <- thresholdRecolor(init_fit, pct = 0.02)
# this isn't as effective
threshold_fit <- thresholdRecolor(init_fit, pct = 0.05)
# this isn't as effective
threshold_fit <- thresholdRecolor(init_fit, pct = 0.1)
# this isn't as effective
threshold_fit <- thresholdRecolor(init_fit, pct = 0.05)
plot(init_fit)
# using default settings
init_fit <- recolorize(corbetti, method = "histogram", bins = 2, color_space = "sRGB")
plot(init_fit)
merge_fit <- mergeLayers(init_fit, merge_list = list(1, 2,
c(3, 5),
c(4, 7),
c(6, 8)))
# we can clean/despeckle layers:
edited_fit <- editLayer(merge_fit, layer_idx = 1, operation = "clean", px_size = 2)
# we can clean/despeckle layers:
edited_fit <- editLayer(merge_fit, layer_idx = 1, operation = "fill", px_size = 2)
# we can clean/despeckle layers:
edited_fit <- editLayer(merge_fit, layer_idx = 1, operation = "shrink", px_size = 2)
# we can clean/despeckle layers:
edited_fit <- editLayer(merge_fit, layer_idx = 1, operation = "shrink", px_size = 3)
edited_fit2 <- editLayer(edited_fit, layer_idx = 1, operation = "grow", px_size = 2)
edited_fit2 <- editLayer(edited_fit, layer_idx = 1, operation = "grow", px_size = 3)
# we can clean/despeckle layers:
edited_fit <- editLayer(merge_fit, layer_idx = 1, operation = "clean", px_size = 3)
# we can clean/despeckle layers:
edited_fit <- editLayer(merge_fit, layer_idx = 1, operation = "clean", px_size = 2)
edited_fit2 <- editLayer(merge_fit, layer_idx = 1, operation = "fill", px_size = 2)
# we can do several layers at once:
edited_multiple <- editLayers(merge_fit)
# we can do several layers at once:
edited_multiple <- editLayers(merge_fit, operations = "shrink", px_sizes = 8)
# we can do several layers at once:
edited_multiple <- editLayers(merge_fit, operations = "shrink", px_sizes = 5)
# we can do several layers at once:
edited_multiple <- editLayers(merge_fit, operations = "clean", px_sizes = 5)
# we can do several layers at once:
edited_multiple <- editLayers(merge_fit, operations = "clean", px_sizes = 10)
dir(system.file("extdata", package = "recolorize"))
im1 <- system.file("extdata/ocellata.png", package = "recolorize")
im2 <- system.file("extdata/ephippigera.png", package = "recolorize")
fit_1 <- recolorize(im1)
fit_2 <- imposeColors(im2, centers = fit_1$centers)
fit_2 <- imposeColors(im2, centers = fit_1$centers, adjust_centers = FALSE)
rgb_centers <- col2rgb(c("red", "green", "blue",
"cyan", "magenta", "yellow",
"black", "white"))
rgb_centers
rgb_centers <- t(col2rgb(c("red", "green", "blue",
"cyan", "magenta", "yellow",
"black", "white")) / 255)
fit_rgb <- imposeColors(im2, centers = rgb_centers, adjust_centers = FALSE)
# image path
fulgidissima <- system.file("extdata/fulgidissima.png", package = "recolorize")
# load image
img <- readImage(fulgidissima)
# load image
img <- readImage(fulgidissima)
?blurImage
#
blurred_img <- blurImage(img, blur_function = "blur_anisotropic", 2)
#
blurred_img <- blurImage(img, blur_function = "blur_anisotropic", 5)
#
blurred_img <- blurImage(img, blur_function = "blur_anisotropic", amplitude = 5)
#
blurred_img <- blurImage(img, blur_function = "blur_anisotropic",
amplitude = 5, sharpness = 3)
#
blurred_img <- blurImage(img, blur_function = "blur_anisotropic",
amplitude = 1, sharpness = 3)
#
blurred_img <- blurImage(img, blur_function = "blur_anisotropic",
amplitude = 2, sharpness = 3)
#
blurred_img <- blurImage(img, blur_function = "blur_anisotropic",
amplitude = 2, sharpness = 1)
#
blurred_img <- blurImage(img, blur_function = "blur_anisotropic",
amplitude = 2, sharpness = 10)
#
blurred_img <- blurImage(img, blur_function = "medianblur",
n = 5, threshold = 0.5)
#
blurred_img <- blurImage(img, blur_function = "medianblur",
n = 5, threshold = 0.4)
#
blurred_img <- blurImage(img, blur_function = "medianblur",
n = 5, threshold = 0.2)
init_fit
recolorize_obj <- init_fit
pixel_idx <- which(recolorize_obj$pixel_assignments != 0)
pixel_idx
# get residuals in given color space
imDist(recluster_fit$original_img,
recluster_fit$recolored_img)
# get residuals in given color space
imDist(merge_fit$recolored_img,
recluster_fit$recolored_img)
# we can identify the hotspots of differences between two clustering methods:
imdist <- imDist(merge_fit$recolored_img,
recluster_fit$recolored_img)
# we can identify the hotspots of differences between two clustering methods:
fit_dist <- imDist(merge_fit$recolored_img,
recluster_fit$recolored_img)
hist(fit_dist)
hist(fit_dist > 0)
hist(fit_dist[which(fit_dist > 0)])
# or between the original image and the color map:
im_dist <- imDist(merge_fit$original_img,
merge_fit$recolored_img)
?imDist
# we can identify the hotspots of differences between two clustering methods:
fit_dist <- imDist(merge_fit$recolored_img,
recluster_fit$recolored_img)
# or between the original image and the color map:
im_dist <- imDist(merge_fit$original_img,
merge_fit$recolored_img)
hist(im_dist)
# we can see how our residuals are distributed:
hist(sqrt(im_dist^2))
# we can see how our residuals are distributed:
hist(sqrt(im_dist^2))
# and we can split by color
layers <- splitByColor(merge_fit, plot_method = "binary")
# and we can split by color
layout(matrix(1:5, nrow = 1))
layers <- splitByColor(merge_fit, plot_method = "binary")
layers <- splitByColor(merge_fit, plot_method = "colormask")
layers <- splitByColor(merge_fit, plot_method = "binary")
as_classify <- classify_recolorize(recluster_fit)
devtools::load_all(".")
# we can see how our residuals are distributed:
hist(im_dist, main = "CIE Lab distances")
as_classify <- classify_recolorize(recluster_fit)
classify_obj <- classify_recolorize(recluster_fit)
test <- pavo::adjacent(classify_obj)
test <- pavo::adjacent(classify_obj, xscale = 10)
devtools::load_all(".")
?recluster
# get an image
corbetti <- system.file("extdata/corbetti.png", package = "recolorize")
# too many color centers
recolored_corbetti <- recolorize(corbetti, bins = 3)
# just enough!
# check previous plot for clustering cutoff
recluster_obj <- recluster(recolored_corbetti,
similarity_cutoff = 60,
plot_hclust = TRUE,
refit_method = "impose")
devtools::load_all(".")
# get an image
corbetti <- system.file("extdata/corbetti.png", package = "recolorize")
# too many color centers
recolored_corbetti <- recolorize(corbetti, bins = 3)
# just enough!
# check previous plot for clustering cutoff
recluster_obj <- recluster(recolored_corbetti,
similarity_cutoff = 60,
plot_hclust = TRUE,
refit_method = "impose")
par(mar = c(3, 2, 0, 0))
plot(hcd, xlab = "", ylab = paste(color_space, "color distance"))
devtools::load_all(".")
# get an image
corbetti <- system.file("extdata/corbetti.png", package = "recolorize")
# too many color centers
recolored_corbetti <- recolorize(corbetti, bins = 3)
# just enough!
# check previous plot for clustering cutoff
recluster_obj <- recluster(recolored_corbetti,
similarity_cutoff = 60,
plot_hclust = TRUE,
refit_method = "impose")
devtools::load_all(".")
# get an image
corbetti <- system.file("extdata/corbetti.png", package = "recolorize")
# too many color centers
recolored_corbetti <- recolorize(corbetti, bins = 3)
# just enough!
# check previous plot for clustering cutoff
recluster_obj <- recluster(recolored_corbetti,
similarity_cutoff = 60,
plot_hclust = TRUE,
refit_method = "impose")
devtools::load_all(".")
centers
centers <- recolored_corbetti$centers
centers
col2col(centers, "sRGB", "sRGB")
hex_col <- grDevices::rgb(centers)
hex_col
library(recolorize)
recluster_results <- recluster(recolorize_defaults,
similarity_cutoff = 45)
corbetti <- system.file("extdata/corbetti.png", package = "recolorize")
# using all the default parameters:
recolorize_defaults <- recolorize(img = corbetti)
recluster_results <- recluster(recolorize_defaults,
similarity_cutoff = 45)
recluster_rgb <- recluster(recolorize_defaults, color_space = "sRGB",
similarity_cutoff = 0.5)
similarity_cutoff = 0.5)
?thresholdRecolor
chongi <- system.file("extdata/chongi.png", package = "recolorize")
chongi_1 <- recolorize(chongi)
chongi_1 <- recolorize(chongi, bins = 3)
chongi_1 <- recolorize(chongi, bins = 2)
chongi_2 <- thresholdRecolor(chongi_1)
chongi_1 <- recolorize(chongi, bins = 3)
chongi_2 <- thresholdRecolor(chongi_1)
chongi_1 <- recolorize(chongi, color_space = "Lab", bins = 3)
chongi_2 <- thresholdRecolor(chongi_1)
chongi_1 <- recolorize(chongi, color_space = "sRGB", bins = 3)
chongi_1 <- recolorize(chongi, color_space = "sRGB", bins = 2)
chongi_2 <- thresholdRecolor(chongi_1)
corbetti_impose <- imposeColors(corbetti,
centers = t(col2rgb(c("black",
"white",
"red",
"green",
"blue")) / 255))
corbetti_impose <- imposeColors(corbetti, color_space = "sRGB",
centers = t(col2rgb(c("black",
"white",
"red",
"green",
"blue")) / 255))
dir(system.file("extdata", package = "recolorize"))
fit1 <- recolorize(im1)
im1 <- system.file("extdata/ocellata.png", package = "recolorize")
im2 <- system.file("extdata/ephippigera.png", package = "recolorize")
fit1 <- recolorize(im1)
fit2 <- imposeColors(im2)
fit2 <- imposeColors(im2, centers = fit1$centers)
fit1 <- recolorize(im1)
fit2 <- imposeColors(im2, centers = fit1$centers)
# edit a single layer
editLayer(recluster_fit, 1, "clean", 2)
# edit a single layer
editLayer(recluster_results, 1, "clean", 2)
# edit a single layer
cream_edit <- editLayer(recluster_results, layer_idx = 2, operation = "clean", px_size = 2)
# edit a single layer
cream_edit <- editLayer(recluster_results, layer_idx = 2, operation = "clean", px_size = 3)
# edit multiple layers
mondrian <- editLayers(cream_edit, operations = "clean", px_sizes = 10)
# edit multiple layers
mondrian <- editLayers(recluster_results, operations = "clean", px_sizes = 10)
merge_fit <- mergeLayers(recolorize_defaults,
merge_list = list(1, 2,
c(3, 5),
c(4, 7),
c(6, 8)))
```{r, fig.width=5}
layout(matrix(1:2, 1))
plotImageArray(recluster_results$recolored_img, main = "recluster")
plotImageArray(merge_fit$recolored_img, main = "mergeLayers")
dist_original <- imDist(recluster_results$original_img,
recluster_results$recolored_img)
dist_fits <- imDist(recolorize_defaults$recolored_img,
recluster_results$recolored_img)
dist_fits <- imDist(merge_fit$recolored_img,
recluster_results$recolored_img)
dist_fits <- imDist(merge_fit$recolored_img,
recluster_results$recolored_img, color_space = "sRGB")
sum(dist_fits)
sum(dist_original, na.rm = TRUE)
hist(dist_original, na.rm = TRUE)
hist(dist_original, main = "CIE Lab residuals", xlab = "CIE Lab distance")
layout(matrix(1:5, nrow = 1))
layers <- splitByColor(recluster_results)
image(layers[[1]])
image(layers[[1]], col = c("black", "white"))
image(t(layers[[1]]), col = c("black", "white"))
plotImageArray(layers[[1]])
lapply(layers, plotImageArray)
as_classify <- classify_recolorize(recluster_results, imgname = "corbetti")
adj_analysis <- pavo::adadjacent(as_classify, xscale = 10)
as_classify <- classify_recolorize(recluster_results, imgname = "corbetti")
adj_analysis <- pavo::adjacent(as_classify, xscale = 10)
