img.path <- system.file("extdata/chongi", package = "recolorize")
img <- readImage(img.path)
# generate a white background condition
bg.condition <- backgroundCondition(alpha.channel = TRUE,
transparent = TRUE)
# index background pixels
bg.indexed <- backgroundIndex(img, bg.condition)
img.path <- system.file("extdata/chongi", package = "recolorize")
img <- readImage(img.path)
# generate a white background condition
bg.condition <- backgroundCondition(alpha.channel = TRUE,
transparent = TRUE)
# index background pixels
bg.indexed <- backgroundIndex(img, bg.condition)
img
img.path <- system.file("extdata/chongi", package = "recolorize")
img.path <- system.file("extdata/chongi.png", package = "recolorize")
img <- readImage(img.path)
# generate a white background condition
bg.condition <- backgroundCondition(alpha.channel = TRUE,
transparent = TRUE)
# index background pixels
bg.indexed <- backgroundIndex(img, bg.condition)
# and cluster them:
color.clusters <- colorClusters(bg.indexed$non.bg,
bins = 2,
color.space = "sRGB")
# recolor image:
pixel_assignments <- pixelAssignMatrix(bg.indexed, color.clusters)
test <- constructImage(pixel_assignments$pixel_assignments,
pixel_assignments$color_centers)
# first, make a pixel assignment matrix:
pixel_assignments <- pixelAssignMatrix(bg.indexed,
color.clusters)
# make an image from the above information:
recolored_img <- constructImage(pixel_assignments$pixel_assignments,
pixel_assignments$centers,
background_color = bg.color)
bg.color = "white"
# make an image from the above information:
recolored_img <- constructImage(pixel_assignments$pixel_assignments,
pixel_assignments$centers,
background_color = bg.color)
# make an image from the above information:
recolored_img <- constructImage(pixel_assignments$pixel_assignments,
pixel_assignments$centers)
pixel_assignments$color_centers
img.path <- system.file("extdata/chongi.png", package = "recolorize")
img <- readImage(img.path)
# generate a white background condition
bg.condition <- backgroundCondition(alpha.channel = TRUE,
transparent = TRUE)
# index background pixels
bg.indexed <- backgroundIndex(img, bg.condition)
# and cluster them:
color.clusters <- colorClusters(bg.indexed$non.bg,
bins = 2,
color.space = "sRGB")
# recolor image:
pixel_assignments <- pixelAssignMatrix(bg.indexed, color.clusters)
test <- constructImage(pixel_assignments$pixel_assignments,
pixel_assignments$color_centers)
# ok, what do we do with it?
recolorize_obj <- init_fit
filterLayer <- function(recolorize_obj,
which_layer = 1,
method = clean,
...){
layers <- splitByColor(recolorize_obj, plot_method = "none")
layer <- imager::as.cimg(layers[[which_layer]]) > 0
edited_layer <- imager::method(layer, ...)
plot(edited_layer)
}
filterLayer(init_fit, method = fill, 2)
devtools::load_all(".")
filterLayer(init_fit, method = fill, 2)
img <- system.file("extdata/corbetti.png", package = "recolorize")
init_fit <- recolorize(img)
layout(matrix(1:8, nrow = 2))
layers <- splitByColor(init_fit, plot_method = "binary")
layout(1)
# this is the cream patch, but we've got some stragglers:
layer_idx <- 1
layer <- layers[[layer_idx]]; plotImageArray(layer)
plotImageArray(init_fit$pixel_assignments / 8)
# first, convert to a cimg:
cimg_layer <- imager::as.cimg(layer) > 0
# now we can do some operation to it:
shrink_layer <- imager::shrink(cimg_layer, 2); plot(shrink_layer)
grow_layer <- imager::grow(cimg_layer, 2); plot(grow_layer)
# cleaning = shrink and then grow:
clean_layer <- imager::clean(cimg_layer, 25); plot(clean_layer)
# filling = grow and then shrink:
fill_layer <- imager::fill(cimg_layer, 4); plot(fill_layer)
# we can do both:
library(imager)
clean(cimg_layer, 4) %>% fill(1) %>% plot
# ok, what do we do with it?
recolorize_obj <- init_fit
filterLayer <- function(recolorize_obj,
which_layer = 1,
method = clean,
...){
layers <- splitByColor(recolorize_obj, plot_method = "none")
layer <- imager::as.cimg(layers[[which_layer]]) > 0
edited_layer <- imager::method(layer, ...)
plot(edited_layer)
}
filterLayer(init_fit, method = fill, 2)
# ok, what do we do with it?
recolorize_obj <- init_fit
filterLayer <- function(recolorize_obj,
which_layer = 1,
imager_method = clean,
...){
layers <- splitByColor(recolorize_obj, plot_method = "none")
layer <- imager::as.cimg(layers[[which_layer]]) > 0
edited_layer <- imager::imager_method(layer, ...)
plot(edited_layer)
}
filterLayer(init_fit, method = fill, 2)
# ok, what do we do with it?
recolorize_obj <- init_fit
filterLayer <- function(recolorize_obj,
which_layer = 1,
imager_method = clean,
...){
layers <- splitByColor(recolorize_obj, plot_method = "none")
layer <- imager::as.cimg(layers[[which_layer]]) > 0
edited_layer <- imager_method(layer, ...)
plot(edited_layer)
}
filterLayer(init_fit, method = fill, 2)
filterLayer(init_fit, imager_method = fill, 2)
filterLayer(init_fit, 1, imager_method = fill, 2)
filterLayer(init_fit, 2, method = clean, 2)
# ok, what do we do with it?
recolorize_obj <- init_fit
filterLayer <- function(recolorize_obj,
which_layer = 1,
imager_method = clean,
...){
layers <- splitByColor(recolorize_obj, plot_method = "none")
layer <- imager::as.cimg(layers[[which_layer]]) > 0
edited_layer <- method(layer, ...)
plot(edited_layer)
}
filterLayer(init_fit, 1, imager_method = fill, 2)
filterLayer(init_fit, 1, method = fill, 2)
# ok, what do we do with it?
recolorize_obj <- init_fit
filterLayer <- function(recolorize_obj,
which_layer = 1,
imager_method = clean,
...){
layers <- splitByColor(recolorize_obj, plot_method = "none")
layer <- imager::as.cimg(layers[[which_layer]]) > 0
edited_layer <- method(layer, ...)
plot(edited_layer)
}
filterLayer(init_fit, 1, method = fill, 2)
# ok, what do we do with it?
recolorize_obj <- init_fit
filterLayer <- function(recolorize_obj,
which_layer = 1,
imager_method = clean,
...){
layers <- splitByColor(recolorize_obj, plot_method = "none")
layer <- imager::as.cimg(layers[[which_layer]]) > 0
edited_layer <- imager_method(layer, ...)
plot(edited_layer)
}
filterLayer(init_fit, 1, fill, 2)
filterLayer(init_fit, 2, clean, 2)
filterLayer(init_fit, 2, clean, 3)
# and now...mild absurdity:
new_image <-constructImage(init_fit$pixel_assignments,
init_fit$centers)
plotImageArray(new_image)
# set the original layer to background
original_idx <- which(init_fit$pixel_assignments == layer_idx)
init_fit$pixel_assignments[original_idx] <- 0
# and set the new layer
array_layer <- recolorize:::cimg_to_array(clean_layer)
init_fit$pixel_assignments[which(array_layer > 0)] <- layer_idx
# and now...mild absurdity:
new_image <-constructImage(init_fit$pixel_assignments,
init_fit$centers)
plotImageArray(new_image)
# install & load package
#devtools::install_github("hiweller/recolorize")
library(recolorize)
# recolorize: simplify image colors ####
# get images that come with the package (thanks Nathan & Able!)
images <- dir(system.file("extdata/", package = "recolorize"),
pattern = "png", full.names = TRUE)
# default behavior is to bin the colors (histogram method)
# note: we don't have to specify a background because this is a PNG with
# transparency; if your background is a color use the `upper` and `lower`
# arguments
chongi_recolored <- recolorize(images[1], method = "hist", n = 2)
devtools::load_all(".")
devtools::install_github("hiweller/recolor", ref = "betterIndexing")
devtools::install_github("hiweller/recolorize", ref = "betterIndexing")
# install & load package
#devtools::install_github("hiweller/recolorize")
library(recolorize)
# recolorize: simplify image colors ####
# get images that come with the package (thanks Nathan & Able!)
images <- dir(system.file("extdata/", package = "recolorize"),
pattern = "png", full.names = TRUE)
# default behavior is to bin the colors (histogram method)
# note: we don't have to specify a background because this is a PNG with
# transparency; if your background is a color use the `upper` and `lower`
# arguments
chongi_recolored <- recolorize(images[1], method = "hist", n = 2)
# install & load package
#devtools::install_github("hiweller/recolorize")
library(recolorize)
# recolorize: simplify image colors ####
# get images that come with the package (thanks Nathan & Able!)
images <- dir(system.file("extdata/", package = "recolorize"),
pattern = "png", full.names = TRUE)
# default behavior is to bin the colors (histogram method)
# note: we don't have to specify a background because this is a PNG with
# transparency; if your background is a color use the `upper` and `lower`
# arguments
chongi_recolored <- recolorize(images[1], method = "hist", n = 2)
# save the output using writePNG
png::writePNG(chongi_recolored$recolored.img, target = "chongi_recolored.png")
# we can also use kmeans clustering
recolorize(images[1], method = "kmeans", n = 8)
# you get different clusters each time you run kmeans:
layout(matrix(1:5, nrow = 1))
for (i in 1:5) {
if (i == 1) {kmeans.repeat <- vector("list", 5)}
kmeans.repeat[[i]] <- recolorize(images[5], n = 4,
method = "kmeans",
plotting = FALSE)
plotImageArray(kmeans.repeat[[i]]$recolored.img,
main = paste0("Iteration ", i))
}
plotImageArray(kmeans.repeat[[i]]$recolored_img,
main = paste0("Iteration ", i))
# you get different clusters each time you run kmeans:
layout(matrix(1:5, nrow = 1))
for (i in 1:5) {
if (i == 1) {kmeans.repeat <- vector("list", 5)}
kmeans.repeat[[i]] <- recolorize(images[5], n = 4,
method = "kmeans",
plotting = FALSE)
plotImageArray(kmeans.repeat[[i]]$recolored_img,
main = paste0("Iteration ", i))
}
# you get different clusters each time you run kmeans:
layout(matrix(1:5, nrow = 1))
for (i in 1:5) {
if (i == 1) {kmeans.repeat <- vector("list", 5)}
kmeans.repeat[[i]] <- recolorize(images[5], n = 4,color_space = "sRGB",
method = "kmeans",
plotting = FALSE)
plotImageArray(kmeans.repeat[[i]]$recolored_img,
main = paste0("Iteration ", i))
}
# you get different clusters each time you run kmeans:
layout(matrix(1:5, nrow = 1))
for (i in 1:5) {
if (i == 1) {kmeans.repeat <- vector("list", 5)}
kmeans.repeat[[i]] <- recolorize(images[1], n = 4,color_space = "sRGB",
method = "kmeans",
plotting = FALSE)
plotImageArray(kmeans.repeat[[i]]$recolored_img,
main = paste0("Iteration ", i))
}
# you get different clusters each time you run kmeans:
layout(matrix(1:5, nrow = 1))
for (i in 1:5) {
if (i == 1) {kmeans.repeat <- vector("list", 5)}
kmeans.repeat[[i]] <- recolorize(images[2], n = 4,
color_space = "sRGB",
method = "kmeans",
plotting = FALSE)
plotImageArray(kmeans.repeat[[i]]$recolored_img,
main = paste0("Iteration ", i))
}
# you get different clusters each time you run kmeans:
layout(matrix(1:5, nrow = 1))
for (i in 1:5) {
if (i == 1) {kmeans.repeat <- vector("list", 5)}
kmeans.repeat[[i]] <- recolorize(images[3], n = 4,
color_space = "sRGB",
method = "kmeans",
plotting = FALSE)
plotImageArray(kmeans.repeat[[i]]$recolored_img,
main = paste0("Iteration ", i))
}
# you get different clusters each time you run kmeans:
layout(matrix(1:5, nrow = 1))
for (i in 1:5) {
if (i == 1) {kmeans.repeat <- vector("list", 5)}
kmeans.repeat[[i]] <- recolorize(images[4], n = 4,
color_space = "sRGB",
method = "kmeans",
plotting = FALSE)
plotImageArray(kmeans.repeat[[i]]$recolored_img,
main = paste0("Iteration ", i))
}
# compare binning vs. kmeans
for (i in 1:length(images)) {
# kmeans recolor
kmeans.recolor <- recolorize(images[i], method = "kmeans",
n = 8, plotting = FALSE)
# hist recolor
hist.recolor <- recolorize(images[i], method = "hist",
bins = 2, plotting = FALSE)
# plot all three side by side
layout(matrix(c(1:3), ncol = 3))
plotImageArray(kmeans.recolor$original.img, main = "original")
plotImageArray(kmeans.recolor$recolored.img, main = "kmeans")
plotImageArray(hist.recolor$recolored.img, main = "binning")
# pausing
invisible(readline(prompt = "Press [enter] to continue or [esc] to exit"))
}
# compare binning vs. kmeans
for (i in 1:length(images)) {
# kmeans recolor
kmeans.recolor <- recolorize(images[i], method = "kmeans",
n = 8, plotting = FALSE)
# hist recolor
hist.recolor <- recolorize(images[i], method = "hist",
bins = 2, plotting = FALSE)
# plot all three side by side
layout(matrix(c(1:3), ncol = 3))
plotImageArray(kmeans.recolor$original_img, main = "original")
plotImageArray(kmeans.recolor$recolored_img, main = "kmeans")
plotImageArray(hist.recolor$recolored_img, main = "binning")
# pausing
invisible(readline(prompt = "Press [enter] to continue or [esc] to exit"))
}
# imposeColors: you can map an image to custom colors ####
# RGB extremes (white, black, red, green, blue, yellow, magenta, cyan)
ctrs <- matrix(c(1, 1, 1,
0, 0, 0,
1, 0, 0,
0, 1, 0,
0, 0, 1,
1, 1, 0,
1, 0, 1,
0, 1, 1), byrow = TRUE, ncol = 3)
# yuck (but you get the point):
sapply(1:5, function(i) imposeColors(images[i], ctrs,
adjust.centers = FALSE))
# yuck (but you get the point):
sapply(1:5, function(i) imposeColors(images[i], ctrs,
adjust_centers = FALSE))
# it looks nicer if you let the centers adjust to average
# colors after pixels are assigned:
imposeColors(images[5], ctrs, adjust.centers = TRUE)
# it looks nicer if you let the centers adjust to average
# colors after pixels are assigned:
imposeColors(images[5], ctrs, adjust_centers = TRUE)
# it looks nicer if you let the centers adjust to average
# colors after pixels are assigned:
imposeColors(images[5],
ctrs, color_space = "sRGB",
adjust_centers = TRUE)
# it looks nicer if you let the centers adjust to average
# colors after pixels are assigned:
imposeColors(images[5],
ctrs, color_space = "Lab",
adjust_centers = TRUE)
# it looks nicer if you let the centers adjust to average
# colors after pixels are assigned:
imposeColors(images[5],
ctrs, color_space = "Luv",
adjust_centers = TRUE)
# but...you can take colors from one image:
ocellata.colors <- recolorize(images[5], method = "kmeans", n = 10)
# and map them to another:
ephippigera_to_ocellata <- imposeColors(images[3],
ocellata.colors$centers,
adjust.centers = FALSE)
# and map them to another:
ephippigera_to_ocellata <- imposeColors(images[3],
ocellata.colors$centers,
adjust_centers = FALSE)
# this one doesn't look so good (big surprise)
corbetti_to_ocellata <- imposeColors(images[2],
ocellata.colors$centers,
adjust.centers = FALSE)
# this one doesn't look so good (big surprise)
corbetti_to_ocellata <- imposeColors(images[2],
ocellata.colors$centers,
adjust_centers = FALSE)
# try it out with heliconius:
# install.packages("colordistance")
heliconius <- dir(system.file("extdata", package = "colordistance"),
pattern = "Heliconius",
recursive = TRUE, full.names = TRUE)
# plot them to see what we're working with:
layout(matrix(c(1:8), nrow = 2, byrow = TRUE))
sapply(heliconius, function(i) plotImageArray(readImage(i),
main = basename(i)))
# get one set of colors...
# (notice we have to mask the white background)
heliconius.colors <- recolorize(heliconius[7],
lower = rep(0.9, 3), upper = rep(1, 3),
method = "kmeans", n = 3)
# map all the other images to those colors
for (i in 1:length(heliconius)) {
imposeColors(heliconius[i], heliconius.colors$centers,
adjust.centers = FALSE,
lower = rep(0.9, 3), upper = rep(1, 3))
} # not bad!
# map all the other images to those colors
for (i in 1:length(heliconius)) {
imposeColors(heliconius[i], heliconius.colors$centers,
adjust_centers = FALSE,
lower = rep(0.9, 3), upper = rep(1, 3))
} # not bad!
# recluster: correct over-clustering ####
chongi <- system.file("extdata/chongi.png", package = "recolorize")
# using 3 bins/channel splits uniform regions (e.g. the navy):
recolored_chongi <- recolorize(chongi, bins = 2,
color_space = "sRGB")
# using 3 bins/channel splits uniform regions (e.g. the navy):
recolored_chongi <- recolorize(chongi, bins = 2,
color_space = "Lab")
# using 3 bins/channel splits uniform regions (e.g. the navy):
recolored_chongi <- recolorize(chongi, bins = 2,
color_space = "sRGB")
# we can group together the most similar clusters:
reclustered_chongi <- recluster(recolored_chongi,
similarity_cutoff = 40,
color.space.fit = "sRGB",
plot_hclust = TRUE)
# we can group together the most similar clusters:
reclustered_chongi <- recluster(recolored_chongi,
similarity_cutoff = 40,
color_space_fit = "sRGB",
plot_hclust = TRUE)
# we can also specify our final number of colors, as with kmeans:
recluster_chongi <- recluster(recolored_chongi,
n_final = 6,
plot_hclust = TRUE)
# compare with actual kmeans with n = 6; the navy is usually split into 2-3
# colors, and we get different results every time (!):
kmeans_chongi <- recolorize(chongi, "k", n = 6)
kmeans_chongi <- recolorize(chongi, "k", n = 6)
kmeans_chongi <- recolorize(chongi, "k", n = 6)
# you can also recluster a kmeans fit, which is nice
# the cutoff typically has to be lower and you do still have the issue of
# different results every time, but the recluster fit tends to be stable
kmeans_chongi <- recolorize(chongi, "k", n = 20)
kmeans_recluster <- recluster(kmeans_chongi, similarity_cutoff = 45)
# note the 'residuals' option (also now in imposeColors and recolorize):
kmeans_chongi <- recolorize(chongi, "k", n = 20, resid = TRUE)
kmeans_recluster <- recluster(kmeans_chongi,
resid = TRUE,
similarity_cutoff = 45)
# note the 'residuals' option (also now in imposeColors and recolorize):
kmeans_chongi <- recolorize(chongi, "k", n = 20, resid = TRUE)
boa <- read.csv("~/Dropbox/projects/john_boas/boa_rotations.csv")
head(boa)
library(tidyverse)
colnames(boa)
pivot_longer(boa, c(13:15), names_to = "rotation")
test <- pivot_longer(boa, c(13:15), names_to = "rotation")
head(test)
test$value
test$rotation
test <- pivot_longer(boa, c(13:15), names_to = "axis", values_to = "rotation")
colnames(test)
ggplot(test, aes(x = axis, y = rotation)) +
geom_boxplot(aes(color = axis)) +
facet_wrap(~individual*posture*behavior)
ggplot(test, aes(x = axis, y = rotation)) +
geom_boxplot(aes(color = axis)) +
facet_wrap(~individual*location*behavior)
ggplot(test, aes(x = axis, y = rotation)) +
geom_boxplot(aes(color = axis)) +
facet_wrap(~individual*location*behavior) + theme_bw(base_size = 9)
ggplot(test, aes(x = axis, y = rotation)) +
geom_boxplot(aes(color = axis)) +
facet_wrap(~individual*location*behavior) + theme_classic(base_size = 9)
ggplot(test, aes(x = axis, y = rotation)) +
geom_boxplot(aes(color = axis)) +
facet_wrap(~individual*location*behavior) + theme_minimal(base_size = 9)
ggplot(test, aes(x = axis, y = rotation)) +
geom_boxplot(aes(color = axis)) +
facet_wrap(~individual*location*behavior) + theme_bw(base_size = 9)
ggplot(test, aes(x = axis, y = rotation)) +
geom_boxplot(aes(color = axis)) +
facet_wrap(~individual*behavior*location)
ggplot(test, aes(x = axis, y = rotation)) +
geom_boxplot(aes(color = axis)) +
facet_wrap(~individual*behavior*location) +
theme_bw(base_size = 10)
length(unique(test$trial))
test$trial
test$filename
length(test$filename)
length(unique(test$filename))
3*2*2
ggplot(test, aes(x = axis, y = rotation)) +
geom_boxplot(aes(color = axis)) +
facet_wrap(~individual*behavior*location) +
theme_bw(base_size = 10)
ggplot(test, aes(x = axis, y = rotation)) +
geom_boxplot(aes(color = axis)) +
facet_wrap(~individual*location*behavior) +
theme_bw(base_size = 10)
