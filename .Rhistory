recolorize(images[3], bins = c(5, 2, 2))
recolorize(images[3], bins = c(2, 5, 2))
recolorize(images[3], bins = c(2, 2, 5))
# we can also have different numbers of bins per channel
# more red bins:
recolorize(images[1], bins = c(5, 2, 2))
recolorize(images[1], bins = c(2, 5, 2))
recolorize(images[1], bins = c(2, 2, 5))
# we can also have different numbers of bins per channel
# more red bins:
recolorize(images[2], bins = c(5, 2, 2))
recolorize(images[2], bins = c(2, 5, 2))
recolorize(images[2], bins = c(2, 2, 5))
# we can also have different numbers of bins per channel
# more red bins:
recolorize(images[1], bins = c(5, 1, 1))
recolorize(images[1], bins = c(1, 5, 1))
recolorize(images[1], bins = c(1, 1, 5))
# we can also have different numbers of bins per channel
# more red bins:
recolorize(images[1], bins = c(5, 1, 1))
recolorize(images[1], bins = c(1, 5, 1))
recolorize(images[1], bins = c(1, 1, 5))
# we can also have different numbers of bins per channel
# more red bins:
recolorize(images[1], bins = c(4, 1, 1))
recolorize(images[1], bins = c(1, 4, 1))
recolorize(images[1], bins = c(1, 1, 4))
# default: histogram, 2 bins/channel
recolorize(images[2])
# we can also have different numbers of bins per channel
recolorize(images[2], bins = c(4, 1, 1)) # mostly red
recolorize(images[2], bins = c(1, 1, 4)) # mostly blue
recolorize(images[1], method = "kmeans", n = 8)
# we can also have different numbers of bins per channel
recolorize(images[2], bins = c(4, 1, 1)) # mostly red
recolorize(images[2], bins = c(1, 4, 1)) # mostly green
recolorize(images[2], bins = c(1, 1, 4)) # mostly blue
# we can also have different numbers of bins per channel
recolorize(images[1], bins = c(4, 1, 1)) # mostly red
recolorize(images[1], bins = c(1, 4, 1)) # mostly green
recolorize(images[1], bins = c(1, 1, 4)) # mostly blue
# default: histogram, 2 bins/channel
recolorize(images[1])
# kmeans can produce a better fit with fewer colors
recolorize(images[1], method = "kmeans", n = 8)
# increasing numbers of kmean colors
recolored.images <- setNames(vector("list", length = 10), c(1:10))
recolored.images
# increasing numbers of kmean colors
recolored.images <- setNames(vector("list", length = 10), c(1:10))
for (i in 1:10) {
kmeans.temp <- recolorize(images[1], n = i, plotting = FALSE)
recolored.images[[i]] <- kmeans.temp$recolored.img
}
# increasing numbers of kmean colors
recolored.images <- setNames(vector("list", length = 10), c(1:10))
for (i in 1:10) {
kmeans.temp <- recolorize(images[1], method = "kmeans",
n = i, plotting = FALSE)
recolored.images[[i]] <- kmeans.temp$recolored.img
}
layout(matrix(c(1:10), nrow = 2))
sapply(c(1:10), function(i) plotImageArray(recolored.images[[i]],
main = i))
layout(matrix(c(1:10), nrow = 2, byrow = TRUE))
sapply(c(1:10), function(i) plotImageArray(recolored.images[[i]],
main = i))
# increasing numbers of kmean colors
recolored.images <- setNames(vector("list", length = 10), c(1:10))
for (i in 1:10) {
kmeans.temp <- recolorize(images[1], method = "kmeans",
n = i)
invisible(readline(prompt = "Press [enter] to continue or [esc] to exit"))
}
# increasing numbers of kmean colors
recolored.images <- setNames(vector("list", length = 10), c(1:10))
for (i in 1:10) {
kmeans.temp <- recolorize(images[1], method = "kmeans",
n = i)
}
# default: histogram, 2 bins/channel
hist.recolor <- recolorize(images[1])
# kmeans, 10 colors
kmeans.recolor <- recolorize(images[1], method = "kmeans",
n = 8, plotting = FALSE)
hist.recolor <- recolorize(images[1], method = "hist",
bins = 2, plotting = FALSE)
# compare binning vs. kmeans clustering
layout(matrix(c(1, 2, 3), ncol = 3))
plotImageArray(kmeans.recolor$original.img, main = "original")
plotImageArray(kmeans.recolor$recolored.img, main = "kmeans")
plotImageArray(hist.recolor$recolored.img, main = "binning")
images <- system.file("extdata/chongi.png", package = "recolorize")
# default: histogram, 2 bins/channel
recolorize(images[1])
library(recolorize)
help(colordistance)
usethis::use_ccby_license()
usethis::use_gpl3_license()
usethis::use_ccby_license(name = "Hannah Weller")
img <- system.file("extdata/corbetti.png", package = "recolorize")
bg.condition <- backgroundCondition(transparent = TRUE, alpha.channel = TRUE)
bg.indexed <- backgroundIndex(img, bg.condition)
# flatten it first -- faster indexing!
img.dims <- dim(img)
flattened.img <- img
dim(flattened.img) <- c(img.dims[1] * img.dims[2],
img.dims[3])
img.dims
dim(img)
img
img.path <- img
img <- readImage(img.path)
bg.indexed <- backgroundIndex(img, bg.condition)
detach("package:recolorize", unload = TRUE)
library(recolorize)
# install & load package
#devtools::install_github("hiweller/recolorize")
library(recolorize)
# recolorize: simplify image colors ####
# get images that come with the package (thanks Nathan & Able!)
images <- dir(system.file("extdata/", package = "recolorize"),
pattern = "png", full.names = TRUE)
# default behavior is to bin the colors (histogram method)
# note: we don't have to specify a background because this is a PNG with
# transparency; if your background is a color use the `upper` and `lower`
# arguments
chongi_recolored <- recolorize(images[1], method = "kmeans", n = 4)
# we can also use kmeans clustering
recolorize(images[1], method = "kmeans", n = 8)
# default behavior is to bin the colors (histogram method)
# note: we don't have to specify a background because this is a PNG with
# transparency; if your background is a color use the `upper` and `lower`
# arguments
chongi_recolored <- recolorize(images[1], method = "hist", n = 2)
# save the output using writePNG
png::writePNG(chongi_recolored$recolored.img, target = "chongi_recolored.png")
# we can also use kmeans clustering
recolorize(images[1], method = "kmeans", n = 8)
# you get different clusters each time you run kmeans:
layout(matrix(1:5, nrow = 1))
for (i in 1:5) {
if (i == 1) {kmeans.repeat <- vector("list", 5)}
kmeans.repeat[[i]] <- recolorize(images[3], n = 8,
method = "kmeans",
plotting = FALSE)
plotImageArray(kmeans.repeat[[i]]$recolored.img,
main = paste0("Iteration ", i))
}
kmeans.repeat[[i]] <- recolorize(images[1], n = 8,
method = "kmeans",
plotting = FALSE)
# you get different clusters each time you run kmeans:
layout(matrix(1:5, nrow = 1))
for (i in 1:5) {
if (i == 1) {kmeans.repeat <- vector("list", 5)}
kmeans.repeat[[i]] <- recolorize(images[1], n = 8,
method = "kmeans",
plotting = FALSE)
plotImageArray(kmeans.repeat[[i]]$recolored.img,
main = paste0("Iteration ", i))
}
# you get different clusters each time you run kmeans:
layout(matrix(1:5, nrow = 1))
for (i in 1:5) {
if (i == 1) {kmeans.repeat <- vector("list", 5)}
kmeans.repeat[[i]] <- recolorize(images[1], n = 4,
method = "kmeans",
plotting = FALSE)
plotImageArray(kmeans.repeat[[i]]$recolored.img,
main = paste0("Iteration ", i))
}
# you get different clusters each time you run kmeans:
layout(matrix(1:5, nrow = 1))
for (i in 1:5) {
if (i == 1) {kmeans.repeat <- vector("list", 5)}
kmeans.repeat[[i]] <- recolorize(images[2], n = 4,
method = "kmeans",
plotting = FALSE)
plotImageArray(kmeans.repeat[[i]]$recolored.img,
main = paste0("Iteration ", i))
}
# you get different clusters each time you run kmeans:
layout(matrix(1:5, nrow = 1))
for (i in 1:5) {
if (i == 1) {kmeans.repeat <- vector("list", 5)}
kmeans.repeat[[i]] <- recolorize(images[4], n = 4,
method = "kmeans",
plotting = FALSE)
plotImageArray(kmeans.repeat[[i]]$recolored.img,
main = paste0("Iteration ", i))
}
# you get different clusters each time you run kmeans:
layout(matrix(1:5, nrow = 1))
for (i in 1:5) {
if (i == 1) {kmeans.repeat <- vector("list", 5)}
kmeans.repeat[[i]] <- recolorize(images[5], n = 4,
method = "kmeans",
plotting = FALSE)
plotImageArray(kmeans.repeat[[i]]$recolored.img,
main = paste0("Iteration ", i))
}
# with histograms, it's the same every time
layout(matrix(1:5, nrow = 1))
for (i in 1:5) {
if (i == 1) {hist.repeat <- vector("list", 5)}
hist.repeat[[i]] <- recolorize(images[5], bins = 2,
method = "hist",
plotting = FALSE)
plotImageArray(hist.repeat[[i]]$recolored.img,
main = paste0("Iteration ", i))
}
# compare binning vs. kmeans
for (i in 1:length(images)) {
# kmeans recolor
kmeans.recolor <- recolorize(images[i], method = "kmeans",
n = 8, plotting = FALSE)
# hist recolor
hist.recolor <- recolorize(images[i], method = "hist",
bins = 2, plotting = FALSE)
# plot all three side by side
layout(matrix(c(1:3), ncol = 3))
plotImageArray(kmeans.recolor$original.img, main = "original")
plotImageArray(kmeans.recolor$recolored.img, main = "kmeans")
plotImageArray(hist.recolor$recolored.img, main = "binning")
# pausing
invisible(readline(prompt = "Press [enter] to continue or [esc] to exit"))
}
# imposeColors: you can map an image to custom colors ####
# RGB extremes (white, black, red, green, blue, yellow, magenta, cyan)
ctrs <- matrix(c(1, 1, 1,
0, 0, 0,
1, 0, 0,
0, 1, 0,
0, 0, 1,
1, 1, 0,
1, 0, 1,
0, 1, 1), byrow = TRUE, ncol = 3)
# yuck (but you get the point):
sapply(1:5, function(i) imposeColors(images[i], ctrs,
adjust.centers = FALSE))
# try it out with heliconius:
heliconius <- dir(system.file("extdata", package = "colordistance"),
pattern = "Heliconius",
recursive = TRUE, full.names = TRUE)
# plot them to see what we're working with:
layout(matrix(c(1:8), nrow = 2, byrow = TRUE))
sapply(heliconius, function(i) plotImageArray(readImage(i),
main = basename(i)))
heliconius
install.packages("colordistance")
# try it out with heliconius:
# install.packages("colordistance")
heliconius <- dir(system.file("extdata", package = "colordistance"),
pattern = "Heliconius",
recursive = TRUE, full.names = TRUE)
# plot them to see what we're working with:
layout(matrix(c(1:8), nrow = 2, byrow = TRUE))
sapply(heliconius, function(i) plotImageArray(readImage(i),
main = basename(i)))
# get one set of colors...
# (notice we have to mask the white background)
heliconius.colors <- recolorize(heliconius[7],
lower = rep(0.9, 3), upper = rep(1, 3),
method = "kmeans", n = 3)
# map all the other images to those colors
for (i in 1:length(heliconius)) {
imposeColors(heliconius[i], heliconius.colors$centers,
adjust.centers = FALSE,
lower = rep(0.9, 3), upper = rep(1, 3))
} # not bad!
img_path <- "inst/extdata/chongi.png"
?assignPixels
devtools::load_all(".")
?recolorize::assignPixels
ctrs <- matrix(c(1, 1, 1,
0, 0, 0,
1, 0, 0,
0, 1, 0,
0, 0, 1,
1, 1, 0,
1, 0, 1,
0, 1, 1), byrow = TRUE, ncol = 3)
# plot it
recolorize::plotColorPalette(ctrs)
# create a pixel matrix of random colors
pixel.matrix <- matrix(runif(3000), ncol = 3)
# assign pixels
reassigned <- recolorize::assignPixels(ctrs, pixel.matrix, adjust.centers = TRUE)
recolorize::plotColorPalette(reassigned$centers)
# if we turn off adjust.centers, the colors remain the same as the inputs:
keep.centers <- recolorize::assignPixels(ctrs, pixel.matrix, adjust.centers = FALSE)
recolorize::plotColorPalette(keep.centers$centers)
# I'm not sure this is really as fast as it could be
tmp <- sapply(1:nrow(pixel.matrix),
function(i) apply(color.centers, 1,
function(v) sum((pixel.matrix[i, ]-v)^2)))
color.centers <- matrix(c(1, 1, 1,
0, 0, 0,
1, 0, 0,
0, 1, 0,
0, 0, 1,
1, 1, 0,
1, 0, 1,
0, 1, 1), byrow = TRUE, ncol = 3)
# I'm not sure this is really as fast as it could be
tmp <- sapply(1:nrow(pixel.matrix),
function(i) apply(color.centers, 1,
function(v) sum((pixel.matrix[i, ]-v)^2)))
tmp
dim(tmp)
px <- pixel.matrix[i, ]
px <- pixel.matrix[1, ]
px
v <- color.centers[1, ]
px - v
(px - v)^2
sum((px - v)^2)
sqrt(sum((px - v)^2))
dist(cbind(px, v))
cbind(px, v)
cbind(px, v)
dist(rbind(px, v))
dim(tmp)
# make returnables
pixel.assignments <- max.col(-t(tmp))  # find index of min distance
pixel.assignments
# calculate residuals
sq_residuals <- sapply(1:length(pixel.assignments),
function(j) sum((pixel.matrix[i, ] -
color.centers[pixel.assignments[i], ])^2))
# calculate residuals
sq_residuals <- sapply(1:length(pixel.assignments),
function(j) sum((pixel.matrix[j, ] -
color.centers[pixel.assignments[j], ])^2))
sq_residuals
hist(sq_residuals)
unique(pixel.assignments)
unique(pixel.assignments) %in% 1:nrow(color.centers)
sum(unique(pixel.assignments) %in% 1:nrow(color.centers))
isTRUE(unique(pixel.assignments) %in% 1:nrow(color.centers))
any(unique(pixel.assignments) %in% 1:nrow(color.centers))
any(unique(pixel.assignments) !%in% 1:nrow(color.centers))
any(!unique(pixel.assignments) %in% 1:nrow(color.centers))
any(!runif(50, min = 1, max = 100) %in% 1:nrow(color.centers))
?hist()
devtools::load_all(".")
?colorResiduals
# RGB extremes (white, black, red, green, blue, yellow, magenta, cyan)
ctrs <- matrix(c(1, 1, 1,
0, 0, 0,
1, 0, 0,
0, 1, 0,
0, 0, 1,
1, 1, 0,
1, 0, 1,
0, 1, 1), byrow = TRUE, ncol = 3)
# plot it
recolorize::plotColorPalette(ctrs)
# create a pixel matrix of random colors
pixel.matrix <- matrix(runif(3000), ncol = 3)
# assign pixels
# see `assignPixels` function for details
reassigned <- assignPixels(ctrs, pixel.matrix, adjust.centers = TRUE)
# find residuals from original color centers
color_residuals <- colorResiduals(pixel.matrix = pixel.matrix,
pixel.assignments = reassigned$pixel.assignments,
color.centers = ctrs)
# compare to residuals from adjusted color centers
color_residuals_adjust <- colorResiduals(pixel.matrix = pixel.matrix,
pixel.assignments = reassigned$pixel.assignments,
color.centers = reassigned$centers)
layout(matrix(1:2, nrow = 2))
hist(color_residuals$sq_residuals,
breaks = 50, border = NA, col = "tomato",
main = "Original centers")
hist(color_residuals_adjust$sq_residuals,
breaks = 50, border = NA, col = "cornflowerblue",
main = "Adjusted centers")
?colorResiduals
pixel.matrix <- matrix(runif(3000), ncol = 3)
# assign pixels
# see `assignPixels` function for details
reassigned <- assignPixels(ctrs, pixel.matrix, adjust.centers = TRUE)
# find residuals from original color centers
color_residuals <- colorResiduals(pixel.matrix = pixel.matrix,
pixel.assignments = reassigned$pixel.assignments,
color.centers = ctrs)
# compare to residuals from adjusted color centers
color_residuals_adjust <- colorResiduals(pixel.matrix = pixel.matrix,
pixel.assignments = reassigned$pixel.assignments,
color.centers = reassigned$centers)
layout(matrix(1:2, nrow = 2))
hist(color_residuals$sq_residuals,
breaks = 30, border = NA, col = "tomato",
xlim = c(0, 1), xlab = "Squared residual",
main = "Original centers")
hist(color_residuals_adjust$sq_residuals,
breaks = 30, border = NA, col = "cornflowerblue",
xlim = c(0, 1), xlab = "Squared residual",
main = "Adjusted centers")
?residuals
?hist
devtools::load_all(".")
devtools::load_all(".")
?classifyColorManual
# filepath to image
img <- system.file("extdata/chongi.png", package = "recolorize")
# default: histogram, 2 bins/channel
classifyColorManual(img)
# we can also have different numbers of bins per channel
classifyColorManual(img, bins = c(4, 1, 1)) # mostly red
classifyColorManual(img, bins = c(1, 4, 1)) # mostly green
classifyColorManual(img, bins = c(1, 1, 4)) # mostly blue
# kmeans can produce a better fit with fewer colors
classifyColorManual(img, method = "kmeans", n = 8)
# increasing numbers of kmean colors
recolored.images <- setNames(vector("list", length = 10), c(1:10))
for (i in 1:10) {
recolored.images[[i]] <- classifyColorManual(img, method = "kmeans",
n = i)
}
layout(matrix(1:10, nrow = 2))
lapply(recolored.images,
function(i) hist(i$color.residuals$sq_residuals,
border = NA, main = paste(i, "clusters")), freq = FALSE,
xlim = c(0, 1))
recolored.images$1
recolored.images
recolored.images$1
as.character(c(1:10))
as.character(c(1:10))
# increasing numbers of kmean colors
recolored.images <- setNames(vector("list", length = 10),
as.character(c(1:10)))
for (i in 1:10) {
recolored.images[[i]] <- classifyColorManual(img, method = "kmeans",
n = i)
}
recolored.images$1
# increasing numbers of kmean colors
recolored.images <- setNames(vector("list", length = 10),
as.character(c(1:10)))
recolored.images
for (i in 1:10) {
recolored.images[[i]] <- classifyColorManual(img, method = "kmeans",
n = i)
}
# increasing numbers of kmean colors
recolored.images <- setNames(vector("list", length = 10))
# increasing numbers of kmean colors
recolored.images <- vector("list", length = 10)
for (i in 1:10) {
recolored.images[[i]] <- classifyColorManual(img, method = "kmeans",
n = i)
}
layout(matrix(1:10, nrow = 2))
lapply(recolored.images,
function(i) hist(i$color.residuals$sq_residuals,
border = NA, main = paste(i, "clusters")), freq = FALSE,
xlim = c(0, 1))
recolored.images[[1]]
recolored.images[[1]]$color.residuals$sq_residuals
lapply(recolored.images, function(i) hist(i$color.residuals$sq_residuals))
lapply(recolored.images,
function(i) hist(i$color.residuals$sq_residuals))
lapply(recolored.images,
function(i) hist(i$color.residuals$sq_residuals,
border = NA))
lapply(recolored.images,
function(i) hist(i$color.residuals$sq_residuals,
border = NA, main = paste(i, "clusters")))
lapply(recolored.images,
function(i) hist(i$color.residuals$sq_residuals,
border = NA, main = paste(i, "clusters")))
sapply(1:length(recolored.images),
function(i) hist(recolored.images[[i]]$color.residuals$sq_residuals,
border = NA, main = paste(i, "clusters")))
layout(matrix(1:10, nrow = 2))
sapply(1:length(recolored.images),
function(i) hist(recolored.images[[i]]$color.residuals$sq_residuals,
border = NA, main = paste(i, "clusters")))
sapply(1:length(recolored.images),
function(i) hist(recolored.images[[i]]$color.residuals$sq_residuals,
border = NA, main = paste(i, "cluster(s)"),
freq = FALSE, xlim = c(0, 1)))
layout(matrix(1:10, nrow = 2, byrow = TRUE))
sapply(1:length(recolored.images),
function(i) hist(recolored.images[[i]]$color.residuals$sq_residuals,
border = NA, main = paste(i, "cluster(s)"),
freq = FALSE, xlim = c(0, 1)))
sapply(1:length(recolored.images),
function(i) hist(recolored.images[[i]]$color.residuals$sq_residuals,
border = NA, main = paste(i, "cluster(s)"),
freq = FALSE, xlab = "Squared residual",
xlim = c(0, 1)), ylim = c(0, 50))
sapply(1:length(recolored.images),
function(i) hist(recolored.images[[i]]$color.residuals$sq_residuals,
border = NA, main = paste(i, "cluster(s)"),
freq = FALSE, xlab = "Squared residual",
xlim = c(0, 1)))
residual_vec <- sapply(1:length(recolored.images),
function(i) recolored.images[[i]]$color.residuals$tot_residuals)
plot(residual_vec, type = 'b')
plot(residual_vec, type = 'b')
devtools::load_all(".")
?colorResiduals
?classifyColorManual
plot(residual_vec, type = 'b',
ylab = "Sum of squared residuals",
xlab = "Cluster number")
