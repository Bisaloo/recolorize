if (!quietly) {
message("Clustering all pixels (no background masking)")
}
}
}
backgroundCondition()
backgroundCondition(lower = NULL, upper = NULL,
center = NULL, radius = NULL,
alpha.channel = FALSE,
transparent = NULL, quietly = TRUE)
args.list <- as.list(match.call())
match.call()
?match.arg
match.call(get, call("get", "abc", i = FALSE, p = 3))
args.list <- as.list(match.call())
# bg.condition can be one of EITHER:
# list with attributes "lower" and "upper"
# list with attributes "center" and "radius"
# "transparent"
# anything else will be parsed as no background masking and all pixels will be
# returned as non-background
# ex: backgroundCondition(lower = rep(0, 3), upper = rep(0.2, 3))
backgroundCondition <- function(lower = NULL, upper = NULL,
center = NULL, radius = NULL,
alpha.channel = FALSE,
transparent = NULL, quietly = TRUE) {
args.list <- as.list(match.call())
message(sum(lapply(args.list, is.null)))
if (!is.null(lower) & !is.null(upper)) {
bg.condition <- list(lower = lower, upper = upper)
class(bg.condition) <- "bg.rect"
} else if (!is.null(center) & !is.null(radius)) {
bg.condition <- list(center = center, radius = radius)
class(bg.condition) <- "bg.sphere"
} else if (!is.null(transparent)) {
bg.condition <- "transparent"
class(bg.condition) <- "bg.t"
} else {
bg.condition <- NA
class(bg.condition) <- "bg.none"
if (!quietly) {
message("Clustering all pixels (no background masking)")
}
}
return(bg.condition)
}
backgroundCondition()
# bg.condition can be one of EITHER:
# list with attributes "lower" and "upper"
# list with attributes "center" and "radius"
# "transparent"
# anything else will be parsed as no background masking and all pixels will be
# returned as non-background
# ex: backgroundCondition(lower = rep(0, 3), upper = rep(0.2, 3))
backgroundCondition <- function(lower = NULL, upper = NULL,
center = NULL, radius = NULL,
alpha.channel = FALSE,
transparent = NULL, quietly = TRUE) {
args.list <- as.list(match.call())
nullsum <- lapply(args.list, is.null)
message(sum(unlist(nullsum)))
if (!is.null(lower) & !is.null(upper)) {
bg.condition <- list(lower = lower, upper = upper)
class(bg.condition) <- "bg.rect"
} else if (!is.null(center) & !is.null(radius)) {
bg.condition <- list(center = center, radius = radius)
class(bg.condition) <- "bg.sphere"
} else if (!is.null(transparent)) {
bg.condition <- "transparent"
class(bg.condition) <- "bg.t"
} else {
bg.condition <- NA
class(bg.condition) <- "bg.none"
if (!quietly) {
message("Clustering all pixels (no background masking)")
}
}
return(bg.condition)
}
backgroundCondition()
args.list <- list(lower = NULL, upper = NULL,
center = NULL, radius = NULL,
alpha.channel = FALSE,
transparent = NULL, quietly = TRUE)
lapply(args.list, is.null)
lapply(args.list, is.null) %>%unlist %>% sum()
args.list <- as.list(lower = lower, upper = upper,
center = center, radius = radius,
transparent = transparent)
args.list <- lapply(args.list, is.null)
args.list <- list(lower = lower, upper = upper,
center = center, radius = radius,
transparent = transparent)
args.list <- lapply(args.list, is.null)
center = NULL
radius = NULL
transparent= NULL
args.list <- list(lower = lower, upper = upper,
center = center, radius = radius,
transparent = transparent)
args.list
args.list <- lapply(args.list, is.null)
args.list
# put potential background conditions into a list
args.list <- list(lower = lower, upper = upper,
center = center, radius = radius,
transparent = transparent)
null.count <- unlist(lapply(args.list, is.null))
null.count
null.count <- which(unlist(lapply(args.list, is.null)))
null.count
combos <- list(c(5),
c(1, 2), c(3, 4),
c(1, 2, 5), c(3, 4, 5))
match(null.count, combos)
combos
?match
null.count == c(1, 2, 5)
match(null.count, args.list)
match(null.count, null.count)
match(null.count, combos)
match(combos, null.count)
match(combos, null.count)
null.count
combos
# count which of them are null
null.count <- which(unlist(lapply(args.list, is.null)))
# put potential background conditions into a list
args.list <- list(lower = lower, upper = upper,
center = center, radius = radius,
transparent = transparent)
# bg.condition can be one of EITHER:
# list with attributes "lower" and "upper"
# list with attributes "center" and "radius"
# "transparent"
# anything else will be parsed as no background masking and all pixels will be
# returned as non-background
# ex: backgroundCondition(lower = rep(0, 3), upper = rep(0.2, 3))
backgroundCondition <- function(lower = NULL, upper = NULL,
center = NULL, radius = NULL,
transparent = NULL,
alpha.channel = FALSE,
quietly = TRUE) {
# put potential background conditions into a list
args.list <- list(lower = lower, upper = upper,
center = center, radius = radius,
transparent = transparent)
# count which of them are null
null.count <- which(unlist(lapply(args.list, is.null)))
# these combinations are allowed:
combos <- list(c(5),
c(1, 2), c(3, 4),
c(1, 2, 5), c(3, 4, 5))
# allowable combinations:
# transparent
# lower + upper
# center + radius
# lower + upper + transparent
# center + radius + transparent
nullsum <- lapply(args.list, is.null)
message(sum(unlist(nullsum)))
if (!is.null(lower) & !is.null(upper)) {
bg.condition <- list(lower = lower, upper = upper)
class(bg.condition) <- "bg.rect"
} else if (!is.null(center) & !is.null(radius)) {
bg.condition <- list(center = center, radius = radius)
class(bg.condition) <- "bg.sphere"
} else if (!is.null(transparent)) {
bg.condition <- "transparent"
class(bg.condition) <- "bg.t"
} else {
bg.condition <- NA
class(bg.condition) <- "bg.none"
if (!quietly) {
message("Clustering all pixels (no background masking)")
}
}
return(bg.condition)
}
args.list <- list(lower = NULL, upper = NULL,
center = NULL, radius = NULL,
transparent = NULL)
# count which of them are null
null.count <- which(unlist(lapply(args.list, is.null)))
null.count
paste0(null.count. collapse = "")
paste0(null.count, collapse = "")
paste(null.count, collapse = "")
lapply(combos, function(i) paste(i, collapse = ""))
# these combinations are allowed:
combos <- list(c(5),
c(1, 2), c(3, 4),
c(1, 2, 5), c(3, 4, 5))
lapply(combos, function(i) paste(i, collapse = ""))
match(null.count, combos)
unlist(combos)
combos <-  lapply(combos, function(i) paste(i, collapse = ""))
combos
match(null.count, combos)
combos
unlist(combos)
# these combinations are allowed:
combos <- list(c(5),
c(1, 2), c(3, 4),
c(1, 2, 5), c(3, 4, 5))
combos <- unlist(lapply(combos,
function(i) paste(i, collapse = "")))
match(null.count, combos)
combos
null.count
null.count <- paste(null.count, collapse = "")
match(null.count, combos)
null.count %in% combos
combos %in% null.count
args.list$lower <- rep(0.95, 0.95, 0)
args.list$lower <- rep(1, 3)
args.list$lower <- rep(.9, 3)
args.list$upper <- rep(1, 3)
null.count <- paste(null.count, collapse = "")
# these combinations are allowed:
combos <- list(c(5),
c(1, 2), c(3, 4),
c(1, 2, 5), c(3, 4, 5))
combos <- unlist(lapply(combos,
function(i) paste(i, collapse = "")))
null.count %in% combos
null.count
# count which of them are null
null.count <- which(unlist(lapply(args.list, is.null)))
null.count <- paste(null.count, collapse = "")
# these combinations are allowed:
combos <- list(c(5),
c(1, 2), c(3, 4),
c(1, 2, 5), c(3, 4, 5))
combos <- unlist(lapply(combos,
function(i) paste(i, collapse = "")))
null.count %in% combos
!null.count %in% combos
# make a vector of which values are NULL
null.count <- which(unlist(lapply(args.list, is.null)))
null.count <- paste(null.count, collapse = "")
# these combinations are allowed:
combos <- list(transparent = c(5),
rect = c(1, 2), sphere = c(3, 4),
t.rect = c(1, 2, 5), t.sphere = c(3, 4, 5))
combo.vecs <- unlist(lapply(combos,
function(i) paste(i, collapse = "")))
if (!null.count %in% combo.vecs)
{}
null.count %in% combo.vecs
null.count
combo.vecs
match(null.count, combo.vecs)
null.count
args.list
# make a vector of which values are NULL
null.count <- which(unlist(lapply(args.list, is.null)))
nulll.count
null.count
# make a vector of which values are NULL
null.count <- which(unlist(lapply(args.list, !is.null)))
lapply(args.list, !is.null)
!lapply(args.list, is.null)
unlist(lapply(args.list, is.null))
!unlist(lapply(args.list, is.null))
# make a vector of which values are NOT NULL
null.count <- which(!unlist(lapply(args.list, is.null)))
null.count <- paste(null.count, collapse = "")
# these combinations are allowed:
combos <- list(transparent = c(5),
rect = c(1, 2), sphere = c(3, 4),
t.rect = c(1, 2, 5), t.sphere = c(3, 4, 5))
combo.vecs <- unlist(lapply(combos,
function(i) paste(i, collapse = "")))
match(null.count, combo.vecs)
combo.vecs
args.list$lower == NULL
args.list$lower = NULL
# make a vector of which values are NOT NULL
null.count <- which(!unlist(lapply(args.list, is.null)))
null.count <- paste(null.count, collapse = "")
# these combinations are allowed:
combos <- list(transparent = c(5),
rect = c(1, 2), sphere = c(3, 4),
t.rect = c(1, 2, 5), t.sphere = c(3, 4, 5))
combo.vecs <- unlist(lapply(combos,
function(i) paste(i, collapse = "")))
match(null.count, combo.vecs)
args.list <- list(lower = NULL, upper = NULL,
center = NULL, radius = NULL,
transparent = NULL)
# make a vector of which values are NOT NULL
null.count <- which(!unlist(lapply(args.list, is.null)))
null.count <- paste(null.count, collapse = "")
null.count
# these combinations are allowed:
combos <- list(transparent = "5", none = "",
rect = "12", sphere = "34",
t.rect = "125", t.sphere = "345")
# do the supplied arguments fit one of these combinations?
category.idx <- match(null.count, combos)
category.idx
combos
combos[[2]]
combos[2]
match("345", combos)
# these combinations are allowed:
combos <- data.frame(vec = c("",
"12", "34",
"5", "125", "345"),
category = c("none",
"rect", "sphere",
rep("transparent", 3)))
combos
# do the supplied arguments fit one of these combinations?
category.idx <- match(null.count, combos$vec)
category.idx
msg <- paste("Masking pixels in range:\n",
paste("R: ", paste(lower[1], "-", upper[1], sep = ""),
"; G: ", paste(lower[2], "-", upper[2], sep = ""),
"; B: ", paste(lower[3], "-", upper[3], sep = ""),
sep = ""))
lower = rep(1, 3)
upper = rep(1, 3)
msg <- paste("Masking pixels in range:\n",
paste("R: ", paste(lower[1], "-", upper[1], sep = ""),
"; G: ", paste(lower[2], "-", upper[2], sep = ""),
"; B: ", paste(lower[3], "-", upper[3], sep = ""),
sep = ""))
msg
msg <- message("Masking pixels in range:\n",
paste("R: ", paste(lower[1], "-", upper[1], sep = ""),
"; G: ", paste(lower[2], "-", upper[2], sep = ""),
"; B: ", paste(lower[3], "-", upper[3], sep = ""),
sep = ""))
msg <- paste("Masking pixels in range:\n",
paste("R: ", paste(lower[1], "-", upper[1], sep = ""),
"; G: ", paste(lower[2], "-", upper[2], sep = ""),
"; B: ", paste(lower[3], "-", upper[3], sep = ""),
sep = ""))
message(msg)
devtools::load_all(".")
backgroundCondition(lower = rep(0, 3), upper = rep(0.2, 3))
backgroundCondition(lower = "yes")
backgroundCondition(lower = "yes", quietly = FALSE)
backgroundCondition()
# bg.condition can be one of EITHER:
# list with attributes "lower" and "upper"
# list with attributes "center" and "radius"
# "transparent"
# anything else will be parsed as no background masking and all pixels will be
# returned as non-background
# ex: backgroundCondition(lower = rep(0, 3), upper = rep(0.2, 3))
backgroundCondition <- function(lower = NULL, upper = NULL,
center = NULL, radius = NULL,
transparent = NULL,
alpha.channel = FALSE,
quietly = TRUE) {
# put potential background conditions into a list
args.list <- list(lower = lower, upper = upper,
center = center, radius = radius,
transparent = transparent)
# make a vector of which values are NOT NULL
null.count <- which(!unlist(lapply(args.list, is.null)))
null.count <- paste(null.count, collapse = "")
# these combinations are allowed:
combos <- data.frame(vec = c("",
"12", "34",
"5", "125", "345"),
category = c("none",
"rect", "sphere",
rep("transparent", 3)))
# do the supplied arguments fit one of these combinations?
category.idx <- match(null.count, combos$vec)
# if they don't, mask nothing
if (is.na(category.idx)) {
warning("Could not parse background parameters; no pixels will be masked")
category <- "none"
} else {
# otherwise, we have our bg category!
category <- combos$category[category.idx]
}
# for each category: define background condition
# classify it
# provide message if quietly = FALSE
if (category == "transparent") {
bg.condition <- "transparent"
class(bg.condition) <- "bg.t"
msg <- "Using transparency to mask pixels"
} else if (category == "rect") {
bg.condition <- list(lower = lower, upper = upper)
class(bg.condition) <- "bg.rect"
msg <- paste("Masking pixels in range:\n",
paste("R: ", paste(lower[1], "-", upper[1], sep = ""),
"; G: ", paste(lower[2], "-", upper[2], sep = ""),
"; B: ", paste(lower[3], "-", upper[3], sep = ""),
sep = ""))
} else if (category == "sphere") {
bg.condition <- list(center = center, radius = radius)
class(bg.condition) <- "bg.sphere"
msg <- paste("Masking pixels in range:\n",
paste("Center: ", paste(center[i, ], collapse = ", "),
" +/- ", radius[i] * 100, "%", sep = ""))
} else if (category == "none") {
bg.condition <- NA
class(bg.condition) <- "bg.none"
msg <- "Using all pixels"
} else {
stop("you lost me, bud")
}
# print message
if (!quietly) { message(msg) }
# return background
return(bg.condition)
}
backgroundCondition()
backgroundCondition(quietly = F)
# fxn 1: 3d array in -> flat array + dimensions out
# 1. start with 3D RGB array m x n x 3
# 2. flatten it to 2D matrix of (m*n)x3
img <- png::readPNG("inst/extdata/chongi_transparent.png")
imdims <- dim(img)
# fxn 1: 3d array in -> flat array + dimensions out
# 1. start with 3D RGB array m x n x 3
# 2. flatten it to 2D matrix of (m*n)x3
img <- png::readPNG("inst/extdata/chongi_transparent.png")
imdims <- dim(img)
flattened.img <- img
dim(flattened.img) <- c(imdims[1]*imdims[2], imdims[3])
# fxn 2: flat array + condition in -> original, index + non-bg out
# 3a. bg mask: get index of bg pixels
# 3b. make non-bg-only pixel matrix for operations
# 3c. convert to color space of choice
bg.condition <- backgroundCondition(transparent = TRUE)
bg.condition
# fxn 2: flat array + condition in -> original, index + non-bg out
# 3a. bg mask: get index of bg pixels
# 3b. make non-bg-only pixel matrix for operations
# 3c. convert to color space of choice
bg.condition <- backgroundCondition(transparent = TRUE,
lower = rep(0, 3), upper = rep(1, 3))
bg.condition
bg.indexed <- backgroundIndex(flattened.img = flattened.img, bg.condition = bg.condition)
bg.indexed$non.bg %>% dim()
library(magrittr)
bg.indexed$non.bg %>% dim()
?convertColor()
pixel.matrix <- bg.indexed$non.bg
dim(pixel.matrix)
pixel.matrix[,4]
test <- pixel.matrix[,1:4]
img.k <- stats::kmeans(pixel.matrix, n)
n = 10
img.k <- stats::kmeans(pixel.matrix, n)
img.k$cluster %>% length()
img.k$cluster %>% dim()
img.k$centers
# we don't care about the alpha channel; remove if present
pixel.matrix <- pixel.matrix[ , 1:3]
img.k <- stats::kmeans(pixel.matrix, n)
img.k$centers
match.arg()
?match.arg()
match.arg("men", choices = c("mean", "median", "trimmed"))
?switch
match.arg("mean", choices = c("mean", "median", "trimmed"))
match.arg("Mean", choices = c("mean", "median", "trimmed"))
match.arg("med", choices = c("mean", "median", "trimmed"))
match.arg(tolower(method), c("kmeans", "histogram"))
method = "kmeans"
match.arg(tolower(method), c("kmeans", "histogram"))
match.arg("hist", c("kmeans", "histogram"))
devtools::load_all(".")
# fxn 3: non-bg pixels in -> centers out
# 4. find centers -- either thru histogram or kmeans
img.clusters <- colorClusters(bg.indexed$non.bg, method = "hist")
# fxn 3: non-bg pixels in -> centers out
# 4. find centers -- either thru histogram or kmeans
img.clusters <- colorClusters(bg.indexed$non.bg, method = "hist")
# fxn 3: non-bg pixels in -> centers out
# 4. find centers -- either thru histogram or kmeans
img.clusters <- colorClusters(bg.indexed$non.bg, method = "k")
# fxn 4:
# in: non-bg + assignments + centers
# out: recolored pixels
# 5. assign pixels to centers / recolor them
pix.recolor <- bg.indexed$non.bg
for (i in 1:nrow(img.clusters$centers)) {
new.color <- img.clusters$centers[i, ]
pix.idx <- which(img.clusters$cluster == i)
replacements <- matrix(new.color, ncol = 3, byrow = TRUE,
nrow = length(pix.idx))
pix.recolor[pix.idx, 1:3] <- replacements
}
nrow(img.clusters$centers)
# fxn 4:
# in: non-bg + assignments + centers
# out: recolored pixels
# 5. assign pixels to centers / recolor them
pix.recolor <- bg.indexed$non.bg
new.color <- img.clusters$centers[i, ]
pix.idx <- which(img.clusters$cluster == i)
pix.idx
for (i in 1:nrow(img.clusters$centers)) {
new.color <- img.clusters$centers[i, ]
pix.idx <- which(img.clusters$pixel.assignments == i)
replacements <- matrix(new.color, ncol = 3, byrow = TRUE,
nrow = length(pix.idx))
pix.recolor[pix.idx, 1:3] <- replacements
}
img.clusters$centers
names(bg.indexed)
