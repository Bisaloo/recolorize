n_final = NULL
# form groups
clust_groups <- stats::cutree(hc, k = n_final,
h = similarity_cutoff)
merge_list <- lapply(unique(clust_groups),
function(i) which(clust_groups == i))
merge_list
# doop doop:
final_fit <- mergeLayers(init_fit,
merge_list = merge_list,
plotting = FALSE)
final_fit$sizes
?mergeLayers
# image path:
img <- system.file("extdata/corbetti.png", package = "recolorize")
# initial fit, 8 bins:
init_fit <- recolorize(img)
# redundant green, red, and blue clusters
milkweed_impostor <- mergeLayers(init_fit,
merge_list = list(c(2:8)),
color_to = "orange")
milkweed_impostor$sizes
init_fit$centers
init_fit$sizes
init_fit <- recolorize(img, bins = 4)
# first, ignore empty clusters -- they're not informative
sizes <- init_fit$sizes
centers <- init_fit$centers
# if any are empty, remove them
if (any(sizes == 0)) {
zero_idx <- which(sizes == 0)
sizes <- sizes[-zero_idx]
centers <- init_fit$centers[-zero_idx, ]
}
# convert to Lab space for better clustering
lab_init <- col2col(centers,
from = "sRGB",
to = color_space,
ref_white = ref_white)
# get distance matrix
d <- stats::dist(lab_init)
# perform clustering
# hc <- hclust(d / max(d))
hc <- stats::hclust(d)
graphics::par(mfrow = c(1, 1), mar = c(1, 3, 3, 1))
plot(hc, xlab = "")
# plot cutoff value if provided:
if (is.null(n_final)) {
graphics::abline(h = similarity_cutoff, lty = 2, col = "red")
}
# form groups
clust_groups <- stats::cutree(hc, k = n_final,
h = similarity_cutoff)
merge_list <- lapply(unique(clust_groups),
function(i) which(clust_groups == i))
merge_list
# doop doop:
final_fit <- mergeLayers(init_fit,
merge_list = merge_list,
plotting = FALSE)
final_fit$sizes
plot(final_fit)
color_to= "weighted_average"
# check parameters
pm <- clean_merge_params(recolorize_obj,
merge_list,
color_to)
recolorize_obj <- init_fit
# check parameters
pm <- clean_merge_params(recolorize_obj,
merge_list,
color_to)
merge_list <- pm$merge_list
color_to <- pm$color_to
# convert recolored image to a cimg object
cimg_obj <- array_to_cimg(recolorize_obj$recolored_img,
flatten_alpha = T)
# split the layers
layers <- splitByColor(recolorize_obj,
plot_method = "none")
# get centers and sizes
centers <- recolorize_obj$centers
sizes <- recolorize_obj$sizes
centers
sizes
merge_list
# check parameters
pm <- clean_merge_params(recolorize_obj,
merge_list,
color_to)
merge_list <- pm$merge_list
color_to <- pm$color_to
# convert recolored image to a cimg object
cimg_obj <- array_to_cimg(recolorize_obj$recolored_img,
flatten_alpha = T)
# split the layers
layers <- splitByColor(recolorize_obj,
plot_method = "none")
# get centers and sizes
centers <- recolorize_obj$centers
sizes <- recolorize_obj$sizes
size
sizes
# get the list of untouched layers
orig_layers <- which(!(1:length(layers) %in% unlist(merge_list)))
new_centers <- centers[orig_layers, ]
new_sizes <- sizes[orig_layers]
px_assign <- recolorize_obj$pixel_assignments
if (length(orig_layers) > 0) {
for (i in 1:length(orig_layers)) {
px_assign[which(recolorize_obj$pixel_assignments ==
orig_layers[i])] <- i
}
}
# for every element of merge list...
for (i in 1:length(merge_list)) {
# get the vector of colors to combine
merge_vector <- merge_list[[i]]
# extract the first layer
layer <- layers[[merge_vector[1]]]
# get the new color:
col_to <- color_to[i]
if (col_to == "weighted average") {
if (length(merge_vector) > 1) {
col_to <- apply(centers[merge_vector, ], 2,
function(j) stats::weighted.mean(j,
sizes[merge_vector]))
} else {
col_to <- centers[merge_vector, ]
}
} else {
col_to <- color_to[i]
col_to <- as.vector(grDevices::col2rgb(col_to) / 255)
}
# add the other layers
# this is silly but doesn't seem that slow
if (length(merge_vector) > 1) {
for (j in 2:length(merge_vector)) {
layer <- layer + layers[[merge_vector[j]]]
}
}
# add new center & size values
new_centers <- rbind(new_centers, col_to)
new_sizes <- c(new_sizes, sum(sizes[merge_vector]))
# change pixel assignments
idx <- which(recolorize_obj$pixel_assignments %in% merge_vector)
px_assign[idx] <- length(orig_layers) + i
# convert to pixset
layer <- imager::as.pixset(imager::as.cimg(layer))
# and recolor (setting alpha)
cimg_obj <- imager::colorise(cimg_obj, layer, col_to)
}
col_to == "weighted average"
col_to = "weighted average"
# for every element of merge list...
for (i in 1:length(merge_list)) {
# get the vector of colors to combine
merge_vector <- merge_list[[i]]
# extract the first layer
layer <- layers[[merge_vector[1]]]
# get the new color:
col_to <- color_to[i]
if (col_to == "weighted average") {
if (length(merge_vector) > 1) {
col_to <- apply(centers[merge_vector, ], 2,
function(j) stats::weighted.mean(j,
sizes[merge_vector]))
} else {
col_to <- centers[merge_vector, ]
}
} else {
col_to <- color_to[i]
col_to <- as.vector(grDevices::col2rgb(col_to) / 255)
}
# add the other layers
# this is silly but doesn't seem that slow
if (length(merge_vector) > 1) {
for (j in 2:length(merge_vector)) {
layer <- layer + layers[[merge_vector[j]]]
}
}
# add new center & size values
new_centers <- rbind(new_centers, col_to)
new_sizes <- c(new_sizes, sum(sizes[merge_vector]))
# change pixel assignments
idx <- which(recolorize_obj$pixel_assignments %in% merge_vector)
px_assign[idx] <- length(orig_layers) + i
# convert to pixset
layer <- imager::as.pixset(imager::as.cimg(layer))
# and recolor (setting alpha)
cimg_obj <- imager::colorise(cimg_obj, layer, col_to)
}
color_to
i
# get the vector of colors to combine
merge_vector <- merge_list[[i]]
# extract the first layer
layer <- layers[[merge_vector[1]]]
# get the new color:
col_to <- color_to[i]
if (col_to == "weighted average") {
if (length(merge_vector) > 1) {
col_to <- apply(centers[merge_vector, ], 2,
function(j) stats::weighted.mean(j,
sizes[merge_vector]))
} else {
col_to <- centers[merge_vector, ]
}
} else {
col_to <- color_to[i]
col_to <- as.vector(grDevices::col2rgb(col_to) / 255)
}
# get the new color:
col_to <- color_to[i]
col_to == "weighted average"
color_to
color_to <- "weighted average"
# check parameters
pm <- clean_merge_params(recolorize_obj,
merge_list,
color_to)
merge_list <- pm$merge_list
color_to <- pm$color_to
# convert recolored image to a cimg object
cimg_obj <- array_to_cimg(recolorize_obj$recolored_img,
flatten_alpha = T)
# split the layers
layers <- splitByColor(recolorize_obj,
plot_method = "none")
# get centers and sizes
centers <- recolorize_obj$centers
sizes <- recolorize_obj$sizes
# get the list of untouched layers
orig_layers <- which(!(1:length(layers) %in% unlist(merge_list)))
new_centers <- centers[orig_layers, ]
new_sizes <- sizes[orig_layers]
px_assign <- recolorize_obj$pixel_assignments
if (length(orig_layers) > 0) {
for (i in 1:length(orig_layers)) {
px_assign[which(recolorize_obj$pixel_assignments ==
orig_layers[i])] <- i
}
}
# for every element of merge list...
for (i in 1:length(merge_list)) {
# get the vector of colors to combine
merge_vector <- merge_list[[i]]
# extract the first layer
layer <- layers[[merge_vector[1]]]
# get the new color:
col_to <- color_to[i]
if (col_to == "weighted average") {
if (length(merge_vector) > 1) {
col_to <- apply(centers[merge_vector, ], 2,
function(j) stats::weighted.mean(j,
sizes[merge_vector]))
} else {
col_to <- centers[merge_vector, ]
}
} else {
col_to <- color_to[i]
col_to <- as.vector(grDevices::col2rgb(col_to) / 255)
}
# add the other layers
# this is silly but doesn't seem that slow
if (length(merge_vector) > 1) {
for (j in 2:length(merge_vector)) {
layer <- layer + layers[[merge_vector[j]]]
}
}
# add new center & size values
new_centers <- rbind(new_centers, col_to)
new_sizes <- c(new_sizes, sum(sizes[merge_vector]))
# change pixel assignments
idx <- which(recolorize_obj$pixel_assignments %in% merge_vector)
px_assign[idx] <- length(orig_layers) + i
# convert to pixset
layer <- imager::as.pixset(imager::as.cimg(layer))
# and recolor (setting alpha)
cimg_obj <- imager::colorise(cimg_obj, layer, col_to)
}
# thbbt
rownames(new_centers) <- NULL
# convert back to array and add alpha channel
# i have LEARNED MY LESSON with imager alpha channels
# (highly unpredictable behavior)
as_array <- cimg_to_array(cimg_obj)
as_array <- abind::abind(as_array,
recolorize_obj$recolored_img[ , , 4],
along = 3)
# reconstruct the recolorize obj
merged_obj <- recolorize_obj
merged_obj$recolored_img <- as_array
merged_obj$method <- paste("merged", merged_obj$method)
merged_obj$centers <- new_centers
merged_obj$sizes <- new_sizes
merged_obj$pixel_assignments <- px_assign
which(new_sizes == 0)
devtools::load_all(".")
# and refit:
final_fit <- imposeColors(init_fit$original_img,
centers = new_centers,
plotting = FALSE)
plot(final_fit)
final_fit$centers
final_fit$sizes
new_centers[-which(new_sizes == 0), ]
new_sizes[-which(new_sizes == 0)]
devtools::load_all(".")
# doop doop:
final_fit <- mergeLayers(init_fit,
merge_list = merge_list,
plotting = FALSE)
plot(final_fit)
final_fit$centers
init_fit <- recolorize(img, bins = 4)
# first, ignore empty clusters -- they're not informative
sizes <- init_fit$sizes
centers <- init_fit$centers
# if any are empty, remove them
if (any(sizes == 0)) {
zero_idx <- which(sizes == 0)
sizes <- sizes[-zero_idx]
centers <- init_fit$centers[-zero_idx, ]
}
# convert to Lab space for better clustering
lab_init <- col2col(centers,
from = "sRGB",
to = color_space,
ref_white = ref_white)
# get distance matrix
d <- stats::dist(lab_init)
# perform clustering
# hc <- hclust(d / max(d))
hc <- stats::hclust(d)
graphics::par(mfrow = c(1, 1), mar = c(1, 3, 3, 1))
plot(hc, xlab = "")
# plot cutoff value if provided:
if (is.null(n_final)) {
graphics::abline(h = similarity_cutoff, lty = 2, col = "red")
}
# plot clustering:
if (plot_hclust) {
graphics::par(mfrow = c(1, 1), mar = c(1, 3, 3, 1))
plot(hc, xlab = "")
# plot cutoff value if provided:
if (is.null(n_final)) {
graphics::abline(h = similarity_cutoff, lty = 2, col = "red")
}
}
# form groups
clust_groups <- stats::cutree(hc, k = n_final,
h = similarity_cutoff)
merge_list <- lapply(unique(clust_groups),
function(i) which(clust_groups == i))
merge_list
# doop doop:
final_fit <- mergeLayers(init_fit,
merge_list = merge_list,
plotting = FALSE)
plot(final_fit)
final_fit$centers
final_fit$sizes
test <- constructImage(final_fit$pixel_assignments, final_fit$centers)
plot(test)
plotImageArray(test)
final_fit$centers
range(test)
?constructImage
hist(test)
hist(test)
hist(test, breaks = 50)
plotImageArray(final_fit$pixel_assignments / 15)
plotImageArray(final_fit$pixel_assignments / 16)
plotImageArray(final_fit$pixel_assignments / 17)
plotImageArray(final_fit$pixel_assignments / 27)
hist(final_fit$pixel_assignments)
hist(final_fit$pixel_assignments)
merge_list
recolorize_obj
hist(recolorize_obj$pixel_assignments)
merge_list
length(merge_list)
# check parameters
pm <- clean_merge_params(recolorize_obj,
merge_list,
color_to)
merge_list <- pm$merge_list
color_to <- pm$color_to
color_to
# convert recolored image to a cimg object
cimg_obj <- array_to_cimg(recolorize_obj$recolored_img,
flatten_alpha = T)
# split the layers
layers <- splitByColor(recolorize_obj,
plot_method = "none")
# get centers and sizes
centers <- recolorize_obj$centers
sizes <- recolorize_obj$sizes
centers
sizes
# get the list of untouched layers
orig_layers <- which(!(1:length(layers) %in% unlist(merge_list)))
orig_layers
new_centers <- centers[orig_layers, ]
new_sizes <- sizes[orig_layers]
px_assign <- recolorize_obj$pixel_assignments
new_sizes
ength(orig_layers) > 0
length(orig_layers) > 0
# if any layers are going untouched...
if (length(orig_layers) > 0) {
for (i in 1:length(orig_layers)) {
# copy their pixel assignments:
px_assign[which(recolorize_obj$pixel_assignments ==
orig_layers[i])] <- i
}
}
length(orig_layers) > 0 & sum(new_sizes) > 0
# get the list of untouched layers
orig_layers <- which(!(1:length(layers) %in% unlist(merge_list)))
new_centers <- centers[orig_layers, ]
new_sizes <- sizes[orig_layers]
px_assign <- recolorize_obj$pixel_assignments
# if any layers are going untouched...
if (length(orig_layers) > 0) {
for (i in 1:length(orig_layers)) {
# copy their pixel assignments:
px_assign[which(recolorize_obj$pixel_assignments ==
orig_layers[i])] <- i
}
}
merge_list
merge_list
# for every element of merge list...
for (i in 1:length(merge_list)) {
# get the vector of colors to combine
merge_vector <- merge_list[[i]]
# extract the first layer
layer <- layers[[merge_vector[1]]]
# get the new color:
col_to <- color_to[i]
if (col_to == "weighted average") {
if (length(merge_vector) > 1) {
col_to <- apply(centers[merge_vector, ], 2,
function(j) stats::weighted.mean(j,
sizes[merge_vector]))
} else {
col_to <- centers[merge_vector, ]
}
} else {
col_to <- color_to[i]
col_to <- as.vector(grDevices::col2rgb(col_to) / 255)
}
# add the other layers
# this is silly but doesn't seem that slow
if (length(merge_vector) > 1) {
for (j in 2:length(merge_vector)) {
layer <- layer + layers[[merge_vector[j]]]
}
}
# add new center & size values
new_centers <- rbind(new_centers, col_to)
new_sizes <- c(new_sizes, sum(sizes[merge_vector]))
# change pixel assignments
idx <- which(recolorize_obj$pixel_assignments %in% merge_vector)
px_assign[idx] <- length(orig_layers) + i
# convert to pixset
layer <- imager::as.pixset(imager::as.cimg(layer))
# and recolor (setting alpha)
cimg_obj <- imager::colorise(cimg_obj, layer, col_to)
}
# thbbt
rownames(new_centers) <- NULL
# convert back to array and add alpha channel
# i have LEARNED MY LESSON with imager alpha channels
# (highly unpredictable behavior)
as_array <- cimg_to_array(cimg_obj)
as_array <- abind::abind(as_array,
recolorize_obj$recolored_img[ , , 4],
along = 3)
# reconstruct the recolorize obj
merged_obj <- recolorize_obj
merged_obj$recolored_img <- as_array
plotImageArray(as_array)
unique(px_assign)
range(px_assign)
range(recolorize_obj$pixel_assignments)
which(recolorize_obj$pixel_assignments ==
orig_layers[i])
i
i = 1
orig_layers[i]
which(recolorize_obj$pixel_assignments ==
orig_layers[i])
devtools::load_all(".")
# filepath to image
img <- system.file("extdata/chongi.png", package = "recolorize")
# default: histogram, 2 bins/channel
recolorize(img, bins = 4)
# default: histogram, 2 bins/channel
rfit <- recolorize(img, bins = 4)
recluster(rfit, method = "merge")
test <- recluster(rfit, refit_method = "merge")
test$sizes
# filepath to image
img <- system.file("extdata/corbetti.png", package = "recolorize")
# default: histogram, 2 bins/channel
rfit <- recolorize(img, bins = 4)
test <- recluster(rfit, refit_method = "merge")
devtools::load_all(".")
test <- recluster(rfit, refit_method = "merge")
