flattened.img <- img
dim(flattened.img) <- c(img.dims[1] * img.dims[2],
img.dims[3])
img.dims
dim(img)
img
img.path <- img
img <- readImage(img.path)
bg.indexed <- backgroundIndex(img, bg.condition)
detach("package:recolorize", unload = TRUE)
library(recolorize)
# install & load package
#devtools::install_github("hiweller/recolorize")
library(recolorize)
# recolorize: simplify image colors ####
# get images that come with the package (thanks Nathan & Able!)
images <- dir(system.file("extdata/", package = "recolorize"),
pattern = "png", full.names = TRUE)
# default behavior is to bin the colors (histogram method)
# note: we don't have to specify a background because this is a PNG with
# transparency; if your background is a color use the `upper` and `lower`
# arguments
chongi_recolored <- recolorize(images[1], method = "kmeans", n = 4)
# we can also use kmeans clustering
recolorize(images[1], method = "kmeans", n = 8)
# default behavior is to bin the colors (histogram method)
# note: we don't have to specify a background because this is a PNG with
# transparency; if your background is a color use the `upper` and `lower`
# arguments
chongi_recolored <- recolorize(images[1], method = "hist", n = 2)
# save the output using writePNG
png::writePNG(chongi_recolored$recolored.img, target = "chongi_recolored.png")
# we can also use kmeans clustering
recolorize(images[1], method = "kmeans", n = 8)
# you get different clusters each time you run kmeans:
layout(matrix(1:5, nrow = 1))
for (i in 1:5) {
if (i == 1) {kmeans.repeat <- vector("list", 5)}
kmeans.repeat[[i]] <- recolorize(images[3], n = 8,
method = "kmeans",
plotting = FALSE)
plotImageArray(kmeans.repeat[[i]]$recolored.img,
main = paste0("Iteration ", i))
}
kmeans.repeat[[i]] <- recolorize(images[1], n = 8,
method = "kmeans",
plotting = FALSE)
# you get different clusters each time you run kmeans:
layout(matrix(1:5, nrow = 1))
for (i in 1:5) {
if (i == 1) {kmeans.repeat <- vector("list", 5)}
kmeans.repeat[[i]] <- recolorize(images[1], n = 8,
method = "kmeans",
plotting = FALSE)
plotImageArray(kmeans.repeat[[i]]$recolored.img,
main = paste0("Iteration ", i))
}
# you get different clusters each time you run kmeans:
layout(matrix(1:5, nrow = 1))
for (i in 1:5) {
if (i == 1) {kmeans.repeat <- vector("list", 5)}
kmeans.repeat[[i]] <- recolorize(images[1], n = 4,
method = "kmeans",
plotting = FALSE)
plotImageArray(kmeans.repeat[[i]]$recolored.img,
main = paste0("Iteration ", i))
}
# you get different clusters each time you run kmeans:
layout(matrix(1:5, nrow = 1))
for (i in 1:5) {
if (i == 1) {kmeans.repeat <- vector("list", 5)}
kmeans.repeat[[i]] <- recolorize(images[2], n = 4,
method = "kmeans",
plotting = FALSE)
plotImageArray(kmeans.repeat[[i]]$recolored.img,
main = paste0("Iteration ", i))
}
# you get different clusters each time you run kmeans:
layout(matrix(1:5, nrow = 1))
for (i in 1:5) {
if (i == 1) {kmeans.repeat <- vector("list", 5)}
kmeans.repeat[[i]] <- recolorize(images[4], n = 4,
method = "kmeans",
plotting = FALSE)
plotImageArray(kmeans.repeat[[i]]$recolored.img,
main = paste0("Iteration ", i))
}
# you get different clusters each time you run kmeans:
layout(matrix(1:5, nrow = 1))
for (i in 1:5) {
if (i == 1) {kmeans.repeat <- vector("list", 5)}
kmeans.repeat[[i]] <- recolorize(images[5], n = 4,
method = "kmeans",
plotting = FALSE)
plotImageArray(kmeans.repeat[[i]]$recolored.img,
main = paste0("Iteration ", i))
}
# with histograms, it's the same every time
layout(matrix(1:5, nrow = 1))
for (i in 1:5) {
if (i == 1) {hist.repeat <- vector("list", 5)}
hist.repeat[[i]] <- recolorize(images[5], bins = 2,
method = "hist",
plotting = FALSE)
plotImageArray(hist.repeat[[i]]$recolored.img,
main = paste0("Iteration ", i))
}
# compare binning vs. kmeans
for (i in 1:length(images)) {
# kmeans recolor
kmeans.recolor <- recolorize(images[i], method = "kmeans",
n = 8, plotting = FALSE)
# hist recolor
hist.recolor <- recolorize(images[i], method = "hist",
bins = 2, plotting = FALSE)
# plot all three side by side
layout(matrix(c(1:3), ncol = 3))
plotImageArray(kmeans.recolor$original.img, main = "original")
plotImageArray(kmeans.recolor$recolored.img, main = "kmeans")
plotImageArray(hist.recolor$recolored.img, main = "binning")
# pausing
invisible(readline(prompt = "Press [enter] to continue or [esc] to exit"))
}
# imposeColors: you can map an image to custom colors ####
# RGB extremes (white, black, red, green, blue, yellow, magenta, cyan)
ctrs <- matrix(c(1, 1, 1,
0, 0, 0,
1, 0, 0,
0, 1, 0,
0, 0, 1,
1, 1, 0,
1, 0, 1,
0, 1, 1), byrow = TRUE, ncol = 3)
# yuck (but you get the point):
sapply(1:5, function(i) imposeColors(images[i], ctrs,
adjust.centers = FALSE))
# try it out with heliconius:
heliconius <- dir(system.file("extdata", package = "colordistance"),
pattern = "Heliconius",
recursive = TRUE, full.names = TRUE)
# plot them to see what we're working with:
layout(matrix(c(1:8), nrow = 2, byrow = TRUE))
sapply(heliconius, function(i) plotImageArray(readImage(i),
main = basename(i)))
heliconius
install.packages("colordistance")
# try it out with heliconius:
# install.packages("colordistance")
heliconius <- dir(system.file("extdata", package = "colordistance"),
pattern = "Heliconius",
recursive = TRUE, full.names = TRUE)
# plot them to see what we're working with:
layout(matrix(c(1:8), nrow = 2, byrow = TRUE))
sapply(heliconius, function(i) plotImageArray(readImage(i),
main = basename(i)))
# get one set of colors...
# (notice we have to mask the white background)
heliconius.colors <- recolorize(heliconius[7],
lower = rep(0.9, 3), upper = rep(1, 3),
method = "kmeans", n = 3)
# map all the other images to those colors
for (i in 1:length(heliconius)) {
imposeColors(heliconius[i], heliconius.colors$centers,
adjust.centers = FALSE,
lower = rep(0.9, 3), upper = rep(1, 3))
} # not bad!
img_path <- "inst/extdata/chongi.png"
?assignPixels
devtools::load_all(".")
?recolorize::assignPixels
ctrs <- matrix(c(1, 1, 1,
0, 0, 0,
1, 0, 0,
0, 1, 0,
0, 0, 1,
1, 1, 0,
1, 0, 1,
0, 1, 1), byrow = TRUE, ncol = 3)
# plot it
recolorize::plotColorPalette(ctrs)
# create a pixel matrix of random colors
pixel.matrix <- matrix(runif(3000), ncol = 3)
# assign pixels
reassigned <- recolorize::assignPixels(ctrs, pixel.matrix, adjust.centers = TRUE)
recolorize::plotColorPalette(reassigned$centers)
# if we turn off adjust.centers, the colors remain the same as the inputs:
keep.centers <- recolorize::assignPixels(ctrs, pixel.matrix, adjust.centers = FALSE)
recolorize::plotColorPalette(keep.centers$centers)
# I'm not sure this is really as fast as it could be
tmp <- sapply(1:nrow(pixel.matrix),
function(i) apply(color.centers, 1,
function(v) sum((pixel.matrix[i, ]-v)^2)))
color.centers <- matrix(c(1, 1, 1,
0, 0, 0,
1, 0, 0,
0, 1, 0,
0, 0, 1,
1, 1, 0,
1, 0, 1,
0, 1, 1), byrow = TRUE, ncol = 3)
# I'm not sure this is really as fast as it could be
tmp <- sapply(1:nrow(pixel.matrix),
function(i) apply(color.centers, 1,
function(v) sum((pixel.matrix[i, ]-v)^2)))
tmp
dim(tmp)
px <- pixel.matrix[i, ]
px <- pixel.matrix[1, ]
px
v <- color.centers[1, ]
px - v
(px - v)^2
sum((px - v)^2)
sqrt(sum((px - v)^2))
dist(cbind(px, v))
cbind(px, v)
cbind(px, v)
dist(rbind(px, v))
dim(tmp)
# make returnables
pixel.assignments <- max.col(-t(tmp))  # find index of min distance
pixel.assignments
# calculate residuals
sq_residuals <- sapply(1:length(pixel.assignments),
function(j) sum((pixel.matrix[i, ] -
color.centers[pixel.assignments[i], ])^2))
# calculate residuals
sq_residuals <- sapply(1:length(pixel.assignments),
function(j) sum((pixel.matrix[j, ] -
color.centers[pixel.assignments[j], ])^2))
sq_residuals
hist(sq_residuals)
unique(pixel.assignments)
unique(pixel.assignments) %in% 1:nrow(color.centers)
sum(unique(pixel.assignments) %in% 1:nrow(color.centers))
isTRUE(unique(pixel.assignments) %in% 1:nrow(color.centers))
any(unique(pixel.assignments) %in% 1:nrow(color.centers))
any(unique(pixel.assignments) !%in% 1:nrow(color.centers))
any(!unique(pixel.assignments) %in% 1:nrow(color.centers))
any(!runif(50, min = 1, max = 100) %in% 1:nrow(color.centers))
?hist()
devtools::load_all(".")
?colorResiduals
# RGB extremes (white, black, red, green, blue, yellow, magenta, cyan)
ctrs <- matrix(c(1, 1, 1,
0, 0, 0,
1, 0, 0,
0, 1, 0,
0, 0, 1,
1, 1, 0,
1, 0, 1,
0, 1, 1), byrow = TRUE, ncol = 3)
# plot it
recolorize::plotColorPalette(ctrs)
# create a pixel matrix of random colors
pixel.matrix <- matrix(runif(3000), ncol = 3)
# assign pixels
# see `assignPixels` function for details
reassigned <- assignPixels(ctrs, pixel.matrix, adjust.centers = TRUE)
# find residuals from original color centers
color_residuals <- colorResiduals(pixel.matrix = pixel.matrix,
pixel.assignments = reassigned$pixel.assignments,
color.centers = ctrs)
# compare to residuals from adjusted color centers
color_residuals_adjust <- colorResiduals(pixel.matrix = pixel.matrix,
pixel.assignments = reassigned$pixel.assignments,
color.centers = reassigned$centers)
layout(matrix(1:2, nrow = 2))
hist(color_residuals$sq_residuals,
breaks = 50, border = NA, col = "tomato",
main = "Original centers")
hist(color_residuals_adjust$sq_residuals,
breaks = 50, border = NA, col = "cornflowerblue",
main = "Adjusted centers")
?colorResiduals
pixel.matrix <- matrix(runif(3000), ncol = 3)
# assign pixels
# see `assignPixels` function for details
reassigned <- assignPixels(ctrs, pixel.matrix, adjust.centers = TRUE)
# find residuals from original color centers
color_residuals <- colorResiduals(pixel.matrix = pixel.matrix,
pixel.assignments = reassigned$pixel.assignments,
color.centers = ctrs)
# compare to residuals from adjusted color centers
color_residuals_adjust <- colorResiduals(pixel.matrix = pixel.matrix,
pixel.assignments = reassigned$pixel.assignments,
color.centers = reassigned$centers)
layout(matrix(1:2, nrow = 2))
hist(color_residuals$sq_residuals,
breaks = 30, border = NA, col = "tomato",
xlim = c(0, 1), xlab = "Squared residual",
main = "Original centers")
hist(color_residuals_adjust$sq_residuals,
breaks = 30, border = NA, col = "cornflowerblue",
xlim = c(0, 1), xlab = "Squared residual",
main = "Adjusted centers")
?residuals
?hist
devtools::load_all(".")
devtools::load_all(".")
?classifyColorManual
# filepath to image
img <- system.file("extdata/chongi.png", package = "recolorize")
# default: histogram, 2 bins/channel
classifyColorManual(img)
# we can also have different numbers of bins per channel
classifyColorManual(img, bins = c(4, 1, 1)) # mostly red
classifyColorManual(img, bins = c(1, 4, 1)) # mostly green
classifyColorManual(img, bins = c(1, 1, 4)) # mostly blue
# kmeans can produce a better fit with fewer colors
classifyColorManual(img, method = "kmeans", n = 8)
# increasing numbers of kmean colors
recolored.images <- setNames(vector("list", length = 10), c(1:10))
for (i in 1:10) {
recolored.images[[i]] <- classifyColorManual(img, method = "kmeans",
n = i)
}
layout(matrix(1:10, nrow = 2))
lapply(recolored.images,
function(i) hist(i$color.residuals$sq_residuals,
border = NA, main = paste(i, "clusters")), freq = FALSE,
xlim = c(0, 1))
recolored.images$1
recolored.images
recolored.images$1
as.character(c(1:10))
as.character(c(1:10))
# increasing numbers of kmean colors
recolored.images <- setNames(vector("list", length = 10),
as.character(c(1:10)))
for (i in 1:10) {
recolored.images[[i]] <- classifyColorManual(img, method = "kmeans",
n = i)
}
recolored.images$1
# increasing numbers of kmean colors
recolored.images <- setNames(vector("list", length = 10),
as.character(c(1:10)))
recolored.images
for (i in 1:10) {
recolored.images[[i]] <- classifyColorManual(img, method = "kmeans",
n = i)
}
# increasing numbers of kmean colors
recolored.images <- setNames(vector("list", length = 10))
# increasing numbers of kmean colors
recolored.images <- vector("list", length = 10)
for (i in 1:10) {
recolored.images[[i]] <- classifyColorManual(img, method = "kmeans",
n = i)
}
layout(matrix(1:10, nrow = 2))
lapply(recolored.images,
function(i) hist(i$color.residuals$sq_residuals,
border = NA, main = paste(i, "clusters")), freq = FALSE,
xlim = c(0, 1))
recolored.images[[1]]
recolored.images[[1]]$color.residuals$sq_residuals
lapply(recolored.images, function(i) hist(i$color.residuals$sq_residuals))
lapply(recolored.images,
function(i) hist(i$color.residuals$sq_residuals))
lapply(recolored.images,
function(i) hist(i$color.residuals$sq_residuals,
border = NA))
lapply(recolored.images,
function(i) hist(i$color.residuals$sq_residuals,
border = NA, main = paste(i, "clusters")))
lapply(recolored.images,
function(i) hist(i$color.residuals$sq_residuals,
border = NA, main = paste(i, "clusters")))
sapply(1:length(recolored.images),
function(i) hist(recolored.images[[i]]$color.residuals$sq_residuals,
border = NA, main = paste(i, "clusters")))
layout(matrix(1:10, nrow = 2))
sapply(1:length(recolored.images),
function(i) hist(recolored.images[[i]]$color.residuals$sq_residuals,
border = NA, main = paste(i, "clusters")))
sapply(1:length(recolored.images),
function(i) hist(recolored.images[[i]]$color.residuals$sq_residuals,
border = NA, main = paste(i, "cluster(s)"),
freq = FALSE, xlim = c(0, 1)))
layout(matrix(1:10, nrow = 2, byrow = TRUE))
sapply(1:length(recolored.images),
function(i) hist(recolored.images[[i]]$color.residuals$sq_residuals,
border = NA, main = paste(i, "cluster(s)"),
freq = FALSE, xlim = c(0, 1)))
sapply(1:length(recolored.images),
function(i) hist(recolored.images[[i]]$color.residuals$sq_residuals,
border = NA, main = paste(i, "cluster(s)"),
freq = FALSE, xlab = "Squared residual",
xlim = c(0, 1)), ylim = c(0, 50))
sapply(1:length(recolored.images),
function(i) hist(recolored.images[[i]]$color.residuals$sq_residuals,
border = NA, main = paste(i, "cluster(s)"),
freq = FALSE, xlab = "Squared residual",
xlim = c(0, 1)))
residual_vec <- sapply(1:length(recolored.images),
function(i) recolored.images[[i]]$color.residuals$tot_residuals)
plot(residual_vec, type = 'b')
plot(residual_vec, type = 'b')
devtools::load_all(".")
?colorResiduals
?classifyColorManual
plot(residual_vec, type = 'b',
ylab = "Sum of squared residuals",
xlab = "Cluster number")
werner <- read.csv("../werner_nomenclature/werner_colors.csv")
hex <- werner$hex
rgb <- werner[grep("rgb", colnames(werner)), ]
rgb
grep("rgb", colnames(werner))
rgb <- werner[ , grep("rgb", colnames(werner))]
rgb
hex_palette <- werner$hex
rgb_palette <- werner[ , grep("rgb", colnames(werner))]
werner <- read.csv("../werner_nomenclature/werner_colors.csv")
hex_palette <- werner$hex
rgb_palette <- werner[ , grep("rgb", colnames(werner))]
hex_palette
rgb_palette
devtools::load_all(".")
plotColorPalette(rgb_palette)
plotColorPalette(rgb_palette, cex.text = 0)
plotColorPalette(rgb_palette, cex.text = NA)
par(mar = rep(0, 4))
plotColorPalette(rgb_palette, cex.text = NA)
plotColorPalette(rgb_palette)
plotColorPalette(rgb_palette, horiz = FALSE)
is.numeric(rgb_palette)
is.numeric(rgb_palette$rgb_R)
dim(rgb_palette)
typeof(rgb_palette)
typeof(hex_palette)
class(rgb_palette)
class(hex_palette)
grep("#", hex_palette)
is.vector(hex_palette)
is.vector(rgb_palette)
dim(hex_palette)
dim(rgb_palette)
dim(hex_palette) == 2
dim(rgb_palette) == c(110, 3)
dim(rgb_palette)[2] == 3
dim(hex_palette)[2] == 2
if(dim(hex_palette)[2] == 2) {print("i")}
plotColorPalette <- function(color.centers, sizes = NULL,
cex.text = 2, horiz = TRUE, ...) {
# check if hex codes
if (is.vector(color.centers)) {
if (sum(grepl("#", color.centers)) == length(color.centers)) {
rgb.exp <- color.centers
} else {
stop("'color.centers' must be either a numeric RGB matrix with colors\n
as rows or a character vector of hex codes")
}
} else if (dim(color.centers)[2] != 3) {
stop("'color.centers' must have colors as rows and RGB coordinates as columns")
}
# make color vector
rgb.exp <- grDevices::rgb(color.centers[, 1],
color.centers[, 2],
color.centers[, 3])
# make a plot
if (is.null(sizes)) {
# if sizes are not included, make bars equal in size
colorbar <- rep(1, nrow(color.centers))
stats::setNames(colorbar, as.character(1:nrow(color.centers)))
# we're making the palettes in different ways, so horizontal plotting is
# reversed; this makes it consistent
horiz <- !horiz
} else {
# if so, make a fake "table" with counts
# this is a bit hacky, but it does make the bars adjacent instead of stacked
sizes <- sizes / sum(sizes)
sizes <- round(sizes * 1000)
colorbar <- unlist(sapply(1:length(sizes),
function(j) rep(j, sizes[j])))
colorbar <- table(colorbar, rep("", length(colorbar)))
# remove any empty values
if (any(sizes == 0)) {
rgb.exp <- rgb.exp[-which(sizes == 0)]
}
}
# plot the colors as a uniform bar
graphics::barplot(colorbar, col = rgb.exp,
axes = FALSE, space = 0, horiz = horiz,
border = NA, axisnames = FALSE, ...)
# text colors - black if the color is light, white if the color is dark
hsv.exp <- grDevices::rgb2hsv(t(color.centers), maxColorValue = 1)
text.colors <- round(hsv.exp[3, ]) + 1
# make text locations
if (horiz == FALSE) {
text.x <- seq(0.5, length(rgb.exp) - 0.5)
text.y <- 0.5
} else {
text.y <- seq(0.5, length(rgb.exp) - 0.5)
text.x <- 0.5
}
# only plot numbers if the sizes are equal
# when they're distorted by sizes it gets too wacky
if (is.null(sizes) & cex.text > 0) {
graphics::text(text.x, text.y,
cex = cex.text,
col = c("white", "black")[text.colors])
}
}
plotColorPalette(rgb_palette, cex.text = 0)
colordistance::plotClusters(cbind(rgb_palette, Pct = rep(1 / 110, 110)))
colordistance::plotClusters(cbind(rgb_palette, Pct = rep(1 / 200, 110)))
rand.colors <- matrix(runif(30), ncol = 3)
rand.colors
rgb(rand.colors)
