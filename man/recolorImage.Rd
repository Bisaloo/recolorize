% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/recolorImage.R
\name{recolorImage}
\alias{recolorImage}
\title{Recolor an image after color clustering}
\usage{
recolorImage(
  bg.indexed,
  color.clusters,
  plotting = FALSE,
  main = "",
  remove.empty.clusters = FALSE,
  bg.recolor = "transparent"
)
}
\arguments{
\item{bg.indexed}{An object of class \code{bg.index}, the output of
\code{\link[recolorize]{backgroundIndex}}.}

\item{color.clusters}{An object of class \code{color.clusters}, the output of
\code{\link[recolorize]{colorClusters}}.}

\item{plotting}{Logical. Plot recolored image results?}

\item{main}{Plot title.}

\item{remove.empty.clusters}{Logical. If no pixels are assigned to a given
color cluster, should that cluster be returned by the function, or dropped?}

\item{bg.recolor}{One of either "transparent" or "white", for masking the
background in the recolored image. See details.}
}
\value{
A list with the following attributes:
\enumerate{
\item \code{recolored.img}: The recolored image, as an RGB array.
\item \code{centers}: The colors to which the recolored image were mapped.
}
}
\description{
Recolors an image after each pixel has been assigned to a particular color.
Combines the input of \code{\link[recolorize]{backgroundIndex}} and
\code{\link[recolorize]{colorClusters}}.
}
\details{
This function works by taking in:
\enumerate{
\item A vector of pixel assignments, where each number represents the
color cluster to which the pixel at that index was assigned;
\item A matrix of colors centers whose order is assumed to match that of
the pixel assignments
\item An RGB array whose pixel locations are assumed to match those of
the pixel assignments.
}

This is all kept organized by keeping these data together in the \code{bg.index} and \code{color.clusters}
classes, and because this function is mostly called internally by \code{\link[recolorize]{imposeColors}}
and \code{\link[recolorize]{recolorize}}. However, it does present the user
with opportunities to remap colors at random by reshuffling or swapping the color centers
in the \code{color.clusters} object. This could be useful for a number of things,
such as testing analytical or color clustering robustness, or otherwise
ruining a nice image with math.

For background masking, the two provided options (white or transparent) will
look identical when plotted within R. The difference is that transparent
background masking adds an alpha channel (thus retaining the RGB values of the background),
while "white" will overwrite those values.
}
\examples{
# load image (recolorize and imposeColors do this automatically)
img <- system.file("extdata/corbetti.png", package = "recolorize")
bg.condition <- backgroundCondition(transparent = TRUE,
                                    alpha.channel = TRUE)
bg.indexed <- backgroundIndex(img, bg.condition)

# histogram binning
hist.colors <- colorClusters(bg.indexed$non.bg,
                             method = "hist", bins = 2)

# shuffle colors
shuffle <- function(m) {
  m[sample(1:nrow(m), nrow(m)), ]
}
hist.shuffle$centers <- shuffle(hist.shuffle$centers)

# recolor based on the two cluster sets
hist.recolor <- recolorImage(bg.indexed, hist.colors)
shuffle.recolor <- recolorImage(bg.indexed, hist.shuffle)

# plot them
layout(matrix(c(1, 2, 3), ncol = 3))
plotImageArray(img, main = "original")
plotImageArray(hist.recolor$recolored.img, main = "binning")
plotImageArray(shuffle.recolor$recolored.img, main = "shuffled colors")

}
